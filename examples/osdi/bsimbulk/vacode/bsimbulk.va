// ****************************************************************************
// *  BSIM-BULK 107.0.0 released by Ravi Goel on 03/04/2020                   *
// *  BSIM Bulk MOSFET Model Equations (Verilog-A)                            *
// ****************************************************************************

// ****************************************************************************
// *  Copyright (c) 2020 University of California                             *
// *                                                                          *
// *  Project director: Prof. Chenming Hu, Prof.Sayeef Salahuddin             *
// *                                                                          *
// *  Current developers: Ravi Goel (Ph.D. student, IIT Kanpur)               *
// *                      Prof. Yogesh Chauhan (IIT Kanpur)                   *
// *                      Dr. Harshit Agarwal (Postdoc, UC Berkeley)          *
// *                      Dr. Pragya Kushwaha (Postdoc, UC Berkeley)          *
// *                                                                          *
// *  Past developers:    Chetan Gupta  (IIT Kanpur)                          *
// *                      Dr. Huan-Lin Chang (UC Berkeley)                    *
// *                      Sriramkumar Venugopalan, (UC Berkeley)              *
// *                      M. A. Karim (UC Berkeley)                           *
// ****************************************************************************

/*
Licensed under Educational Community License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain a copy of the license at
http://opensource.org/licenses/ECL-2.0
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations
under the License.
The BSIM-BULK standard has been supported by the members of Silicon Integration Initiative's Compact Model Coalition.
A link to the most recent version of this standard can be found at:
http://www.si2.org/cmc 
*/

`include "constants.vams"
`include "disciplines.vams"

// Disable strobe for improved performance speed
// To Use DISABLE_STROBE, Activate it here. Used Only at GEOMOD and RGEOMOD
// `define DISABLE_STROBE
`ifdef DISABLE_STROBE
    `define STROBE(X)
    `define STROBE2(X,Y)
`else
    `define STROBE(X) $strobe(X)
    `define STROBE2(X,Y) $strobe(X,Y)
`endif

// Junction capacitance macro between S/D and bulk
`define JunCap(Czbx, Vbx_jct, PBX_t, MJX, czbx_p1, czbx_p2, Qbxj) \
    if (Czbx > 0.0) begin \
        T1 = Vbx_jct / PBX_t; \
        if (T1 < 0.9) begin \
            arg = 1.0 - T1; \
            if (MJX == 0.5) begin \
                sarg = 1.0 / sqrt(arg); \
            end else begin \
                sarg = lexp(-MJX * lln(arg)); \
            end \
            Qbxj = PBX_t * Czbx * (1.0 - arg * sarg) / (1.0 - MJX); \
        end else begin \
            T2  = czbx_p1 * (T1 - 1.0) * (5.0 * MJX * (T1 - 1.0) + (1.0 + MJX)); \
            Qbxj = PBX_t * Czbx * (T2 + czbx_p2); \
        end \
    end else begin \
        Qbxj = 0.0; \
    end \

// Normalized pinch-off voltage including PD
`define PO_psip(vg_vfb, gamma, DPD, phif, psip) \
    T1       = 1.0 + DPD; \
    vgfbPD   = vg_vfb / T1; \
    gammaPD  = gamma / T1; \
    T1       = 0.5 * vgfbPD - 3.0 * (1.0 + gammaPD / `M_SQRT2); \
    T2       = T1 + sqrt(T1 * T1 + 6.0 * vgfbPD); \
    if (vgfbPD < 0.0) begin \
        T3   = (vgfbPD - T2) / gammaPD; \
        psip = -lln(1.0 - T2 + T3 * T3); \
    end else begin \
        T3   = lexp(-T2); \
        T1   = 0.5 * gammaPD; \
        T2   = sqrt(vgfbPD - 1.0 + T3 + T1 * T1) - T1; \
        psip = T2 * T2 + 1.0 - T3; \
    end \

// Normalized charge-voltage relationship
`define BSIM_q(psip, phib, vch, gam, q) \
    T8 = 0.5 * (psip + 1.0 + sqrt((psip - 1.0) * (psip - 1.0) + 0.25 * 2.0 * 2.0)); \
    sqrtpsip = sqrt(T8); \
    T9 = 1.0 + gam / (2.0 * sqrtpsip); \
    T0 = (1.0 + (gam / (2.0 * sqrtpsip))) / gam; \
    T1 = psip - 2.0 * phib - vch; \
    T2 = T1 - lln(4.0 * T0 * sqrtpsip); \
    T8 = 0.5 * (T2 - 0.201491 - sqrt(T2 * (T2 + 0.402982) + 2.446562)); \
    sqrtpsisa = sqrtpsip; \
    if (T8 <= -68.0) begin \
        T4 = -100.0; \
        T5 = 20.0; \
        if (T8 < T4 - 0.5 * T5) \
            T3 = lexp(T4); \
        else begin \
            if (T8 > T4 + 0.5 * T5) \
                T3 = lexp(T8); \
            else begin \
                T2 = (T8 - T4) / T5; \
                T6 = T2 * T2; \
                T3 = lexp(T4 + T5 * ((5.0 / 64.0) + 0.5 * T2 + T6 * ((15.0 / 16.0) - T6 * (1.25 - T6)))); \
            end \
        end \
        q = T3 * (1.0 + T1 - T8 - lln(2.0 * T0 * (T3 * 2.0 * T0 + 2.0 * sqrtpsisa))); \
    end else begin \
        T3 = lexp(T8); \
        sqrtpsisainv = 1.0 / sqrtpsisa; \
        T4 = 2.0 * T3 + lln(T3 * 2.0 * T0 * (T3 *  2.0 * T0 + 2.0 * sqrtpsisa)) - T1; \
        T5 = 2.0 + (1.0 / T3) + (T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa); \
        T3 = T3 - T4 / T5; \
        T4 = 2.0 * T3 + lln(T3 * 2.0 * T0 * (T3 * 2.0 * T0 + 2.0 * sqrtpsisa)) - T1; \
        T5 = 2.0 + (1.0 / T3) + (T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa); \
        T6 = ((T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa)) * ((T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa)); \
        T7 = -((1.0 / T3) * (1.0 / T3)) - (1.0 / (sqrtpsisa * sqrtpsisa * sqrtpsisa * (T0 * T3 + sqrtpsisa))) - T6; \
        q  = T3 - (T4 / T5) * (1.0 + T4 * T7 / (2.0 * T5 * T5)); \
    end \

// Smoothing function for (max of x, x0 with deltax)
`define Smooth(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)); \

// Smoothing function for (max of x, x0 with deltax)
`define Smooth1(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)) - 0.25 * deltax; \

// Smoothing function for (min of x, x0 with deltax)
`define Smooth2(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)) + 0.25 * deltax; \

// Smoothing function for (min of x, x0 with deltax)
`define Min1(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)); \

 // These macros represent the subroutines to process the geometry dependent
 // parasitics for BSIM-BULK, which calculates Ps, Pd, As, Ad, and Rs and Rd
 // for multi-fingers and various GEO and RGEO options.

// Define GEOMOD and RGEOMOD in the modelcard
`define BSIMBULKNumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    if ((nf % 2) != 0) begin \
        nuEndD = 1.0; \
        nuEndS = 1.0; \
        nuIntD = 2.0 * max((nf - 1.0) / 2.0, 0.0); \
        nuIntS = nuIntD; \
    end else begin \
        if (minSD == 1) begin \
            nuEndD = 2.0; \
            nuIntD = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
            nuEndS = 0.0; \
            nuIntS = nf; \
        end else begin \
            nuEndD = 0.0; \
            nuIntD = nf; \
            nuEndS = 2.0; \
            nuIntS = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
        end \
    end

`define BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, SRCFLAG, Rend) \
    if (SRCFLAG == 1) begin \
        case(rgeo) \
        1, 2, 5: begin \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end else begin \
                Rend = Rsh * DMCG / (Weffcj * nuEnd); \
            end \
        end \
        3, 4, 6: begin \
            if ((DMCG + DMCI) == 0.0) begin \
                `STROBE("(DMCG + DMCI) can not be equal to zero"); \
            end \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end else begin \
                Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
            end \
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified RGEO = %d not matched (BSIMBULKRdsEndIso), Rend is set to zero.", rgeo); \
            Rend = 0.0; \
        end \
        endcase \
    end else begin \
        case(rgeo) \
        1, 3, 7: begin \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end else begin \
                Rend = Rsh * DMCG / (Weffcj * nuEnd); \
            end \
        end \
        2, 4, 8: begin \
            if ((DMCG + DMCI) == 0.0) begin \
                `STROBE("(DMCG + DMCI) can not be equal to zero"); \
            end \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end \
            else begin \
                Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
            end \
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIMBULKRdsEndIso type 2), Rend is set to zero.", rgeo); \
            Rend = 0.0; \
        end \
        endcase \
    end

`define BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, SRCFLAG, Rend) \
    begin \
        if (SRCFLAG == 1) begin \
            case(rgeo) \
            1, 2, 5: begin \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end else begin \
                    Rend = Rsh * DMCG / (Weffcj * nuEnd); \
                end \
            end \
            3, 4, 6: begin \
                if (DMCG == 0.0) begin \
                    `STROBE("DMCG can not be equal to zero"); \
                end \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end \
                else begin \
                    Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
                end \
            end \
            default: begin \
                `STROBE2("Warning: (instance %M) Specified RGEO = %d not matched (BSIMBULKRdsEndSha), Rend is set to zero.", rgeo); \
                Rend = 0.0; \
            end \
            endcase \
        end else begin \
            case(rgeo) \
            1, 3, 7: begin \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end else begin \
                    Rend = Rsh * DMCG / (Weffcj * nuEnd); \
                end \
            end \
            2, 4, 8: begin \
                if (DMCG == 0.0) begin \
                    `STROBE("DMCG can not be equal to zero"); \
                end \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end \
                else begin \
                    Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
                end \
            end \
            default: begin \
                `STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIMBULKRdsEndSha \
                type 2), Rend is set to zero.", rgeo); \
                Rend = 0.0; \
            end \
            endcase \
        end \
    end

`define BSIMBULKRdseffGeo(nf, geo, rgeo, minSD, Weffcj, Rsh, DMCG, DMCI, DMDG, SRCFLAG, Rtot) \
    begin \
        if (geo < 9) begin \
            `BSIMBULKNumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
            if (SRCFLAG == 1) begin \
                if (nuIntS == 0.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntS); \
                end \
            end \
            else begin \
                if (nuIntD == 0.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntD); \
                end \
            end \
        end \
        case(geo) \
        0: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        1: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        2: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        3: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        4: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                Rend = Rsh * DMDG / Weffcj; \
            end \
        end \
        5: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                    if (nuEndD==0) begin\
                        Rend = 0;\
                    end else begin \
                    Rend = Rsh * DMDG / (Weffcj * nuEndD); \
                    end \
                end\
        end \
        6: begin \
            if (SRCFLAG == 1) begin \
                Rend = Rsh * DMDG / Weffcj; \
            end else begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        7:begin \
            if (SRCFLAG == 1) begin \
                    if (nuEndS == 0) begin \
                        Rend = 0; \
                    end else begin \
                        Rend = Rsh * DMDG / (Weffcj * nuEndS); \
                    end \
            end else \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
        end \
        8: begin \
            Rend = Rsh * DMDG / Weffcj; \
        end \
        9: begin /* all wide contacts assumed for geo = 9 and 10 */\
            if (SRCFLAG == 1) begin \
                Rend = 0.5 * Rsh * DMCG / Weffcj; \
                if (nf == 2.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
                end \
            end \
            else begin \
                Rend = 0.0; \
                Rint = Rsh * DMCG / (Weffcj * nf); \
            end \
        end \
        10: begin \
            if (SRCFLAG == 1) begin \
                Rend = 0.0; \
                Rint = Rsh * DMCG / (Weffcj * nf); \
            end \
            else begin \
                Rend = 0.5 * Rsh * DMCG / Weffcj; \
                if (nf == 2.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
                end \
            end \
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified GEO=%d not matched (BSIMBULKRdseffGeo), Rint is set to zero.", geo); \
            Rint = 0.0; \
        end \
        endcase \
        if (Rint <= 0.0) begin \
            Rtot = Rend; \
        end else if (Rend <= 0.0) begin \
            Rtot = Rint; \
        end else begin \
            Rtot = Rint * Rend / (Rint + Rend); \
        end \
        if (Rtot==0.0) begin \
            `STROBE("Warning: (instance %M) Zero resistance returned from RdseffGeo"); \
        end \
    end

// Effective PS, PD, AS, AD calculation, Ref: BSIM4
`define BSIMBULKPAeffGeo(nf, geo, minSD,Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad) \
    begin if (geo < 9) \
    `BSIMBULKNumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    T0 = DMCG + DMCI;\
    T1 = DMCG + DMCG;\
    T2 = DMDG + DMDG;\
    PSiso = T0 + T0 + Weffcj;\
    PDiso = T0 + T0 + Weffcj;\
    PSsha = T1;\
    PDsha = T1;\
    PSmer = T2;\
    PDmer = T2;\
    ASiso = T0 * Weffcj;\
    ADiso = T0 * Weffcj;\
    ASsha = DMCG * Weffcj;\
    ADsha = DMCG * Weffcj;\
    ASmer = DMDG * Weffcj;  \
    ADmer = DMDG * Weffcj;  \
        case(geo) \
        0: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha;\
            Pd = nuEndD * PDiso + nuIntD * PDsha;\
            As = nuEndS * ASiso + nuIntS * ASsha;\
            Ad = nuEndD * ADiso + nuIntD * ADsha;\
        end \
        1: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha;\
            Pd = (nuEndD + nuIntD) * PDsha;\
            As = nuEndS * ASiso + nuIntS * ASsha;\
            Ad = (nuEndD + nuIntD) * ADsha;\
        end \
        2: begin \
            Ps = (nuEndS + nuIntS) * PSsha;\
            Pd = nuEndD * PDiso + nuIntD * PDsha;\
            As = (nuEndS + nuIntS) * ASsha;\
            Ad = nuEndD * ADiso + nuIntD * ADsha;\
        end \
        3: begin \
            Ps = (nuEndS + nuIntS) * PSsha;\
            Pd = (nuEndD + nuIntD) * PDsha;\
            As = (nuEndS + nuIntS) * ASsha;\
            Ad = (nuEndD + nuIntD) * ADsha;\
        end \
        4: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha;\
            Pd = nuEndD * PDmer + nuIntD * PDsha;\
            As = nuEndS * ASiso + nuIntS * ASsha;\
            Ad = nuEndD * ADmer + nuIntD * ADsha;\
        end \
        5: begin \
            Ps = (nuEndS + nuIntS) * PSsha;\
            Pd = nuEndD * PDmer + nuIntD * PDsha;\
            As = (nuEndS + nuIntS) * ASsha;\
            Ad = nuEndD * ADmer + nuIntD * ADsha;\
        end \
        6: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha;\
            Pd = nuEndD * PDiso + nuIntD * PDsha;\
            As = nuEndS * ASmer + nuIntS * ASsha;\
            Ad = nuEndD * ADiso + nuIntD * ADsha;\
        end \
        7: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha;\
            Pd = (nuEndD + nuIntD) * PDsha;\
            As = nuEndS * ASmer + nuIntS * ASsha;\
                    Ad = (nuEndD + nuIntD) * ADsha;\
        end \
        8: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha;\
        Pd = nuEndD * PDmer + nuIntD * PDsha;\
            As = nuEndS * ASmer + nuIntS * ASsha;\
            Ad = nuEndD * ADmer + nuIntD * ADsha;\
        end \
        9: begin \
            Ps = PSiso + (nf - 1.0) * PSsha;\
            Pd = nf * PDsha;\
            As = ASiso + (nf - 1.0) * ASsha;\
            Ad = nf * ADsha;\
        end \
        10: begin \
            Ps = nf * PSsha;\
            Pd = PDiso + (nf - 1.0) * PDsha;\
            As = nf * ASsha;\
            Ad = ADiso + (nf - 1.0) * ADsha;\
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified GEO=%d not matched (BSIMBULKPAeffGeo \
            ), PS,PD,AS,AD set to zero.", geo); \
            Ps = 0;\
            Pd = 0;\
            As = 0;\
            Ad = 0;\
        end \
        endcase \
    end \

// Numerical Constants
`define EXPL_THRESHOLD  80.0
`define MAX_EXPL        5.540622384e34
`define MIN_EXPL        1.804851387e-35
`define N_MINLOG        1.0e-38
`define DELTA_1         0.02
`define Oneby3          0.33333333333333333
`define REFTEMP         300.15       // 27 degrees C

// Physical Constants
`define ntype       1
`define ptype       -1
`define q           1.60219e-19
`define EPS0        8.85418e-12
`define KboQ        8.617087e-5      // Joule/degree

//  Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     ||
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     cz    closed lower bound=0, open upper bound=inf
//     oz    open   lower bound=0, open upper bound=inf
//     nb    no bounds
//     ex    no bounds with exclude
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  IPM   instance parameter mFactor(multiplicity, implicit for LRM 2.2)
//  OPP   operating point parameter, includes units and description for printing

`define OPP(nam,uni,des)               (* units=uni, desc=des *)           real    nam;
`define OPM(nam,uni,des)               (* units=uni, desc=des, multiplicity="multiply" *)  real    nam;
`define OPD(nam,uni,des)               (* units=uni, desc=des, multiplicity="divide"   *)  real    nam;

`define MPRnb(nam,def,uni,        des) (* units=uni, desc=des *) parameter real    nam=def;
`define MPRex(nam,def,uni,exc,    des) (* units=uni, desc=des *) parameter real    nam=def exclude exc;
`define MPRcc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from[lwr:upr];
`define MPRoo(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from(lwr:upr);
`define MPRco(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from[lwr:upr);
`define MPRoc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from(lwr:upr];
`define MPRcz(nam,def,uni,        des) (* units=uni, desc=des *) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (* units=uni, desc=des *) parameter real    nam=def from(  0:inf);

`define MPInb(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def;
`define MPIex(nam,def,uni,exc,    des) (* units=uni, desc=des *) parameter integer nam=def exclude exc;
`define MPIcc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from[lwr:upr];
`define MPIoo(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from(lwr:upr);
`define MPIco(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from[lwr:upr);
`define MPIoc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from(lwr:upr];
`define MPIcz(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from[  0:inf);
`define MPIoz(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from(  0:inf);
`define MPIsw(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from[  0:  1];
`define MPIty(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from[ -1:  1] exclude 0;
`define IPRnb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def;
`define IPRex(nam,def,uni,exc,    des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def exclude exc;
`define IPRcc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from[lwr:upr];
`define IPRoo(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from(lwr:upr);
`define IPRco(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from[lwr:upr);
`define IPRoc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from(lwr:upr];
`define IPRcz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from[  0:inf);
`define IPRoz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from(  0:inf);
`define IPInb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def;
`define IPIex(nam,def,uni,exc,    des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def exclude exc;
`define IPIcc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from[lwr:upr];
`define IPIoo(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from(lwr:upr);
`define IPIco(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from[lwr:upr);
`define IPIoc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from(lwr:upr];
`define IPIcz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from[  0:inf);
`define IPIoz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from(  0:inf);
`define BPRco(nam, def, uni, lwr, upr, des) (* units = uni, type = "instance", desc = des *) parameter real    nam = def from[lwr : upr);
`define BPRoz(nam, def, uni,           des) (* units = uni, type = "instance", desc = des *) parameter real    nam = def from(0.0 : inf);
`define BPRcz(nam, def, uni,           des) (* units = uni, type = "instance", desc = des *) parameter real    nam = def from[0.0 : inf);
`define BPIcc(nam, def, uni, lwr, upr, des) (* units = uni, type = "instance", desc = des *) parameter integer nam = def from[lwr : upr];
`define BPInb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def;
`define BPRnb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real nam=def;

module bsimbulk(d, g, s, b, t);
inout d, g, s, b, t;
electrical d, g, s, b, di, si, gi, gm, bi, sbulk, dbulk;
thermal t;

// Extra internal nodes and branches (TNOIMOD=1) for correlated drain and gate noise
electrical N1, N2;
branch (N1) NI;
branch (N1) NR;
branch (N1) NC;

// Clamped exponential function
analog function real lexp;
    input x;
    real x;
    begin
        if (x > `EXPL_THRESHOLD) begin
            lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
        end else if (x < -`EXPL_THRESHOLD) begin
            lexp = `MIN_EXPL;
        end else begin
            lexp = exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input x;
    real x;
    begin
        lln = ln(max(x, `N_MINLOG));
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input x, c;
    real x, c;
    begin
        hypsmooth = 0.5 * (x + sqrt(x * x + 4.0 * c * c));
    end
endfunction

// Pure instance parameters
`IPRoz( L                 ,1.0e-5                                   ,"m"                                     ,"Length" )
`IPRoz( W                 ,1.0e-5                                   ,"m"                                     ,"Total width including fingers" )
`IPIco( NF                ,1                                        ,""            ,1           ,inf         ,"Number of fingers" )
`IPRcz( NRS               ,1.0                                      ,""                                      ,"Number of squares in source" )
`IPRcz( NRD               ,1.0                                      ,""                                      ,"Number of squares in drain" )
`IPRnb( VFBSDOFF          ,0.0                                      ,"V"                                     ,"Flatband voltage offset parameter" )
`IPIcc( MINZ              ,0                                        ,""            ,0           ,1           ,"Minimize either drain or source" )
`IPIcc( RGATEMOD          ,0                                        ,""            ,0           ,3           ,"Gate resistance model selector" )
`IPIcc( RBODYMOD          ,0                                        ,""            ,0           ,2           ,"Distributed body R model" )
`IPIcc( GEOMOD            ,0                                        ,""            ,0           ,10          ,"Geometry-dependent parasitics model" )
`IPIcc( RGEOMOD           ,0                                        ,""            ,0           ,8           ,"Geometry-dependent source/drain resistance,  0: RSH-based, 1: Holistic" )
`IPRcz( RBPB              ,50.0                                     ,"ohm"                                   ,"Resistance between bNodePrime and bNode" )
`IPRcz( RBPD              ,50.0                                     ,"ohm"                                   ,"Resistance between bNodePrime and bNode" )
`IPRcz( RBPS              ,50.0                                     ,"ohm"                                   ,"Resistance between bNodePrime and sbNode" )
`IPRcz( RBDB              ,50.0                                     ,"ohm"                                   ,"Resistance between bNode and dbNode" )
`IPRcz( RBSB              ,50.0                                     ,"ohm"                                   ,"Resistance between bNode and sbNode" )
`IPRnb( SA                ,0.0                                      ,"m"                                     ,"Distance between OD edge from poly from one side" )
`IPRnb( SB                ,0.0                                      ,"m"                                     ,"Distance between OD edge from poly from other side" )
`IPRnb( SD                ,0.0                                      ,"m"                                     ,"Distance between neighboring fingers" )
`IPRoo( SCA               ,0.0                                      ,""            ,-inf        ,inf         ,"Integral of the first distribution function for scattered well dopants" )
`IPRoo( SCB               ,0.0                                      ,""            ,-inf        ,inf         ,"Integral of second distribution function for scattered well dopants" )
`IPRoo( SCC               ,0.0                                      ,""            ,-inf        ,inf         ,"Integral of third distribution function for scattered well dopants" )
`IPRoo( SC                ,0.0                                      ,"m"           ,-inf        ,inf         ,"Distance to a single well edge; if <= 0.0, turn off WPE" )
`IPRcz( AS                ,0.0                                      ,"m^2"                                   ,"Source-to-substrate junction area" )
`IPRcz( AD                ,0.0                                      ,"m^2"                                   ,"Drain-to-substrate junction area" )
`IPRcz( PS                ,0.0                                      ,"m"                                     ,"Source-to-substrate junction perimeter" )
`IPRcz( PD                ,0.0                                      ,"m"                                     ,"Drain-to-substrate junction perimeter" )

// Both model and instance parameters
`BPRnb( XGW               ,0.0                                      ,"m"                                     ,"Distance from gate contact center to device edge" )
`BPIcc( NGCON             ,1                                        ,""            ,1           ,2           ,"Number of gate contacts" )
`BPRnb( DTEMP             ,0.0                                      ,"K"                                     ,"Offset of device temperature" )
`BPRnb( MULU0             ,1.0                                      ,"m^2/(V*s)"                             ,"Multiplication factor for low field mobility" )
`BPRnb( DELVTO            ,0.0                                      ,"V"                                     ,"Zero bias threshold voltage variation" )
`BPRcz( IDS0MULT          ,1.0                                      ,""                                      ,"Variability in drain current for miscellaneous reasons" )
`BPIcc( EDGEFET           ,0                                        ,""            ,0           ,1           ,"0: Edge FET Model OFF, 1: Edge FET Model ON" )
`BPIcc( SSLMOD            ,0                                        ,""            ,0           ,1           ,"Sub-surface leakage drain current, 0: Turn off  1: Turn on" )

// Pure model parameters
`MPIty( TYPE              ,`ntype                                   ,""                                      ,"N-type = 1, P-type = -1" )
`MPIcc( CVMOD             ,0                                        ,""            ,0           ,1           ,"0: Consistent I-V/C-V, 1: Different I-V/C-V" )
`MPIcc( COVMOD            ,0                                        ,""            ,0           ,1           ,"0: Use bias-independent overlap capacitances,  1: Use bias-dependent overlap capacitances" )
`MPIcc( RDSMOD            ,0                                        ,""            ,0           ,2           ,"0: Internal bias dependent and external bias independent S/D resistance model, 1: External S/D resistance model, 2: Internal S/D resistance model" )
`MPIcc( WPEMOD            ,0                                        ,""            ,0           ,1           ,"Model flag" )
`MPIcc( ASYMMOD           ,0                                        ,""            ,0           ,1           ,"0: Asymmetry model turned off - forward mode parameters used,  1: Asymmetry model turned on" )
`MPIcc( GIDLMOD           ,0                                        ,""            ,0           ,1           ,"0: Turn off GIDL current,  1: Turn on GIDL current" )
`MPIcc( IGCMOD            ,0                                        ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd, 1: Turn on Igc, Igs and Igd" )
`MPIcc( IGBMOD            ,0                                        ,""            ,0           ,1           ,"0: Turn off Igb, 1: Turn on Igb" )
`MPIcc( TNOIMOD           ,0                                        ,""            ,0           ,1           ,"Thermal noise model selector" )
`MPIcc( SHMOD             ,0                                        ,""            ,0           ,1           ,"0: Self heating model OFF, 1: Self heating model ON" )
`MPIcc( MOBSCALE          ,0                                        ,""            ,0           ,1           ,"Mobility scaling model, 0: Old Model,  1: New Model" )

// Device parameters
`MPRoz( LLONG             ,1.0e-5                                   ,"m"                                     ,"L of extracted long channel device" )
`MPRoz( LMLT              ,1.0                                      ,""                                      ,"Length shrinking parameter" )
`MPRoz( WMLT              ,1.0                                      ,""                                      ,"Width shrinking parameter" )
`MPRnb( XL                ,0.0                                      ,"m"                                     ,"L offset for channel length due to mask/etch effect" )
`MPRoz( WWIDE             ,1.0e-5                                   ,"m"                                     ,"W of extracted wide channel device" )
`MPRnb( XW                ,0.0                                      ,"m"                                     ,"W offset for channel width due to mask/etch effect" )
`MPRnb( LINT              ,0.0                                      ,"m"                                     ,"Delta L for I-V" )
`MPRnb( LL                ,0.0                                      ,"m^(1+LLN)"                             ,"Length reduction parameter" )
`MPRnb( LW                ,0.0                                      ,"m^(1+LWN)"                             ,"Length reduction parameter" )
`MPRnb( LWL               ,0.0                                      ,"m^(1+LLN+LWN)"                         ,"Length reduction parameter" )
`MPRnb( LLN               ,1.0                                      ,""                                      ,"Length reduction parameter" )
`MPRnb( LWN               ,1.0                                      ,""                                      ,"Length reduction parameter" )
`MPRnb( WINT              ,0.0                                      ,"m"                                     ,"Delta W for I-V" )
`MPRnb( WL                ,0.0                                      ,"m^(1+WLN)"                             ,"Width reduction parameter" )
`MPRnb( WW                ,0.0                                      ,"m^(1+WWN)"                             ,"Width reduction parameter" )
`MPRnb( WWL               ,0.0                                      ,"m^(1+WWN+WLN)"                         ,"Width reduction parameter" )
`MPRnb( WLN               ,1.0                                      ,""                                      ,"Width reduction parameter" )
`MPRnb( WWN               ,1.0                                      ,""                                      ,"Width reduction parameter" )
`MPRnb( DLC               ,0.0                                      ,"m"                                     ,"Delta L for C-V" )
`MPRnb( LLC               ,0.0                                      ,"m^(1+LLN)"                             ,"Length reduction parameter" )
`MPRnb( LWC               ,0.0                                      ,"m^(1+LWN)"                             ,"Length reduction parameter" )
`MPRnb( LWLC              ,0.0                                      ,"m^(1+LWN+LLN)"                         ,"Length reduction parameter" )
`MPRnb( DWC               ,0.0                                      ,"m"                                     ,"Delta W for C-V" )
`MPRnb( WLC               ,0.0                                      ,"m^(1+WLN)"                             ,"Width reduction parameter" )
`MPRnb( WWC               ,0.0                                      ,"m^(1+WWN)"                             ,"Width reduction parameter" )
`MPRnb( WWLC              ,0.0                                      ,"m^(1+WWN+WLN)"                         ,"Width reduction parameter" )
`MPRoo( TOXE              ,3.0e-9                                   ,"m"           ,0.0         ,inf         ,"Effective gate dielectric thickness relative to SiO2" )
`MPRoo( TOXP              ,TOXE                                     ,"m"           ,0.0         ,inf         ,"Physical gate dielectric thickness. If not given, TOXP is calculated from TOXE and DTOX" )
`MPRnb( DTOX              ,0.0                                      ,"m"                                     ,"Difference between effective dielectric thickness" )
`MPRnb( NDEP              ,1e24                                     ,"1/m^3"                                 ,"Channel doping concentration for I-V" )
`MPRnb( NDEPL1            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of NDEP" )
`MPRoz( NDEPLEXP1         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of NDEP" )
`MPRnb( NDEPL2            ,0.0                                      ,"m"                                     ,"Length dependence of NDEP - For Short Channel Devices" )
`MPRoz( NDEPLEXP2         ,2.0                                      ,""                                      ,"Length dependence exponent coefficient of NDEP" )
`MPRnb( NDEPW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of NDEP" )
`MPRoz( NDEPWEXP          ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of NDEP" )
`MPRnb( NDEPWL            ,0.0                                      ,"m^2"                                   ,"Width-length dependence coefficient of NDEP" )
`MPRoz( NDEPWLEXP         ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of NDEP" )
`MPRnb( LNDEP             ,0.0                                      ,"1/m^2"                                 ,"Length dependence of NDEP" )
`MPRnb( WNDEP             ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NDEP" )
`MPRnb( PNDEP             ,0.0                                      ,"1/m"                                   ,"Area dependence of NDEP " )
`MPRnb( NDEPCV            ,1e24                                     ,"1/m^3"                                 ,"Channel doping concentration for C-V" )
`MPRnb( NDEPCVL1          ,0.0                                      ,"m"                                     ,"Length dependence coefficient of NDEPCV" )
`MPRoz( NDEPCVLEXP1       ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of NDEPCV" )
`MPRnb( NDEPCVL2          ,0.0                                      ,"m"                                     ,"Length dependence coefficient of NDEPCV - For Short Channel Devices" )
`MPRoz( NDEPCVLEXP2       ,2.0                                      ,""                                      ,"Length dependence exponent coefficient of NDEPCV" )
`MPRnb( NDEPCVW           ,0.0                                      ,"m"                                     ,"Width dependence coefficient of NDEPCV" )
`MPRoz( NDEPCVWEXP        ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of NDEPCV" )
`MPRnb( NDEPCVWL          ,0.0                                      ,"m^2"                                   ,"Width-length dependence coefficient of NDEPCV" )
`MPRoz( NDEPCVWLEXP       ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of NDEPCV" )
`MPRnb( LNDEPCV           ,0.0                                      ,"1/m^2"                                 ,"Length dependence  of NDEP for C-V" )
`MPRnb( WNDEPCV           ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NDEP for C-V" )
`MPRnb( PNDEPCV           ,0.0                                      ,"1/m"                                   ,"Area dependence of NDEP for C-V" )
`MPRnb( NGATE             ,5e25                                     ,"1/m^3"                                 ,"Gate doping concentration" )
`MPRnb( LNGATE            ,0.0                                      ,"1/m^2"                                 ,"Length dependence of NGATE" )
`MPRnb( WNGATE            ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NGATE" )
`MPRnb( PNGATE            ,0.0                                      ,"1/m"                                   ,"Area dependence of NGATE" )
`MPRnb( EASUB             ,4.05                                     ,"eV"                                    ,"Electron affinity of substrate" )
`MPRoz( NI0SUB            ,1.1e16                                   ,"1/m^3"                                 ,"Intrinsic carrier concentration of the substrate at 300.15K" )
`MPRoo( BG0SUB            ,1.17                                     ,"eV"          ,0.0         ,inf         ,"Bandgap of substrate at 300.15K" )
`MPRoo( EPSRSUB           ,11.9                                     ,""            ,0.0         ,inf         ,"Relative dielectric constant of the channel material" )
`MPRoo( EPSROX            ,3.9                                      ,""            ,0.0         ,inf         ,"Relative dielectric constant of the gate dielectric" )
`MPRnb( XJ                ,1.5e-7                                   ,"m"                                     ,"S/D junction depth" )
`MPRnb( LXJ               ,0.0                                      ,"m^2"                                   ,"Length dependence of XJ" )
`MPRnb( WXJ               ,0.0                                      ,"m^2"                                   ,"Width dependence of XJ" )
`MPRnb( PXJ               ,0.0                                      ,"m^3"                                   ,"Area dependence of XJ" )
`MPRnb( VFB               ,-0.5                                     ,"V"                                     ,"Flatband voltage" )
`MPRnb( LVFB              ,0.0                                      ,"V*m"                                   ,"Length dependence of VFB" )
`MPRnb( WVFB              ,0.0                                      ,"V*m"                                   ,"Width dependence of VFB" )
`MPRnb( PVFB              ,0.0                                      ,"V*m^2"                                 ,"Area dependence of VFB" )
`MPRnb( VFBCV             ,-0.5                                     ,"V"                                     ,"Flatband voltage for C-V" )
`MPRnb( LVFBCV            ,0.0                                      ,"V*m"                                   ,"Length dependence of VFBCV" )
`MPRnb( WVFBCV            ,0.0                                      ,"V*m"                                   ,"Width dependence of VFBCV" )
`MPRnb( PVFBCV            ,0.0                                      ,"V*m^2"                                 ,"Area dependence of VFBCV" )
`MPRnb( VFBCVL            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of VFBCV" )
`MPRoz( VFBCVLEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of VFBCV" )
`MPRnb( VFBCVW            ,0.0                                      ,"m"                                     ,"Width dependence coefficient of VFBCV" )
`MPRoz( VFBCVWEXP         ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of VFBCV" )
`MPRnb( VFBCVWL           ,0.0                                      ,"m^2"                                   ,"Width-length dependence coefficient of VFBCV" )
`MPRoz( VFBCVWLEXP        ,1.0                                      ,""                                      ,"Width-length dependence coefficient of VFBCV" )
`MPRnb( DELVFBACC         ,0.0                                      ,""                                      ,"VFB shift in the accumulation region, valid for CVMOD=1 only" )

// Diode parameters
`MPIcc( PERMOD            ,1                                        ,""            ,0           ,1           ,"Whether PS/PD (when given) include gate-edge perimeter" )
`MPRnb( DWJ               ,DWC                                      ,"m"                                     ,"Delta W for S/D junctions" )

// Short channel effects
`MPRnb( NSD               ,1e26                                     ,"1/m^3"                                 ,"S/D doping concentration" )
`MPRnb( LNSD              ,0.0                                      ,"1/m^2"                                 ,"Length dependence of NSD" )
`MPRnb( WNSD              ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NSD" )
`MPRnb( PNSD              ,0.0                                      ,"1/m"                                   ,"Area dependence of NSD" )
`MPRnb( DVTP0             ,0.0                                      ,"m"                                     ,"DITS" )
`MPRnb( LDVTP0            ,0                                        ,"m^2"                                   ,"Length dependence of DVTP0" )
`MPRnb( WDVTP0            ,0                                        ,"m^2"                                   ,"Width dependence of DVTP0" )
`MPRnb( PDVTP0            ,0                                        ,"m^3"                                   ,"Area dependence of DVTP0" )
`MPRnb( DVTP1             ,0.0                                      ,"1/V"                                   ,"DITS" )
`MPRnb( LDVTP1            ,0                                        ,"m/V"                                   ,"Length dependence of DVTP1" )
`MPRnb( WDVTP1            ,0                                        ,"m/V"                                   ,"Width dependence of DVTP1" )
`MPRnb( PDVTP1            ,0                                        ,"m^2/V"                                 ,"Area dependence of DVTP1" )
`MPRnb( DVTP2             ,0.0                                      ,"m*V"                                   ,"DITS" )
`MPRnb( LDVTP2            ,0                                        ,"m^2/V"                                 ,"Length dependence of DVTP2" )
`MPRnb( WDVTP2            ,0                                        ,"m^2/V"                                 ,"Width dependence of DVTP2" )
`MPRnb( PDVTP2            ,0                                        ,"m^3/V"                                 ,"Area dependence of DVTP2" )
`MPRnb( DVTP3             ,0.0                                      ,""                                      ,"DITS" )
`MPRnb( LDVTP3            ,0                                        ,"m"                                     ,"Length dependence of DVTP3" )
`MPRnb( WDVTP3            ,0                                        ,"m"                                     ,"Width dependence of DVTP3" )
`MPRnb( PDVTP3            ,0                                        ,"m^2"                                   ,"Area dependence of DVTP3" )
`MPRnb( DVTP4             ,0.0                                      ,"1/V"                                   ,"DITS" )
`MPRnb( LDVTP4            ,0                                        ,"m/V"                                   ,"Length dependence of DVTP4" )
`MPRnb( WDVTP4            ,0                                        ,"m/V"                                   ,"Width dependence of DVTP4" )
`MPRnb( PDVTP4            ,0                                        ,"m^2/V"                                 ,"Area dependence of DVTP4" )
`MPRnb( DVTP5             ,0.0                                      ,"V"                                     ,"DITS" )
`MPRnb( LDVTP5            ,0                                        ,"m*V"                                   ,"Length dependence of DVTP5" )
`MPRnb( WDVTP5            ,0                                        ,"m*V"                                   ,"Width dependence of DVTP5" )
`MPRnb( PDVTP5            ,0                                        ,"m^2*V"                                 ,"Area dependence of DVTP5" )
`MPRnb( PHIN              ,0.045                                    ,"V"                                     ,"Non-uniform vertical doping effect on surface potential" )
`MPRnb( LPHIN             ,0.0                                      ,"m*V"                                   ,"Length dependence of PHIN" )
`MPRnb( WPHIN             ,0.0                                      ,"m*V"                                   ,"Width dependence of PHIN" )
`MPRnb( PPHIN             ,0.0                                      ,"m^2*V"                                 ,"Area dependence of PHIN" )
`MPRnb( ETA0              ,0.08                                     ,""                                      ,"DIBL coefficient" )
`MPRnb( LETA0             ,0.0                                      ,"m"                                     ,"Length dependence of ETA0" )
`MPRnb( WETA0             ,0.0                                      ,"m"                                     ,"Width dependence of ETA0" )
`MPRnb( PETA0             ,0.0                                      ,"m^2"                                   ,"Area dependence of ETA0" )
`MPRnb( ETA0R             ,ETA0                                     ,""                                      ,"DIBL coefficient" )
`MPRnb( LETA0R            ,LETA0                                    ,"m"                                     ,"Length dependence of ETA0R" )
`MPRnb( WETA0R            ,WETA0                                    ,"m"                                     ,"Width dependence of ETA0R" )
`MPRnb( PETA0R            ,PETA0                                    ,"m^2"                                   ,"Area dependence of ETA0R" )
`MPRnb( DSUB              ,1.0                                      ,""                                      ,"Length scaling exponent for DIBL" )
`MPRnb( ETAB              ,-0.07                                    ,"1/V"                                   ,"Body bias coefficient for subthreshold DIBL effect" )
`MPRoz( ETABEXP           ,1.0                                      ,""                                      ,"Exponent coefficient of ETAB" )
`MPRnb( LETAB             ,0.0                                      ,"m/V"                                   ,"Length dependence of ETAB" )
`MPRnb( WETAB             ,0.0                                      ,"m/V"                                   ,"Width dependence of ETAB" )
`MPRnb( PETAB             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of ETAB" )
`MPRnb( K1                ,0.0                                      ,"V^0.5"                                 ,"First-order body-bias Vth shift due to vertical non-uniform doping" )
`MPRnb( K1L               ,0.0                                      ,""                                      ,"length dependence coefficient of K1" )
`MPRoz( K1LEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of K1" )
`MPRnb( K1W               ,0.0                                      ,""                                      ,"Width dependence coefficient of K1" )
`MPRoz( K1WEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of K1" )
`MPRnb( K1WL              ,0.0                                      ,""                                      ,"Width-length dependence coefficient of K1" )
`MPRoz( K1WLEXP           ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of K1" )
`MPRnb( LK1               ,0.0                                      ,"m*V^0.5"                               ,"Length dependence of K1" )
`MPRnb( WK1               ,0.0                                      ,"m*V^0.5"                               ,"Width dependence of K1" )
`MPRnb( PK1               ,0.0                                      ,"m^2*V^0.5"                             ,"Area dependence of K1" )
`MPRnb( K2                ,0.0                                      ,"V"                                     ,"Vth shift due to vertical non-uniform doping" )
`MPRnb( K2L               ,0.0                                      ,"m^K2LEXP"                              ,"Length dependence coefficient of K2" )
`MPRoz( K2LEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of K2" )
`MPRnb( K2W               ,0.0                                      ,"m^K2WEXP"                              ,"Width dependence coefficient of K2" )
`MPRoz( K2WEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of K2" )
`MPRnb( K2WL              ,0.0                                      ,"m^(2*K2WLEXP)"                         ,"Width-length dependence coefficient of K2" )
`MPRoz( K2WLEXP           ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of K2" )
`MPRnb( LK2               ,0.0                                      ,"m"                                     ,"Length dependence of K2" )
`MPRnb( WK2               ,0.0                                      ,"m"                                     ,"Width dependence of K2" )
`MPRnb( PK2               ,0.0                                      ,"m^2"                                   ,"Area dependence of K2" )

// Quantum mechanical effects
`MPRcz( ADOS              ,0.0                                      ,""                                      ,"Quantum mechanical effect pre-factor switch in inversion" )
`MPRcz( BDOS              ,1.0                                      ,""                                      ,"Charge centroid parameter - slope of C-V curve under QME in inversion" )
`MPRoz( QM0               ,1.0e-3                                   ,""                                      ,"Charge centroid parameter - starting point for QME in inversion" )
`MPRcz( ETAQM             ,0.54                                     ,""                                      ,"Bulk charge coefficient for charge centroid in inversion" )

// Sub-threshold swing factor
`MPRnb( CIT               ,0.0                                      ,"F/m^2"                                 ,"Parameter for interface traps" )
`MPRnb( LCIT              ,0.0                                      ,"F/m"                                   ,"Length dependence of CIT" )
`MPRnb( WCIT              ,0.0                                      ,"F/m"                                   ,"Width dependence of CIT" )
`MPRnb( PCIT              ,0.0                                      ,"F"                                     ,"Area dependence of CIT" )
`MPRnb( NFACTOR           ,0.0                                      ,""                                      ,"Subthreshold slope factor" )
`MPRnb( NFACTORL          ,0.0                                      ,"m^NFACTORLEXP"                         ,"Length dependence coefficient of NFACTOR" )
`MPRoz( NFACTORLEXP       ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of NFACTOR" )
`MPRnb( NFACTORW          ,0.0                                      ,"m^NFACTORWEXP"                         ,"Width dependence coefficient of NFACTOR" )
`MPRoz( NFACTORWEXP       ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of NFACTOR" )
`MPRnb( NFACTORWL         ,0.0                                      ,"m^(2*NFACTORWLEXP)"                    ,"Width-length dependence coefficient of NFACTOR" )
`MPRoz( NFACTORWLEXP      ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of NFACTOR" )
`MPRnb( LNFACTOR          ,0.0                                      ,"m"                                     ,"Length dependence of NFACTOR" )
`MPRnb( WNFACTOR          ,0.0                                      ,"m"                                     ,"Width dependence of NFACTOR" )
`MPRnb( PNFACTOR          ,0.0                                      ,"m^2"                                   ,"Area dependence of NFACTOR" )
`MPRnb( CDSCD             ,1e-9                                     ,"F/m^2/V"                               ,"Drain bias sensitivity of subthreshold slope" )
`MPRnb( CDSCDL            ,0.0                                      ,"m^CDSCDLEXP"                           ,"Length dependence coefficient of CDSCD" )
`MPRoz( CDSCDLEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of CDSCD" )
`MPRnb( LCDSCD            ,0.0                                      ,"F/m/V"                                 ,"Length dependence of CDSCD" )
`MPRnb( WCDSCD            ,0.0                                      ,"F/m/V"                                 ,"Width dependence of CDSCD" )
`MPRnb( PCDSCD            ,0.0                                      ,"F/V"                                   ,"Area dependence of CDSCD" )
`MPRnb( CDSCDR            ,CDSCD                                    ,"F/m^2/V"                               ,"Drain bias sensitivity of subthreshold slope" )
`MPRnb( CDSCDLR           ,CDSCDL                                   ,"m^CDSCDLEXP"                           ,"Length dependence coefficient of CDSCD" )
`MPRnb( LCDSCDR           ,LCDSCD                                   ,"F/m/V"                                 ,"Length dependence of CDSCDR" )
`MPRnb( WCDSCDR           ,WCDSCD                                   ,"F/m/V"                                 ,"Width dependence of CDSCDR" )
`MPRnb( PCDSCDR           ,PCDSCD                                   ,"F/V"                                   ,"Area dependence of CDSCDR" )
`MPRnb( CDSCB             ,0.0                                      ,"F/m^2/V"                               ,"Body-bias sensitivity of subthreshold slope" )
`MPRnb( CDSCBL            ,0.0                                      ,"m^CDSCBLEXP"                           ,"Length dependence coefficient of CDSCB" )
`MPRoz( CDSCBLEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of CDSCB" )
`MPRnb( LCDSCB            ,0.0                                      ,"F/m/V"                                 ,"Length dependence of CDSCB" )
`MPRnb( WCDSCB            ,0.0                                      ,"F/m/V"                                 ,"Width dependence of CDSCB" )
`MPRnb( PCDSCB            ,0.0                                      ,"F/V"                                   ,"Area dependence of CDSCB" )

// Drain saturation voltage
`MPRnb( VSAT              ,1e5                                      ,"m/s"                                   ,"Saturation velocity" )
`MPRnb( LVSAT             ,0.0                                      ,"m^2/s"                                 ,"Length dependence of VSAT" )
`MPRnb( WVSAT             ,0.0                                      ,"m^2/s"                                 ,"Width dependence of VSAT" )
`MPRnb( PVSAT             ,0.0                                      ,"m^3/s"                                 ,"Area dependence of VSAT" )
`MPRnb( VSATL             ,0.0                                      ,"m^VSATLEXP"                            ,"Length dependence coefficient of VSAT" )
`MPRoz( VSATLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of VSAT" )
`MPRnb( VSATW             ,0.0                                      ,"m^VSATWEXP"                            ,"Width dependence coefficient of VSAT" )
`MPRoz( VSATWEXP          ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of VSAT" )
`MPRnb( VSATWL            ,0.0                                      ,"m^(2*VSATWLEXP)"                       ,"Width-length dependence coefficient of VSAT" )
`MPRoz( VSATWLEXP         ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of of VSAT" )
`MPRnb( VSATR             ,VSAT                                     ,"m/s"                                   ,"Saturation velocity" )
`MPRnb( LVSATR            ,LVSAT                                    ,"m^2/s"                                 ,"Length dependence of VSATR" )
`MPRnb( WVSATR            ,WVSAT                                    ,"m^2/s"                                 ,"Width dependence of VSATR" )
`MPRnb( PVSATR            ,PVSAT                                    ,"m^3/s"                                 ,"Area dependence of VSATR" )
`MPRnb( DELTA             ,0.125                                    ,""                                      ,"Smoothing function factor for Vdsat" )
`MPRnb( LDELTA            ,0.0                                      ,"m"                                     ,"Length dependence of DELTA" )
`MPRnb( WDELTA            ,0.0                                      ,"m"                                     ,"Width dependence of DELTA" )
`MPRnb( PDELTA            ,0.0                                      ,"m^2"                                   ,"Area dependence of DELTA" )
`MPRnb( DELTAL            ,0.0                                      ,"m^DELTALEXP"                           ,"Length dependence coefficient of DELTA" )
`MPRoz( DELTALEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of DELTA" )
`MPRnb( VSATCV            ,1e5                                      ,"m/s"                                   ,"VSAT parameter for C-V" )
`MPRnb( LVSATCV           ,0.0                                      ,"m^2/s"                                 ,"Length dependence of VSATCV" )
`MPRnb( WVSATCV           ,0.0                                      ,"m^2/s"                                 ,"Width dependence of VSATCV" )
`MPRnb( PVSATCV           ,0.0                                      ,"m^3/s"                                 ,"Area dependence of VSATCV" )
`MPRnb( VSATCVL           ,0.0                                      ,"m^VSATCVLEXP"                          ,"Length dependence coefficient of VSATCV" )
`MPRoz( VSATCVLEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of VSATCV" )
`MPRnb( VSATCVW           ,0.0                                      ,"m^VSATCVWEXP"                          ,"Width dependence coefficient of VSATCV" )
`MPRoz( VSATCVWEXP        ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of VSATCV" )
`MPRnb( VSATCVWL          ,0.0                                      ,"m^(2*VSATCVWLEXP)"                     ,"Width-length dependence coefficient of VSATCV" )
`MPRoz( VSATCVWLEXP       ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of VSATCV" )

// Mobility degradation
`MPRoo( UP1               ,0.0                                      ,""            ,-inf        ,inf         ,"Mobility channel length coefficient" )
`MPRex( LP1               ,1.0e-8                                   ,"m"           ,0.0                      ,"Mobility channel length exponential coefficient" )
`MPRoo( UP2               ,0.0                                      ,""            ,-inf        ,inf         ,"Mobility channel length coefficient" )
`MPRex( LP2               ,1.0e-8                                   ,"m"           ,0.0                      ,"Mobility channel length exponential coefficient" )
`MPRoz( U0                ,67.0e-3                                  ,"m^2/V/s"                               ,"Low Field mobility." )
`MPRnb( U0L               ,0.0                                      ,"m^U0LEXP"                              ,"Length dependence coefficient of U0L" )
`MPRoz( U0LEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of U0L" )
`MPRnb( LU0               ,0.0                                      ,"m^3/V/s"                               ,"Length dependence of U0" )
`MPRnb( WU0               ,0.0                                      ,"m^3/V/s"                               ,"Width dependence of U0" )
`MPRnb( PU0               ,0.0                                      ,"m^4/V/s"                               ,"Area dependence of U0" )
`MPRnb( U0R               ,U0                                       ,"m^2/V/s"                               ,"Reverse-mode Low Field mobility." )
`MPRnb( LU0R              ,LU0                                      ,"m^3/V/s"                               ,"Length dependence of U0R" )
`MPRnb( WU0R              ,WU0                                      ,"m^3/V/s"                               ,"Width dependence of U0R" )
`MPRnb( PU0R              ,PU0                                      ,"m^4/V/s"                               ,"Area dependence of U0R" )
`MPRnb( ETAMOB            ,1.0                                      ,""                                      ,"Effective field parameter (should be kept close to 1)" )
`MPRnb( UA                ,0.001                                    ,"(m/V)^EU"                              ,"Mobility reduction coefficient" )
`MPRnb( UAL               ,0.0                                      ,"m^UALEXP"                              ,"Length dependence coefficient of  UA" )
`MPRoz( UALEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of  UA" )
`MPRnb( UAW               ,0.0                                      ,"m^UAWEXP"                              ,"Width dependence coefficient of UA" )
`MPRoz( UAWEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of UA" )
`MPRnb( UAWL              ,0.0                                      ,"m^UAWLEXP"                             ,"Width-length dependence coefficient of UA" )
`MPRoz( UAWLEXP           ,1.0                                      ,""                                      ,"Width-length dependence coefficient of UA" )
`MPRnb( LUA               ,0.0                                      ,"m*(m/V)^EU"                            ,"Length dependence of UA" )
`MPRnb( WUA               ,0.0                                      ,"m*(m/V)^EU"                            ,"Width dependence of UA" )
`MPRnb( PUA               ,0.0                                      ,"m^2*(m/V)^EU"                          ,"Area dependence of UA" )
`MPRnb( UAR               ,UA                                       ,"(m/V)^EU"                              ,"Reverse-mode mobility reduction coefficient" )
`MPRnb( LUAR              ,LUA                                      ,"m*(m/V)^EU"                            ,"Length dependence of UAR" )
`MPRnb( WUAR              ,WUA                                      ,"m*(m/V)^EU"                            ,"Width dependence of UAR" )
`MPRnb( PUAR              ,PUA                                      ,"m^2*(m/V)^EU"                          ,"Area dependence of UAR" )
`MPRnb( EU                ,1.5                                      ,""                                      ,"Mobility reduction exponent" )
`MPRnb( LEU               ,0.0                                      ,"m"                                     ,"Length dependence of EU" )
`MPRnb( WEU               ,0.0                                      ,"m"                                     ,"Width dependence of EU" )
`MPRnb( PEU               ,0.0                                      ,"m^2"                                   ,"Area dependence of EU" )
`MPRnb( EUL               ,0.0                                      ,"m^EULEXP"                              ,"Length dependence coefficient of EU" )
`MPRoz( EULEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of EU" )
`MPRnb( EUW               ,0.0                                      ,"m^EUWEXP"                              ,"Width dependence coefficient of EU" )
`MPRoz( EUWEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of EU" )
`MPRnb( EUWL              ,0.0                                      ,"m^EUWLEXP"                             ,"Width-length dependence coefficient of EU" )
`MPRoz( EUWLEXP           ,1.0                                      ,""                                      ,"Width-length dependence coefficient of EU" )
`MPRnb( UD                ,0.001                                    ,""                                      ,"Coulomb scattering parameter" )
`MPRnb( UDL               ,0.0                                      ,"m^UDLEXP"                              ,"Length dependence coefficient of UD" )
`MPRoz( UDLEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of UD" )
`MPRnb( LUD               ,0.0                                      ,"m"                                     ,"Length dependence of UD" )
`MPRnb( WUD               ,0.0                                      ,"m"                                     ,"Width dependence of UD" )
`MPRnb( PUD               ,0.0                                      ,"m^2"                                   ,"Area dependence of UD" )
`MPRnb( UDR               ,UD                                       ,""                                      ,"Reverse-mode Coulomb scattering parameter" )
`MPRnb( LUDR              ,LUD                                      ,"m"                                     ,"Length dependence of UDR" )
`MPRnb( WUDR              ,WUD                                      ,"m"                                     ,"Width dependence of UDR" )
`MPRnb( PUDR              ,PUD                                      ,"m^2"                                   ,"Area dependence of UDR" )
`MPRnb( UCS               ,2.0                                      ,""                                      ,"Coulomb scattering parameter" )
`MPRnb( LUCS              ,0.0                                      ,"m"                                     ,"Length dependence of UCS" )
`MPRnb( WUCS              ,0.0                                      ,"m"                                     ,"Width dependence of UCS" )
`MPRnb( PUCS              ,0.0                                      ,"m^2"                                   ,"Area dependence of UCS" )
`MPRnb( UCSR              ,UCS                                      ,""                                      ,"Reverse-mode Coulomb scattering parameter" )
`MPRnb( LUCSR             ,LUCS                                     ,"m"                                     ,"Length dependence of UCSR" )
`MPRnb( WUCSR             ,WUCS                                     ,"m"                                     ,"Width dependence of UCSR" )
`MPRnb( PUCSR             ,PUCS                                     ,"m^2"                                   ,"Area dependence of UCSR" )
`MPRnb( UC                ,0.0                                      ,"(m/V)^EU/V"                            ,"Mobility reduction with body bias" )
`MPRnb( UCL               ,0.0                                      ,"m^UCLEXP"                              ,"Length dependence coefficient of UC" )
`MPRoz( UCLEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of UC" )
`MPRnb( UCW               ,0.0                                      ,"m^UCWEXP"                              ,"Width dependence coefficient of UC" )
`MPRoz( UCWEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of UC" )
`MPRnb( UCWL              ,0.0                                      ,"m^(2*UCWLEXP)"                         ,"Width-length dependence coefficient of UC" )
`MPRoz( UCWLEXP           ,1.0                                      ,""                                      ,"Width-length dependence exponent coefficient of UC" )
`MPRnb( LUC               ,0.0                                      ,"m*(m/V)^EU/V"                          ,"Length dependence of UC" )
`MPRnb( WUC               ,0.0                                      ,"m*(m/V)^EU/V"                          ,"Width dependence of UC" )
`MPRnb( PUC               ,0.0                                      ,"m^2*(m/V)^EU/V"                        ,"Area dependence of UC" )
`MPRnb( UCR               ,UC                                       ,"(m/V)^EU/V"                            ,"Reverse-mode mobility reduction with body bias" )
`MPRnb( LUCR              ,LUC                                      ,"m*(m/V)^EU/V"                          ,"Length dependence of UCR" )
`MPRnb( WUCR              ,WUC                                      ,"m*(m/V)^EU/V"                          ,"Width dependence of UCR" )
`MPRnb( PUCR              ,PUC                                      ,"m^2*(m/V)^EU/V"                        ,"Area dependence of UCR" )

// Channel length modulation
`MPRnb( PCLM              ,0.0                                      ,""                                      ,"CLM pre-factor" )
`MPRnb( PCLML             ,0.0                                      ,"m^PCLMLEXP"                            ,"Length dependence coefficient of PCLM" )
`MPRoz( PCLMLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PCLM" )
`MPRnb( LPCLM             ,0.0                                      ,"m"                                     ,"Length dependence of PCLM" )
`MPRnb( WPCLM             ,0.0                                      ,"m"                                     ,"Width dependence of PCLM" )
`MPRnb( PPCLM             ,0.0                                      ,"m^2"                                   ,"Area dependence of PCLM" )
`MPRnb( PCLMR             ,PCLM                                     ,""                                      ,"Reverse-mode CLM pre-factor" )
`MPRnb( LPCLMR            ,LPCLM                                    ,"m"                                     ,"Length dependence of PCLMR" )
`MPRnb( WPCLMR            ,WPCLM                                    ,"m"                                     ,"Width dependence of PCLMR" )
`MPRnb( PPCLMR            ,PPCLM                                    ,"m^2"                                   ,"Area dependence of PCLMR" )
`MPRnb( PCLMG             ,0.0                                      ,"V"                                     ,"CLM pre-factor gate voltage dependence" )
`MPRnb( PCLMCV            ,PCLM                                     ,""                                      ,"CLM parameter for C-V" )
`MPRnb( PCLMCVL           ,PCLML                                    ,"m^PCLMLEXP"                            ,"Length dependence coefficient of PCLMCV" )
`MPRoz( PCLMCVLEXP        ,PCLMLEXP                                 ,""                                      ,"Length dependence exponent coefficient of PCLMCV" )
`MPRnb( LPCLMCV           ,LPCLM                                    ,"m"                                     ,"Length dependence of PCLMCV" )
`MPRnb( WPCLMCV           ,WPCLM                                    ,"m"                                     ,"Width dependence of PCLMCV" )
`MPRnb( PPCLMCV           ,PPCLM                                    ,"m^2"                                   ,"Area dependence of PCLMCV" )
`MPRnb( PSCBE1            ,4.24e8                                   ,"V/m"                                   ,"Substrate current body-effect coefficient" )
`MPRnb( LPSCBE1           ,0.0                                      ,"V"                                     ,"Length dependence of PSCBE1" )
`MPRnb( WPSCBE1           ,0.0                                      ,"V"                                     ,"Width dependence of PSCBE1" )
`MPRnb( PPSCBE1           ,0.0                                      ,"V*m"                                   ,"Area dependence of PSCBE1" )
`MPRnb( PSCBE2            ,1.0e-8                                   ,"m/V"                                   ,"Substrate current body-effect coefficient" )
`MPRnb( LPSCBE2           ,0.0                                      ,"m^2/V"                                 ,"Length dependence of PSCBE2" )
`MPRnb( WPSCBE2           ,0.0                                      ,"m^2/V"                                 ,"Width dependence of PSCBE2" )
`MPRnb( PPSCBE2           ,0.0                                      ,"m^3/V"                                 ,"Area dependence of PSCBE2" )
`MPRnb( PDITS             ,0.0                                      ,"1/V"                                   ,"Coefficient for drain-induced Vth shift" )
`MPRnb( LPDITS            ,0.0                                      ,"m/V"                                   ,"Length dependence of PDITS" )
`MPRnb( WPDITS            ,0.0                                      ,"m/V"                                   ,"Width dependence of PDITS" )
`MPRnb( PPDITS            ,0.0                                      ,"m^2/V"                                 ,"Area dependence of PDITS" )
`MPRcz( PDITSL            ,0.0                                      ,"1/m"                                   ,"L dependence of drain-induced Vth shift" )
`MPRnb( PDITSD            ,0.0                                      ,"1/V"                                   ,"Vds dependence of drain-induced Vth shift" )
`MPRnb( LPDITSD           ,0.0                                      ,"m/V"                                   ,"Length dependence of PDITSD" )
`MPRnb( WPDITSD           ,0.0                                      ,"m/V"                                   ,"Width dependence of PDITSD" )
`MPRnb( PPDITSD           ,0.0                                      ,"m^2/V"                                 ,"Area dependence of PDITSD" )

// S/D series resistances
`MPRcz( RSH               ,0.0                                      ,"ohm/square"                            ,"Source-drain sheet resistances" )
`MPRnb( PRWG              ,1.0                                      ,"1/V"                                   ,"Gate bias dependence of S/D extension resistances" )
`MPRnb( LPRWG             ,0.0                                      ,"m/V"                                   ,"Length dependence of PRWG" )
`MPRnb( WPRWG             ,0.0                                      ,"m/V"                                   ,"Width dependence of PRWG" )
`MPRnb( PPRWG             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of PRWG" )
`MPRnb( PRWB              ,0.0                                      ,"1/V"                                   ,"Body bias dependence of resistances" )
`MPRnb( LPRWB             ,0.0                                      ,"m/V"                                   ,"Length dependence of PRWB" )
`MPRnb( WPRWB             ,0.0                                      ,"m/V"                                   ,"Width dependence of PRWB" )
`MPRnb( PPRWB             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of PRWB" )
`MPRnb( PRWBL             ,0.0                                      ,"m^PRWBLEXP"                            ,"Length dependence coefficient of PPRWB" )
`MPRoz( PRWBLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PPRWB" )
`MPRnb( WR                ,1.0                                      ,""                                      ,"W dependence parameter of S/D extension resistances" )
`MPRnb( LWR               ,0.0                                      ,"m"                                     ,"Length dependence of WR" )
`MPRnb( WWR               ,0.0                                      ,"m"                                     ,"Width dependence of WR" )
`MPRnb( PWR               ,0.0                                      ,"m^2"                                   ,"Area dependence of WR" )
`MPRnb( RSWMIN            ,0.0                                      ,"ohm*m^WR"                              ,"Source resistance per unit width at high Vgs (RDSMOD=1)" )
`MPRnb( LRSWMIN           ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RSWMIN" )
`MPRnb( WRSWMIN           ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence of RSWMIN" )
`MPRnb( PRSWMIN           ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence of RSWMIN" )
`MPRnb( RSW               ,10.0                                     ,"ohm*m^WR"                              ,"Zero bias source resistance (RDSMOD=1)" )
`MPRnb( LRSW              ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RSW" )
`MPRnb( WRSW              ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence of RSW" )
`MPRnb( PRSW              ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence of RSW" )
`MPRnb( RSWL              ,0.0                                      ,"m^RSWLEXP"                             ,"Geometrical scaling of RSW (RDSMOD=1)" )
`MPRoz( RSWLEXP           ,1.0                                      ,""                                      ,"Geometrical scaling of RSW (RDSMOD=1)" )
`MPRnb( RDWMIN            ,RSWMIN                                   ,"ohm*m^WR"                              ,"Drain resistance per unit width at high Vgs (RDSMOD=1)" )
`MPRnb( LRDWMIN           ,LRSWMIN                                  ,"ohm*m^(2*WR)"                          ,"Length dependence of RDWMIN" )
`MPRnb( WRDWMIN           ,WRSWMIN                                  ,"ohm*m^(2*WR)"                          ,"Width dependence of RDWMIN" )
`MPRnb( PRDWMIN           ,PRSWMIN                                  ,"ohm*m^(3*WR)"                          ,"Area dependence of RDWMIN" )
`MPRnb( RDW               ,RSW                                      ,"ohm*m^WR"                              ,"Zero bias drain resistance (RDSMOD=1)" )
`MPRnb( LRDW              ,LRSW                                     ,"ohm*m^(2*WR)"                          ,"Length dependence of RDW" )
`MPRnb( WRDW              ,WRSW                                     ,"ohm*m^(2*WR)"                          ,"Width dependence of RDW" )
`MPRnb( PRDW              ,PRSW                                     ,"ohm*m^(3*WR)"                          ,"Area dependence of RDW" )
`MPRnb( RDWL              ,RSWL                                     ,"m^RDWLEXP"                             ,"Geometrical scaling of RDW (RDSMOD=1)" )
`MPRoz( RDWLEXP           ,RSWLEXP                                  ,""                                      ,"Geometrical scaling of RDW (RDSMOD=1)" )
`MPRnb( RDSWMIN           ,0.0                                      ,"ohm*m^WR"                              ,"S/D Resistance per unit width at high Vgs (RDSMOD=0 and RDSMOD=2)" )
`MPRnb( LRDSWMIN          ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RDSWMIN" )
`MPRnb( WRDSWMIN          ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence of RDSWMIN" )
`MPRnb( PRDSWMIN          ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence of RDSWMIN" )
`MPRnb( RDSW              ,20.0                                     ,"ohm*um^WR"                             ,"Zero bias resistance (RDSMOD=0 and RDSMOD=2)" )
`MPRnb( RDSWL             ,0.0                                      ,"m^RDSWLEXP"                            ,"Geometrical scaling of RDSW (RDSMOD=0 and RDSMOD=2)" )
`MPRoz( RDSWLEXP          ,1.0                                      ,""                                      ,"Geometrical scaling of RDSW (RDSMOD=0 and RDSMOD=2)" )
`MPRnb( LRDSW             ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RDSW" )
`MPRnb( WRDSW             ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence of RDSW" )
`MPRnb( PRDSW             ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence of RDSW" )

// Velocity saturation
`MPRnb( PSAT              ,1.0                                      ,""                                      ,"Gmsat variation with gate bias" )
`MPRnb( LPSAT             ,0.0                                      ,"m"                                     ,"Length dependence of PSAT" )
`MPRnb( WPSAT             ,0.0                                      ,"m"                                     ,"Width dependence of PSAT" )
`MPRnb( PPSAT             ,0.0                                      ,"m^2"                                   ,"Area dependence of PSAT" )
`MPRnb( PSATL             ,0.0                                      ,"m^PSATLEXP"                            ,"Length dependence coefficient of PSATL" )
`MPRoz( PSATLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PSATLEXP" )
`MPRnb( PSATB             ,0.0                                      ,"1/V"                                   ,"Body bias effect on Idsat" )
`MPRnb( PSATR             ,PSAT                                     ,""                                      ,"Reverse-mode Gmsat variation with gate bias" )
`MPRnb( LPSATR            ,LPSAT                                    ,"m"                                     ,"Length dependence of PSATR" )
`MPRnb( WPSATR            ,WPSAT                                    ,"m"                                     ,"Width dependence of PSATR" )
`MPRnb( PPSATR            ,PPSAT                                    ,"m^2"                                   ,"Area dependence of PSATR" )
`MPRnb( LPSATB            ,0.0                                      ,"m/V"                                   ,"Length dependence of PSATB" )
`MPRnb( WPSATB            ,0.0                                      ,"m/V"                                   ,"Width dependence of PSATB" )
`MPRnb( PPSATB            ,0.0                                      ,"m^2/V"                                 ,"Area dependence of PSATB" )
`MPRoz( PSATX             ,1.0                                      ,""                                      ,"Fine tuning of PTWG effect" )
`MPRnb( PTWG              ,0.0                                      ,""                                      ,"Idsat variation with gate bias" )
`MPRnb( LPTWG             ,0.0                                      ,"m"                                     ,"Length dependence of PTWG" )
`MPRnb( WPTWG             ,0.0                                      ,"m"                                     ,"Width dependence of PTWG" )
`MPRnb( PPTWG             ,0.0                                      ,"m^2"                                   ,"Area dependence of PTWG" )
`MPRnb( PTWGL             ,0.0                                      ,"m^PTWGLEXP"                            ,"Length dependence coefficient of PTWG" )
`MPRoz( PTWGLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PTWG" )
`MPRnb( PTWGR             ,PTWG                                     ,""                                      ,"Reverse-mode Idsat variation with gate bias" )
`MPRnb( LPTWGR            ,LPTWG                                    ,"m"                                     ,"Length dependence of PTWGR" )
`MPRnb( WPTWGR            ,WPTWG                                    ,"m"                                     ,"Width dependence of PTWGR" )
`MPRnb( PPTWGR            ,PPTWG                                    ,"m^2"                                   ,"Area dependence of PTWGR" )
`MPRnb( PTWGLR            ,PTWGL                                    ,"m^PTWGLEXPR"                           ,"Length dependence coefficient of PTWG" )
`MPRoz( PTWGLEXPR         ,PTWGLEXP                                 ,""                                      ,"Length dependence exponent coefficient of PTWG" )

// Velocity non-saturation effect
`MPRnb( A1                ,0.0                                      ,"1/V^2"                                 ,"Non-saturation effect parameter for strong inversion region" )
`MPRnb( LA1               ,0.0                                      ,"m/V^2"                                 ,"Length dependence of A1" )
`MPRnb( WA1               ,0.0                                      ,"m/V^2"                                 ,"Width dependence of A1" )
`MPRnb( PA1               ,0.0                                      ,"m^2/V^2"                               ,"Area dependence of A1" )
`MPRnb( A11               ,0.0                                      ,""                                      ,"Temperature dependence of A1" )
`MPRnb( LA11              ,0.0                                      ,"m"                                     ,"Length dependence of A11" )
`MPRnb( WA11              ,0.0                                      ,"m"                                     ,"Width dependence of A11" )
`MPRnb( PA11              ,0.0                                      ,"m^2"                                   ,"Area dependence of A11" )
`MPRnb( A2                ,0.0                                      ,"1/V"                                   ,"Non-saturation effect parameter for moderate inversion region" )
`MPRnb( LA2               ,0.0                                      ,"m/V"                                   ,"Length dependence of A2" )
`MPRnb( WA2               ,0.0                                      ,"m/V"                                   ,"Width dependence of A2" )
`MPRnb( PA2               ,0.0                                      ,"m^2/V"                                 ,"Area dependence of A2" )
`MPRnb( A21               ,0.0                                      ,""                                      ,"Temperature dependence of A2" )
`MPRnb( LA21              ,0.0                                      ,"m"                                     ,"Length dependence of A21" )
`MPRnb( WA21              ,0.0                                      ,"m"                                     ,"Width dependence of A21" )
`MPRnb( PA21              ,0.0                                      ,"m^2"                                   ,"Area dependence of A21" )

// Output conductance
`MPRnb( PDIBLC            ,0.0                                      ,""                                      ,"Parameter for DIBL effect on Rout" )
`MPRnb( PDIBLCL           ,0.0                                      ,"m^PDIBLCLEXP"                          ,"Length dependence coefficient of PDIBLC" )
`MPRoz( PDIBLCLEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PDIBLC" )
`MPRnb( LPDIBLC           ,0.0                                      ,"m"                                     ,"Length dependence of PDIBLC" )
`MPRnb( WPDIBLC           ,0.0                                      ,"m"                                     ,"Width dependence of PDIBLC" )
`MPRnb( PPDIBLC           ,0.0                                      ,"m^2"                                   ,"Area dependence of PDIBLC" )
`MPRnb( PDIBLCR           ,PDIBLC                                   ,""                                      ,"Reverse-mode parameter for DIBL effect on Rout" )
`MPRnb( PDIBLCLR          ,PDIBLCL                                  ,"m^PDIBLCLEXPR"                         ,"Length dependence coefficient of PDIBLC" )
`MPRoz( PDIBLCLEXPR       ,PDIBLCLEXP                               ,""                                      ,"Length dependence exponent coefficient of PDIBLC" )
`MPRnb( LPDIBLCR          ,LPDIBLC                                  ,"m"                                     ,"Length dependence of PDIBLCR" )
`MPRnb( WPDIBLCR          ,WPDIBLC                                  ,"m"                                     ,"Width dependence of PDIBLCR" )
`MPRnb( PPDIBLCR          ,PPDIBLC                                  ,"m^2"                                   ,"Area dependence of PDIBLCR" )
`MPRnb( PDIBLCB           ,0.0                                      ,"1/V"                                   ,"Parameter for DIBL effect on Rout" )
`MPRnb( LPDIBLCB          ,0.0                                      ,"m/V"                                   ,"Length dependence of PDIBLCB" )
`MPRnb( WPDIBLCB          ,0.0                                      ,"m/V"                                   ,"Width dependence of PDIBLCB" )
`MPRnb( PPDIBLCB          ,0.0                                      ,"m^2/V"                                 ,"Area dependence of PDIBLCB" )
`MPRnb( PVAG              ,1.0                                      ,""                                      ,"Vg dependence of early voltage" )
`MPRnb( LPVAG             ,0.0                                      ,"m"                                     ,"Length dependence of PVAG" )
`MPRnb( WPVAG             ,0.0                                      ,"m"                                     ,"Width dependence of PVAG" )
`MPRnb( PPVAG             ,0.0                                      ,"m^2"                                   ,"Area dependence of PVAG" )
`MPRnb( FPROUT            ,0.0                                      ,"V/m^0.5"                               ,"Gds degradation factor due to pocket implants" )
`MPRnb( FPROUTL           ,0.0                                      ,"m^FPROUTLEXP"                          ,"Length dependence coefficient of FPROUT" )
`MPRoz( FPROUTLEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of FPROUT" )
`MPRnb( LFPROUT           ,0.0                                      ,"V*m^0.5"                               ,"Length dependence of FPROUT" )
`MPRnb( WFPROUT           ,0.0                                      ,"V*m^0.5"                               ,"Width dependence of FPROUT" )
`MPRnb( PFPROUT           ,0.0                                      ,"V*m^1.5"                               ,"Area dependence of FPROUT" )

// Impact ionization current
`MPRnb( ALPHA0            ,0.0                                      ,"m/V"                                   ,"First parameter of Iii" )
`MPRnb( ALPHA0L           ,0.0                                      ,"m^ALPHA0LEXP"                          ,"Length dependence coefficient of ALPHA0" )
`MPRoz( ALPHA0LEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of ALPHA0" )
`MPRnb( LALPHA0           ,0.0                                      ,"m^2/V"                                 ,"Length dependence of ALPHA0" )
`MPRnb( WALPHA0           ,0.0                                      ,"m^2/V"                                 ,"Width dependence of ALPHA0" )
`MPRnb( PALPHA0           ,0.0                                      ,"m^3/V"                                 ,"Area dependence of ALPHA0" )
`MPRnb( BETA0             ,0.0                                      ,"1/V"                                   ,"Vds dependent parameter of Iii" )
`MPRnb( LBETA0            ,0.0                                      ,"m/V"                                   ,"Length dependence of BETA0" )
`MPRnb( WBETA0            ,0.0                                      ,"m/V"                                   ,"Width dependence of BETA0" )
`MPRnb( PBETA0            ,0.0                                      ,"m^2/V"                                 ,"Area dependence of BETA0" )

// Gate dielectric tunnelling current model parameters
`MPRnb( AIGBACC           ,1.36e-2                                  ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igb" )
`MPRnb( BIGBACC           ,1.71e-3                                  ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igb" )
`MPRnb( CIGBACC           ,0.075                                    ,"1/V"                                   ,"Parameter for Igb" )
`MPRnb( NIGBACC           ,1.0                                      ,""                                      ,"Parameter for Igbacc slope" )
`MPRnb( AIGBINV           ,1.11e-2                                  ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igb" )
`MPRnb( BIGBINV           ,9.49e-4                                  ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igb" )
`MPRnb( CIGBINV           ,0.006                                    ,"1/V"                                   ,"Parameter for Igb" )
`MPRnb( EIGBINV           ,1.1                                      ,"V"                                     ,"Parameter for the Si bandgap for Igbinv" )
`MPRnb( NIGBINV           ,3.0                                      ,""                                      ,"Parameter for Igbinv slope" )
`MPRnb( AIGC              ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igc" )
`MPRnb( BIGC              ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)   ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igc" )
`MPRnb( CIGC              ,((TYPE == `ntype) ? 0.075 : 0.03)        ,"1/V"                                   ,"Parameter for Igc" )
`MPRnb( AIGS              ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igs" )
`MPRnb( BIGS              ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)   ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igs" )
`MPRnb( CIGS              ,((TYPE == `ntype) ? 0.075 : 0.03)        ,"1/V"                                   ,"Parameter for Igs" )
`MPRnb( AIGD              ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igd" )
`MPRnb( BIGD              ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)   ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igd" )
`MPRnb( CIGD              ,((TYPE == `ntype) ? 0.075 : 0.03)        ,"1/V"                                   ,"Parameter for Igd" )
`MPRnb( DLCIG             ,LINT                                     ,"m"                                     ,"Delta L for Ig model" )
`MPRnb( DLCIGD            ,DLCIG                                    ,"m"                                     ,"Delta L for Ig model" )
`MPRnb( POXEDGE           ,1.0                                      ,""                                      ,"Factor for the gate edge Tox" )
`MPRnb( NTOX              ,1.0                                      ,""                                      ,"Exponent for Tox ratio" )
`MPRoz( TOXREF            ,3.0e-9                                   ,"m"                                     ,"Target tox value" )
`MPRcc( PIGCD             ,1.0                                      ,""            ,-50.0       ,50.0        ,"Igc, S/D partition parameter" )
`MPRnb( AIGCL             ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AIGC" )
`MPRnb( AIGCW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AIGC" )
`MPRnb( AIGSL             ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AIGS" )
`MPRnb( AIGSW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AIGS" )
`MPRnb( AIGDL             ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AIGD" )
`MPRnb( AIGDW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AIGD" )
`MPRnb( PIGCDL            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of PIGCD" )
`MPRnb( LAIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGBINV" )
`MPRnb( WAIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence of AIGBINV" )
`MPRnb( PAIGBINV          ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence of AIGBINV" )
`MPRnb( LBIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGBINV" )
`MPRnb( WBIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence of BIGBINV" )
`MPRnb( PBIGBINV          ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence of BIGBINV" )
`MPRnb( LCIGBINV          ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGBINV" )
`MPRnb( WCIGBINV          ,0.0                                      ,"m/V"                                   ,"Width dependence of CIGBINV" )
`MPRnb( PCIGBINV          ,0.0                                      ,"m^2/V"                                 ,"Area dependence of CIGBINV" )
`MPRnb( LEIGBINV          ,0.0                                      ,"m*V"                                   ,"Length dependence of EIGBINV" )
`MPRnb( WEIGBINV          ,0.0                                      ,"m*V"                                   ,"Width dependence of EIGBINV" )
`MPRnb( PEIGBINV          ,0.0                                      ,"m^2*V"                                 ,"Area dependence of EIGBINV" )
`MPRnb( LNIGBINV          ,0.0                                      ,"m"                                     ,"Length dependence of NIGBINV" )
`MPRnb( WNIGBINV          ,0.0                                      ,"m"                                     ,"Width dependence of NIGBINV" )
`MPRnb( PNIGBINV          ,0.0                                      ,"m^2"                                   ,"Area dependence of NIGBINV" )
`MPRnb( LAIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGBACC" )
`MPRnb( WAIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence of AIGBACC" )
`MPRnb( PAIGBACC          ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence of AIGBACC" )
`MPRnb( LBIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGBACC" )
`MPRnb( WBIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence of BIGBACC" )
`MPRnb( PBIGBACC          ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence of BIGBACC" )
`MPRnb( LCIGBACC          ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGBACC" )
`MPRnb( WCIGBACC          ,0.0                                      ,"m/V"                                   ,"Width dependence of CIGBACC" )
`MPRnb( PCIGBACC          ,0.0                                      ,"m^2/V"                                 ,"Area dependence of CIGBACC" )
`MPRnb( LNIGBACC          ,0.0                                      ,"m"                                     ,"Length dependence of NIGBACC" )
`MPRnb( WNIGBACC          ,0.0                                      ,"m"                                     ,"Width dependence of NIGBACC" )
`MPRnb( PNIGBACC          ,0.0                                      ,"m^2"                                   ,"Area dependence of NIGBACC" )
`MPRnb( LAIGC             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGC" )
`MPRnb( WAIGC             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence of AIGC" )
`MPRnb( PAIGC             ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence of AIGC" )
`MPRnb( LBIGC             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGC" )
`MPRnb( WBIGC             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence of BIGC" )
`MPRnb( PBIGC             ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence of BIGC" )
`MPRnb( LCIGC             ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGC" )
`MPRnb( WCIGC             ,0.0                                      ,"m/V"                                   ,"Width dependence of CIGC" )
`MPRnb( PCIGC             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of CIGC" )
`MPRnb( LAIGS             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGS" )
`MPRnb( WAIGS             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence of AIGS" )
`MPRnb( PAIGS             ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence of AIGS" )
`MPRnb( LBIGS             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGS" )
`MPRnb( WBIGS             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence of BIGS" )
`MPRnb( PBIGS             ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence of BIGS" )
`MPRnb( LCIGS             ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGS" )
`MPRnb( WCIGS             ,0.0                                      ,"m/V"                                   ,"Width dependence of CIGS" )
`MPRnb( PCIGS             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of CIGS" )
`MPRnb( LAIGD             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGD" )
`MPRnb( WAIGD             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence of AIGD" )
`MPRnb( PAIGD             ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence of AIGD" )
`MPRnb( LBIGD             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGD" )
`MPRnb( WBIGD             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence of BIGD" )
`MPRnb( PBIGD             ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence of BIGD" )
`MPRnb( LCIGD             ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGD" )
`MPRnb( WCIGD             ,0.0                                      ,"m/V"                                   ,"Width dependence of CIGD" )
`MPRnb( PCIGD             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of CIGD" )
`MPRnb( LPOXEDGE          ,0.0                                      ,"m"                                     ,"Length dependence of POXEDGE" )
`MPRnb( WPOXEDGE          ,0.0                                      ,"m"                                     ,"Width dependence of POXEDGE" )
`MPRnb( PPOXEDGE          ,0.0                                      ,"m^2"                                   ,"Area dependence of POXEDGE" )
`MPRnb( LDLCIG            ,0.0                                      ,"m^2"                                   ,"Length dependence of DLCIG" )
`MPRnb( WDLCIG            ,0.0                                      ,"m^2"                                   ,"Width dependence of DLCIG" )
`MPRnb( PDLCIG            ,0.0                                      ,"m^3"                                   ,"Area dependence of DLCIG" )
`MPRnb( LDLCIGD           ,0.0                                      ,"m^2"                                   ,"Length dependence of DLCIGD" )
`MPRnb( WDLCIGD           ,0.0                                      ,"m^2"                                   ,"Width dependence of DLCIGD" )
`MPRnb( PDLCIGD           ,0.0                                      ,"m^3"                                   ,"Area dependence of DLCIGD" )
`MPRnb( LNTOX             ,0.0                                      ,"m"                                     ,"Length dependence of NTOX" )
`MPRnb( WNTOX             ,0.0                                      ,"m"                                     ,"Width dependence of NTOX" )
`MPRnb( PNTOX             ,0.0                                      ,"m^2"                                   ,"Area dependence of NTOX" )

// GIDL and GISL currents
`MPRnb( AGIDL             ,0.0                                      ,"V/m"                                   ,"Pre-exponential coefficient for GIDL" )
`MPRnb( AGIDLL            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AGIDL" )
`MPRnb( AGIDLW            ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AGIDL" )
`MPRnb( LAGIDL            ,0.0                                      ,"m^2"                                   ,"Length dependence of AGIDL" )
`MPRnb( WAGIDL            ,0.0                                      ,"m^2"                                   ,"Width dependence of AGIDL" )
`MPRnb( PAGIDL            ,0.0                                      ,"m^3"                                   ,"Area dependence of AGIDL" )
`MPRnb( BGIDL             ,2.3e9                                    ,"V/m"                                   ,"Exponential coefficient for GIDL" )
`MPRnb( LBGIDL            ,0.0                                      ,"V"                                     ,"Length dependence of BGIDL" )
`MPRnb( WBGIDL            ,0.0                                      ,"V"                                     ,"Width dependence of BGIDL" )
`MPRnb( PBGIDL            ,0.0                                      ,"V*m"                                   ,"Area dependence of BGIDL" )
`MPRnb( CGIDL             ,0.5                                      ,"V/m"                                   ,"Exponential coefficient for GIDL" )
`MPRnb( LCGIDL            ,0.0                                      ,"V"                                     ,"Length dependence of CGIDL" )
`MPRnb( WCGIDL            ,0.0                                      ,"V"                                     ,"Width dependence of CGIDL" )
`MPRnb( PCGIDL            ,0.0                                      ,"V*m"                                   ,"Area dependence of CGIDL" )
`MPRnb( EGIDL             ,0.8                                      ,"V"                                     ,"Band bending parameter for GIDL" )
`MPRnb( LEGIDL            ,0.0                                      ,"V*m"                                   ,"Length dependence of EGIDL" )
`MPRnb( WEGIDL            ,0.0                                      ,"V*m"                                   ,"Width dependence of EGIDL" )
`MPRnb( PEGIDL            ,0.0                                      ,"V*m^2"                                 ,"Area dependence of EGIDL" )
`MPRnb( AGISL             ,AGIDL                                    ,"V/m"                                   ,"Pre-exponential coefficient for GISL" )
`MPRnb( AGISLL            ,AGIDLL                                   ,"m"                                     ,"Length dependence coefficient of AGISL" )
`MPRnb( AGISLW            ,AGIDLW                                   ,"m"                                     ,"Width dependence coefficient of AGISL" )
`MPRnb( LAGISL            ,LAGIDL                                   ,"m^2"                                   ,"Length dependence of AGISL" )
`MPRnb( WAGISL            ,WAGIDL                                   ,"m^2"                                   ,"Width dependence of AGISL" )
`MPRnb( PAGISL            ,PAGIDL                                   ,"m^3"                                   ,"Area dependence of AGISL" )
`MPRnb( BGISL             ,BGIDL                                    ,"V/m"                                   ,"Exponential coefficient for GISL" )
`MPRnb( LBGISL            ,LBGIDL                                   ,"V"                                     ,"Length dependence of BGISL" )
`MPRnb( WBGISL            ,WBGIDL                                   ,"V"                                     ,"Width dependence of BGISL" )
`MPRnb( PBGISL            ,PBGIDL                                   ,"V*m"                                   ,"Area dependence of BGISL" )
`MPRnb( CGISL             ,CGIDL                                    ,"V/m"                                   ,"Exponential coefficient for GISL" )
`MPRnb( LCGISL            ,LCGIDL                                   ,"V"                                     ,"Length dependence of CGISL" )
`MPRnb( WCGISL            ,WCGIDL                                   ,"V"                                     ,"Width dependence of CGISL" )
`MPRnb( PCGISL            ,PCGIDL                                   ,"V*m"                                   ,"Area dependence of CGISL" )
`MPRnb( EGISL             ,EGIDL                                    ,"V"                                     ,"Band bending parameter for GISL" )
`MPRnb( LEGISL            ,LEGIDL                                   ,"V*m"                                   ,"Length dependence of EGISL" )
`MPRnb( WEGISL            ,WEGIDL                                   ,"V*m"                                   ,"Width dependence of EGISL" )
`MPRnb( PEGISL            ,PEGIDL                                   ,"V*m^2"                                 ,"Area dependence of EGISL" )

// Overlap capacitance and fringing capacitance
`MPRnb( CF                ,0.0                                      ,"F/m"                                   ,"Outer fringe capacitance" )
`MPRnb( LCF               ,0.0                                      ,"F"                                     ,"Length dependence of CF" )
`MPRnb( WCF               ,0.0                                      ,"F"                                     ,"Width dependence of CF" )
`MPRnb( PCF               ,0.0                                      ,"F*m"                                   ,"Area dependence of CF" )
`MPRco( CFRCOEFF          ,1.0                                      ,"F/m"         ,1.0         ,inf         ,"Coefficient for outer fringe capacitance" )
`MPRnb( CGSO              ,0.0                                      ,"F/m"                                   ,"Gate-to-source overlap capacitance" )
`MPRnb( CGDO              ,0.0                                      ,"F/m"                                   ,"Gate-to-drain overlap capacitance" )
`MPRnb( CGBO              ,0.0                                      ,"F/m"                                   ,"Gate-to-body overlap capacitance" )
`MPRnb( CGSL              ,0.0                                      ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" )
`MPRnb( LCGSL             ,0.0                                      ,""                                      ,"Length dependence of CGSL" )
`MPRnb( WCGSL             ,0.0                                      ,""                                      ,"Width dependence of CGSL" )
`MPRnb( PCGSL             ,0.0                                      ,""                                      ,"Area dependence of CGSL" )
`MPRnb( CGDL              ,0.0                                      ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" )
`MPRnb( LCGDL             ,0.0                                      ,"F"                                     ,"Length dependence of CGDL" )
`MPRnb( WCGDL             ,0.0                                      ,"F"                                     ,"Width dependence of CGDL" )
`MPRnb( PCGDL             ,0.0                                      ,"F*m"                                   ,"Area dependence of CGDL" )
`MPRnb( CKAPPAS           ,0.6                                      ,"V"                                     ,"Coefficient of bias-dependent overlap capacitance for the source side" )
`MPRnb( LCKAPPAS          ,0.0                                      ,"m*V"                                   ,"Length dependence of CKAPPAS" )
`MPRnb( WCKAPPAS          ,0.0                                      ,"m*V"                                   ,"Width dependence of CKAPPAS" )
`MPRnb( PCKAPPAS          ,0.0                                      ,"m^2*V"                                 ,"Area dependence of CKAPPAS" )
`MPRnb( CKAPPAD           ,0.6                                      ,"V"                                     ,"Coefficient of bias-dependent overlap capacitance for the drain side" )
`MPRnb( LCKAPPAD          ,0.0                                      ,"m*V"                                   ,"Length dependence of CKAPPAD" )
`MPRnb( WCKAPPAD          ,0.0                                      ,"m*V"                                   ,"Width dependence of CKAPPAD" )
`MPRnb( PCKAPPAD          ,0.0                                      ,"m^2*V"                                 ,"Area dependence of CKAPPAD" )

// Layout-dependent parasitics model parameters (resistance only)
`MPRnb( DMCG              ,0.0                                      ,"m"                                     ,"Distance of mid-contact to gate edge" )
`MPRnb( DMCI              ,DMCG                                     ,"m"                                     ,"Distance of mid-contact to isolation" )
`MPRnb( DMDG              ,0.0                                      ,"m"                                     ,"Distance of mid-ciffusion to gate edge" )
`MPRnb( DMCGT             ,0.0                                      ,"m"                                     ,"Distance of id-contact to gate edge in test" )
`MPRoo( XGL               ,0.0                                      ,"m"           ,-inf        ,(L*LMLT+XL) ,"Variation in Ldrawn" )
`MPRcz( RSHG              ,0.1                                      ,"ohm"                                   ,"Gate sheet resistance" )

// Junction capacitance
`MPRnb( CJS               ,5.0e-4                                   ,"F/m^2"                                 ,"Unit area source-side junction capacitance at zero bias" )
`MPRnb( CJD               ,CJS                                      ,"F/m^2"                                 ,"Unit area drain-side junction capacitance at zero bias" )
`MPRnb( CJSWS             ,5.0e-10                                  ,"F/m"                                   ,"Unit length source-side side-wall junction capacitance at zero bias" )
`MPRnb( CJSWD             ,CJSWS                                    ,"F/m"                                   ,"Unit length drain-side side-wall junction capacitance at zero bias" )
`MPRnb( CJSWGS            ,0.0                                      ,"F/m"                                   ,"Unit length source-side gate side-wall junction capacitance at zero bias" )
`MPRnb( CJSWGD            ,CJSWGS                                   ,"F/m"                                   ,"Unit length drain-side gate side-wall junction capacitance at zero bias" )
`MPRnb( PBS               ,1.0                                      ,"V"                                     ,"Source-side bulk junction built-in potential" )
`MPRnb( PBD               ,PBS                                      ,"V"                                     ,"Drain-side bulk junction built-in potential" )
`MPRnb( PBSWS             ,1.0                                      ,"V"                                     ,"Built-in potential for Source-side side-wall junction capacitance" )
`MPRnb( PBSWD             ,PBSWS                                    ,"V"                                     ,"Built-in potential for Drain-side side-wall junction capacitance" )
`MPRnb( PBSWGS            ,PBSWS                                    ,"V"                                     ,"Built-in potential for Source-side gate side-wall junction capacitance" )
`MPRnb( PBSWGD            ,PBSWGS                                   ,"V"                                     ,"Built-in potential for Drain-side gate side-wall junction capacitance" )
`MPRnb( MJS               ,0.5                                      ,""                                      ,"Source bottom junction capacitance grading coefficient" )
`MPRnb( MJD               ,MJS                                      ,""                                      ,"Drain bottom junction capacitance grading coefficient" )
`MPRnb( MJSWS             ,0.33                                     ,""                                      ,"Source side-wall junction capacitance grading coefficient" )
`MPRnb( MJSWD             ,MJSWS                                    ,""                                      ,"Drain side-wall junction capacitance grading coefficient" )
`MPRnb( MJSWGS            ,MJSWS                                    ,""                                      ,"Source-side gate side-wall junction capacitance grading coefficient" )
`MPRnb( MJSWGD            ,MJSWGS                                   ,""                                      ,"Drain-side gate side-wall junction capacitance grading coefficient" )

// Junction current
`MPRnb( JSS               ,1.0e-4                                   ,"A/m^2"                                 ,"Bottom source junction reverse saturation current density" )
`MPRnb( JSD               ,JSS                                      ,"A/m^2"                                 ,"Bottom drain junction reverse saturation current density" )
`MPRnb( JSWS              ,0.0                                      ,"A/m"                                   ,"Unit length reverse saturation current for side-wall source junction" )
`MPRnb( JSWD              ,JSWS                                     ,"A/m"                                   ,"Unit length reverse saturation current for side-wall drain junction" )
`MPRnb( JSWGS             ,0.0                                      ,"A/m"                                   ,"Unit length reverse saturation current for gate-edge side-wall source junction" )
`MPRnb( JSWGD             ,JSWGS                                    ,"A/m"                                   ,"Unit length reverse saturation current for gate-edge side-wall drain junction" )
`MPRoz( NJS               ,1.0                                      ,""                                      ,"Source junction emission coefficient" )
`MPRoz( NJD               ,NJS                                      ,""                                      ,"Drain junction emission coefficient" )
`MPRnb( IJTHSFWD          ,0.1                                      ,"A"                                     ,"Forward source diode breakdown limiting current" )
`MPRnb( IJTHDFWD          ,IJTHSFWD                                 ,"A"                                     ,"Forward drain diode breakdown limiting current" )
`MPRnb( IJTHSREV          ,0.1                                      ,"A"                                     ,"Reverse source diode breakdown limiting current" )
`MPRnb( IJTHDREV          ,IJTHSREV                                 ,"A"                                     ,"Reverse drain diode breakdown limiting current" )
`MPRnb( BVS               ,10.0                                     ,"V"                                     ,"Source diode breakdown voltage" )
`MPRnb( BVD               ,BVS                                      ,"V"                                     ,"Drain diode breakdown voltage" )
`MPRoz( XJBVS             ,1.0                                      ,""                                      ,"Fitting parameter for source diode breakdown current" )
`MPRoz( XJBVD             ,XJBVS                                    ,""                                      ,"Fitting parameter for drain diode breakdown current" )

// Tunneling component of junction current
`MPRnb( JTSS              ,0.0                                      ,"A/m"                                   ,"Bottom source junction trap-assisted saturation current density" )
`MPRnb( JTSD              ,JTSS                                     ,"A/m"                                   ,"Bottom drain junction trap-assisted saturation current density" )
`MPRnb( JTSSWS            ,0.0                                      ,"A/m^2"                                 ,"Unit length trap-assisted saturation current for side-wall source junction" )
`MPRnb( JTSSWD            ,JTSSWS                                   ,"A/m^2"                                 ,"Unit length trap-assisted saturation current for side-wall drain junction" )
`MPRnb( JTSSWGS           ,0.0                                      ,"A/m"                                   ,"Unit length trap-assisted saturation current for gate-edge side-wall source junction" )
`MPRnb( JTSSWGD           ,JTSSWGS                                  ,"A/m"                                   ,"Unit length trap-assisted saturation current for gate-edge side-wall drain junction" )
`MPRcz( JTWEFF            ,0.0                                      ,""                                      ,"Trap assisted tunnelling current width dependence" )
`MPRnb( NJTS              ,20.0                                     ,""                                      ,"Non-ideality factor for JTSS" )
`MPRnb( NJTSD             ,NJTS                                     ,""                                      ,"Non-ideality factor for JTSD" )
`MPRnb( NJTSSW            ,20.0                                     ,""                                      ,"Non-ideality factor for JTSSWS" )
`MPRnb( NJTSSWD           ,NJTSSW                                   ,""                                      ,"Non-ideality factor for JTSSWD" )
`MPRnb( NJTSSWG           ,20.0                                     ,""                                      ,"Non-ideality factor for JTSSWGS" )
`MPRnb( NJTSSWGD          ,NJTSSWG                                  ,""                                      ,"Non-ideality factor for JTSSWGD" )
`MPRnb( VTSS              ,10.0                                     ,"V"                                     ,"Bottom source junction trap-assisted current voltage dependent parameter" )
`MPRnb( VTSD              ,VTSS                                     ,"V"                                     ,"Bottom drain junction trap-assisted current voltage dependent parameter" )
`MPRnb( VTSSWS            ,10.0                                     ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for side-wall source junction" )
`MPRnb( VTSSWD            ,VTSSWS                                   ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for side-wall drain junction" )
`MPRnb( VTSSWGS           ,10.0                                     ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for gate-edge side-wall source junction" )
`MPRnb( VTSSWGD           ,VTSSWGS                                  ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for gate-edge side-wall drain junction" )

// High-speed/RF model parameters
`MPRnb( XRCRG1            ,12.0                                     ,""                                      ,"1st fitting parameter the bias-dependent Rg " )
`MPRnb( XRCRG2            ,1.0                                      ,""                                      ,"2nd fitting parameter the bias-dependent Rg " )
`MPRcz( GBMIN             ,1.0e-12                                  ,"mho"                                   ,"Minimum body conductance" )
`MPRoz( RBPS0             ,50.0                                     ,"ohm"                                   ,"Scaling pre-factor for RBPS" )
`MPRcz( RBPSL             ,0.0                                      ,""                                      ,"Length scaling parameter for RBPS" )
`MPRcz( RBPSW             ,0.0                                      ,""                                      ,"Width scaling parameter for RBPS" )
`MPRcz( RBPSNF            ,0.0                                      ,""                                      ,"Number of fingers scaling parameter for RBPS" )
`MPRoz( RBPD0             ,50.0                                     ,"ohm"                                   ,"Scaling pre-factor for RBPD" )
`MPRcz( RBPDL             ,0.0                                      ,""                                      ,"Length scaling parameter for RBPD" )
`MPRcz( RBPDW             ,0.0                                      ,""                                      ,"Width scaling parameter for RBPD" )
`MPRcz( RBPDNF            ,0.0                                      ,""                                      ,"Number of fingers scaling parameter for RBPD" )
`MPRoz( RBPBX0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBPBX" )
`MPRcz( RBPBXL            ,0.0                                      ,""                                      ,"Length scaling parameter for RBPBX" )
`MPRcz( RBPBXW            ,0.0                                      ,""                                      ,"Width scaling parameter for RBPBX" )
`MPRcz( RBPBXNF           ,0.0                                      ,""                                      ,"Number of fingers scaling parameter for RBPBX" )
`MPRoz( RBPBY0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBPBY" )
`MPRcz( RBPBYL            ,0.0                                      ,""                                      ,"Length scaling parameter for RBPBY" )
`MPRcz( RBPBYW            ,0.0                                      ,""                                      ,"Width scaling parameter for RBPBY" )
`MPRcz( RBPBYNF           ,0.0                                      ,""                                      ,"Number of fingers scaling parameter for RBPBY" )
`MPRoz( RBSBX0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBSBX" )
`MPRoz( RBSBY0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBSBY" )
`MPRoz( RBDBX0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBDBX" )
`MPRoz( RBDBY0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBDBY" )
`MPRcz( RBSDBXL           ,0.0                                      ,""                                      ,"Length scaling parameter for RBSBX and RBDBX" )
`MPRcz( RBSDBXW           ,0.0                                      ,""                                      ,"Width scaling parameter for RBSBX and RBDBX" )
`MPRcz( RBSDBXNF          ,0.0                                      ,""                                      ,"Number of fingers scaling parameter for RBSBX and RBDBX" )
`MPRcz( RBSDBYL           ,0.0                                      ,""                                      ,"Length scaling parameter for RBSBY and RBDBY" )
`MPRcz( RBSDBYW           ,0.0                                      ,""                                      ,"Width scaling parameter for RBSBY and RBDBY" )
`MPRcz( RBSDBYNF          ,0.0                                      ,""                                      ,"Number of fingers scaling parameter for RBSBY and RBDBY" )

// Flicker noise
`MPRoc( EF                ,1.0                                      ,""            ,0.0         ,2.0         ,"Flicker noise frequency exponent" )
`MPRnb( EM                ,4.1e7                                    ,"V/m"                                   ,"Saturation field" )
`MPRnb( NOIA              ,6.250e40                                 ,"s^(1-EF)/(eV)^1/m^3"                   ,"Flicker noise parameter A" )
`MPRnb( NOIB              ,3.125e25                                 ,"s^(1-EF)/(eV)^1/m"                     ,"Flicker noise parameter B" )
`MPRnb( NOIC              ,8.750e8                                  ,"s^(1-EF)*m/(eV)^1"                     ,"Flicker noise parameter C" )
`MPRnb( LINTNOI           ,0.0                                      ,"m"                                     ,"Length reduction parameter offset" )
`MPRcz( NOIA1             ,0.0                                      ,""                                      ,"Flicker noise fitting parameter in strong inversion" )
`MPRoz( NOIAX             ,1.0                                      ,""                                      ,"Flicker noise fitting parameter in strong inversion for high VDS" )

// Thermal noise
`MPRcz( NTNOI             ,1.0                                      ,""                                      ,"Noise factor for short-channel devices for TNOIMOD=0 only" )
`MPRnb( RNOIA             ,0.577                                    ,""                                      ,"Noise parameter for TNOIMOD = 1" )
`MPRnb( RNOIB             ,0.5164                                   ,""                                      ,"Noise parameter for TNOIMOD = 1" )
`MPRnb( RNOIC             ,0.395                                    ,""                                      ,"Noise parameter for TNOIMOD = 1" )
`MPRoo( TNOIA             ,1.5                                      ,""            ,-inf        ,inf         ,"Noise parameter for TNOIMOD = 1" )
`MPRoo( TNOIB             ,3.5                                      ,""            ,-inf        ,inf         ,"Noise parameter for TNOIMOD = 1" )
`MPRoo( TNOIC             ,0.0                                      ,""            ,-inf        ,inf         ,"Noise correlation coefficient for TNOIMOD = 1" )

// Binning parameters
`MPIcc( BINUNIT           ,1                                        ,""            ,0           ,1           ,"Unit of L and W for Binning, 1: micro-meter, 0: default" )
`MPRnb( DLBIN             ,0.0                                      ,""                                      ,"Length reduction parameter for binning" )
`MPRnb( DWBIN             ,0.0                                      ,""                                      ,"Width reduction parameter for binning" )

// Temperature dependence parameters
`MPRnb( TNOM              ,27.0                                     ,"degC"                                  ,"Temperature at which the model was extracted" )
`MPRnb( TBGASUB           ,4.73e-4                                  ,"eV/K"                                  ,"Bandgap temperature coefficient" )
`MPRnb( TBGBSUB           ,636.0                                    ,"K"                                     ,"Bandgap temperature coefficient" )
`MPRnb( TNFACTOR          ,0.0                                      ,""                                      ,"Temperature exponent for NFACTOR" )
`MPRnb( UTE               ,-1.5                                     ,""                                      ,"Mobility temperature exponent" )
`MPRnb( LUTE              ,0.0                                      ,"m"                                     ,"Length dependence of UTE" )
`MPRnb( WUTE              ,0.0                                      ,"m"                                     ,"Width dependence of UTE" )
`MPRnb( PUTE              ,0.0                                      ,"m^2"                                   ,"Area dependence of UTE" )
`MPRnb( UTEL              ,0.0                                      ,"m"                                     ,"Length scaling parameter for UTE" )
`MPRnb( UA1               ,1.0e-3                                   ,"m/V"                                   ,"Temperature coefficient for UA" )
`MPRnb( LUA1              ,0.0                                      ,"m^2/V"                                 ,"Length dependence of UA1" )
`MPRnb( WUA1              ,0.0                                      ,"m^2/V"                                 ,"Width dependence of UA1" )
`MPRnb( PUA1              ,0.0                                      ,"m^3/V"                                 ,"Area dependence of UA1" )
`MPRnb( UA1L              ,0.0                                      ,"m"                                     ,"Length scaling parameter for UA1" )
`MPRnb( UC1               ,0.056e-9                                 ,"1/K"                                   ,"Temperature coefficient for UC" )
`MPRnb( LUC1              ,0.0                                      ,"m/K"                                   ,"Length dependence of UC1" )
`MPRnb( WUC1              ,0.0                                      ,"m/K"                                   ,"Width dependence of UC1" )
`MPRnb( PUC1              ,0.0                                      ,"m^2/K"                                 ,"Area dependence of UC1" )
`MPRnb( UD1               ,0.0                                      ,"1/m^2"                                 ,"Temperature coefficient for UD" )
`MPRnb( LUD1              ,0.0                                      ,"1/m"                                   ,"Length dependence of UD1" )
`MPRnb( WUD1              ,0.0                                      ,"1/m"                                   ,"Width dependence of UD1" )
`MPRnb( PUD1              ,0.0                                      ,""                                      ,"Area dependence of UD1" )
`MPRnb( UD1L              ,0.0                                      ,"m"                                     ,"Length scaling parameter for UD1" )
`MPRnb( EU1               ,0.0                                      ,""                                      ,"Temperature coefficient for EU" )
`MPRnb( LEU1              ,0.0                                      ,"m"                                     ,"Length dependence of EU1" )
`MPRnb( WEU1              ,0.0                                      ,"m"                                     ,"Width dependence of EU1" )
`MPRnb( PEU1              ,0.0                                      ,"m^2"                                   ,"Area dependence of EU1" )
`MPRnb( UCSTE             ,-4.775e-3                                ,""                                      ,"Temperature coefficient for UCS" )
`MPRnb( LUCSTE            ,0.0                                      ,"m"                                     ,"Length dependence of UCSTE" )
`MPRnb( WUCSTE            ,0.0                                      ,"m"                                     ,"Width dependence of UCSTE" )
`MPRnb( PUCSTE            ,0.0                                      ,"m^2"                                   ,"Area dependence of UCSTE" )
`MPRnb( TETA0             ,0.0                                      ,""                                      ,"Temperature coefficient for ETA0" )
`MPRnb( PRT               ,0.0                                      ,""                                      ,"Temperature coefficient for resistance" )
`MPRnb( LPRT              ,0.0                                      ,"m"                                     ,"Length dependence of PRT" )
`MPRnb( WPRT              ,0.0                                      ,"m"                                     ,"Width dependence of PRT" )
`MPRnb( PPRT              ,0.0                                      ,"m^2"                                   ,"Area dependence of PRT" )
`MPRnb( AT                ,-1.56e-3                                 ,"m/s"                                   ,"Temperature coefficient for saturation velocity" )
`MPRnb( LAT               ,0.0                                      ,"m^2/s"                                 ,"Length dependence of AT" )
`MPRnb( WAT               ,0.0                                      ,"m^2/s"                                 ,"Width dependence of AT" )
`MPRnb( PAT               ,0.0                                      ,"m^3/s"                                 ,"Area dependence of AT" )
`MPRnb( ATL               ,0.0                                      ,"m"                                     ,"Length Scaling parameter for AT" )
`MPRnb( TDELTA            ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for DELTA" )
`MPRnb( PTWGT             ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for PTWG" )
`MPRnb( LPTWGT            ,0.0                                      ,"m/K"                                   ,"Length dependence of PTWGT" )
`MPRnb( WPTWGT            ,0.0                                      ,"m/K"                                   ,"Width dependence of PTWGT" )
`MPRnb( PPTWGT            ,0.0                                      ,"m^2/K"                                 ,"Area dependence of PTWGT" )
`MPRnb( PTWGTL            ,0.0                                      ,"m"                                     ,"Length acaling parameter for PTWGT" )
`MPRnb( KT1               ,-0.11                                    ,"V"                                     ,"Temperature coefficient for Vth" )
`MPRoz( KT1EXP            ,1.0                                      ,""                                      ,"Temperature coefficient for Vth" )
`MPRnb( KT1L              ,0.0                                      ,"V*m"                                   ,"Temperature coefficient for Vth" )
`MPRnb( LKT1              ,0.0                                      ,"V*m"                                   ,"Length dependence of KT1" )
`MPRnb( WKT1              ,0.0                                      ,"V*m"                                   ,"Width dependence of KT1" )
`MPRnb( PKT1              ,0.0                                      ,"V*m^2"                                 ,"Area dependence of KT1" )
`MPRnb( KT2               ,0.022                                    ,""                                      ,"Temperature coefficient for Vth" )
`MPRnb( LKT2              ,0.0                                      ,"m"                                     ,"Length dependence of KT2" )
`MPRnb( WKT2              ,0.0                                      ,"m"                                     ,"Width dependence of KT2" )
`MPRnb( PKT2              ,0.0                                      ,"m^2"                                   ,"Area dependence of KT2" )
`MPRnb( IIT               ,0.0                                      ,""                                      ,"Temperature coefficient for BETA0" )
`MPRnb( LIIT              ,0.0                                      ,"m"                                     ,"Length dependence of IIT" )
`MPRnb( WIIT              ,0.0                                      ,"m"                                     ,"Width dependence of IIT" )
`MPRnb( PIIT              ,0.0                                      ,"m^2"                                   ,"Area dependence of IIT" )
`MPRnb( IGT               ,2.5                                      ,""                                      ,"Gate current temperature dependence" )
`MPRnb( LIGT              ,0.0                                      ,"m"                                     ,"Length dependence of IGT" )
`MPRnb( WIGT              ,0.0                                      ,"m"                                     ,"Width dependence of IGT" )
`MPRnb( PIGT              ,0.0                                      ,"m^2"                                   ,"Area dependence of IGT" )
`MPRnb( TGIDL             ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for GIDL/GISL" )
`MPRnb( LTGIDL            ,0.0                                      ,"m/K"                                   ,"Length dependence of TGIDL" )
`MPRnb( WTGIDL            ,0.0                                      ,"m/K"                                   ,"Width dependence of TGIDL" )
`MPRnb( PTGIDL            ,0.0                                      ,"m^2/K"                                 ,"Area dependence of TGIDL" )
`MPRnb( TCJ               ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for CJS/CJD" )
`MPRnb( TCJSW             ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for CJSWS/CJSWD" )
`MPRnb( TCJSWG            ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for CJSWGS/CJSWGD" )
`MPRnb( TPB               ,0.0                                      ,"V/K"                                   ,"Temperature coefficient for PBS/PBD" )
`MPRnb( TPBSW             ,0.0                                      ,"V/K"                                   ,"Temperature coefficient for PBSWS/PBSWD" )
`MPRnb( TPBSWG            ,0.0                                      ,"V/K"                                   ,"Temperature coefficient for PBSWGS/PBSWGD" )
`MPRnb( XTIS              ,3.0                                      ,""                                      ,"Source junction current temperature exponent" )
`MPRnb( XTID              ,XTIS                                     ,""                                      ,"Drain junction current temperature exponent" )
`MPRnb( XTSS              ,0.02                                     ,""                                      ,"Power dependence of JTSS on temperature" )
`MPRnb( XTSD              ,XTSS                                     ,""                                      ,"Power dependence of JTSD on temperature" )
`MPRnb( XTSSWS            ,0.02                                     ,""                                      ,"Power dependence of JTSSWS on temperature" )
`MPRnb( XTSSWD            ,XTSSWS                                   ,""                                      ,"Power dependence of JTSSWD on temperature" )
`MPRnb( XTSSWGS           ,0.02                                     ,""                                      ,"Power dependence of JTSSWGS on temperature" )
`MPRnb( XTSSWGD           ,XTSSWGS                                  ,""                                      ,"Power dependence of JTSSWGD on temperature" )
`MPRnb( TNJTS             ,0.0                                      ,""                                      ,"Temperature coefficient for NJTS" )
`MPRnb( TNJTSD            ,TNJTS                                    ,""                                      ,"Temperature coefficient for NJTSD" )
`MPRnb( TNJTSSW           ,0.0                                      ,""                                      ,"Temperature coefficient for NJTSSW" )
`MPRnb( TNJTSSWD          ,TNJTSSW                                  ,""                                      ,"Temperature coefficient for NJTSSWD" )
`MPRnb( TNJTSSWG          ,0.0                                      ,""                                      ,"Temperature coefficient for NJTSSWG" )
`MPRnb( TNJTSSWGD         ,TNJTSSWG                                 ,""                                      ,"Temperature coefficient for NJTSSWGD" )

// Self heating parameters
`MPRco( RTH0              ,0.0                                      ,"m*K/W"       ,0.0         ,inf         ,"Thermal resistance" )
`MPRco( CTH0              ,1.0e-5                                   ,"s*W/(m*K)"   ,0.0         ,inf         ,"Thermal capacitance" )
`MPRnb( WTH0              ,0.0                                      ,"m"                                     ,"Width dependence coefficient for Rth and Cth" )

// Stress related parameters
`MPRoz( SAREF             ,1.0e-6                                   ,"m"                                     ,"Reference distance between OD edge from Poly from one side" )
`MPRoz( SBREF             ,1.0e-6                                   ,"m"                                     ,"Reference distance between OD edge from Poly from other side" )
`MPRcz( WLOD              ,0.0                                      ,"m"                                     ,"Width parameter for stress effect" )
`MPRnb( KU0               ,0.0                                      ,"m"                                     ,"Mobility degradation/enhancement parameter for stress effect" )
`MPRnb( KVSAT             ,0.0                                      ,"m"                                     ,"Saturation velocity degradation/enhancement parameter for stress effect" )
`MPRnb( TKU0              ,0.0                                      ,""                                      ,"Temperature coefficient for KU0" )
`MPRnb( LKU0              ,0.0                                      ,"m^LLODKU0"                             ,"Length dependence of KU0" )
`MPRnb( WKU0              ,0.0                                      ,"m^WLODKU0"                             ,"Width dependence of KU0" )
`MPRnb( PKU0              ,0.0                                      ,"m^(LLODKU0+WLODKU0)"                   ,"Cross-term dependence of KU0" )
`MPRnb( LLODKU0           ,0.0                                      ,""                                      ,"Length parameter for U0 stress effect" )
`MPRnb( WLODKU0           ,0.0                                      ,""                                      ,"Width parameter for U0 stress effect" )
`MPRnb( KVTH0             ,0.0                                      ,"V*m"                                   ,"Threshold shift parameter for stress effect" )
`MPRnb( LKVTH0            ,0.0                                      ,"m^LLODKU0"                             ,"Length dependence of KVTH0" )
`MPRnb( WKVTH0            ,0.0                                      ,"m^WLODKU0"                             ,"Width dependence of KVTH0" )
`MPRnb( PKVTH0            ,0.0                                      ,"m^(LLODKU0+WLODKU0)"                   ,"Cross-term dependence of KVTH0" )
`MPRnb( LLODVTH           ,0.0                                      ,""                                      ,"Length parameter for Vth stress effect" )
`MPRnb( WLODVTH           ,0.0                                      ,""                                      ,"Width parameter for Vth stress effect" )
`MPRnb( STK2              ,0.0                                      ,"m"                                     ,"K2 shift factor related to Vth change" )
`MPRnb( LODK2             ,0.0                                      ,""                                      ,"K2 shift modification factor for stress effect" )
`MPRnb( STETA0            ,0.0                                      ,"m"                                     ,"ETA0 shift related to Vth0 change" )
`MPRnb( LODETA0           ,0.0                                      ,""                                      ,"ETA0 modification factor for stress effect" )

// Well proximity parameters
`MPRnb( WEB               ,0.0                                      ,""                                      ,"Coefficient for SCB (> 0)" )
`MPRnb( WEC               ,0.0                                      ,""                                      ,"Coefficient for SCC (> 0)" )
`MPRnb( KVTH0WE           ,0.0                                      ,""                                      ,"Threshold shift factor for well proximity effect" )
`MPRnb( LKVTH0WE          ,0.0                                      ,"m"                                     ,"Length dependence of KVTH0WE" )
`MPRnb( WKVTH0WE          ,0.0                                      ,"m"                                     ,"Width dependence of KVTH0WE" )
`MPRnb( PKVTH0WE          ,0.0                                      ,"m^2"                                   ,"Area dependence of KVTH0WE" )
`MPRnb( K2WE              ,0.0                                      ,""                                      ,"K2 shift factor for well proximity effect" )
`MPRnb( LK2WE             ,0.0                                      ,"m"                                     ,"Length dependence of K2WE" )
`MPRnb( WK2WE             ,0.0                                      ,"m"                                     ,"Width dependence of K2WE" )
`MPRnb( PK2WE             ,0.0                                      ,"m^2"                                   ,"Area dependence of K2WE" )
`MPRnb( KU0WE             ,0.0                                      ,""                                      ,"Mobility degradation factor for well proximity effect" )
`MPRnb( LKU0WE            ,0.0                                      ,"m"                                     ,"Length dependence of KU0WE" )
`MPRnb( WKU0WE            ,0.0                                      ,"m"                                     ,"Width dependence of KU0WE" )
`MPRnb( PKU0WE            ,0.0                                      ,"m^2"                                   ,"Area dependence of KU0WE" )
`MPRoo( SCREF             ,1.0e-6                                   ,"m"           ,0.0         ,inf         ,"Reference distance to calculate SCA,SCB and SCC (< 0)" )

// Sub-surface leakage drain current
`MPRnb( SSL0              ,4.0e2                                    ,"A/m"                                   ,"Temperature- and doping-independent parameter for sub-surface leakage drain current" )
`MPRnb( SSL1              ,3.36e8                                   ,"1/m"                                   ,"Temperature- and doping-independent parameter for gate length for sub-surface leakage drain current" )
`MPRnb( SSL2              ,0.185                                    ,""                                      ,"Fitting parameter for sub-surface leakage drain current: barrier height" )
`MPRnb( SSL3              ,0.3                                      ,"V"                                     ,"Fitting parameter for sub-surface leakage drain current: gate voltage effect" )
`MPRnb( SSL4              ,1.4                                      ,"1/V"                                   ,"Fitting parameter for sub-surface leakage drain current: gate voltage effect" )
`MPRnb( SSL5              ,0                                      ,"1/V"                                   ,"Fitting parameter for sub-surface leakage drain current: gate voltage effect")
`MPRnb( SSLEXP1           ,0.490                                    ,""                                      ,"Fitting exponent for SSL doping effect" )
`MPRnb( SSLEXP2           ,1.42                                     ,""                                      ,"Fitting exponent for SSL temperature" )

// Vdsx smoothing
`MPRco( AVDSX             ,20.0                                     ,""            ,5.0         ,100.0       ,"Smoothing parameter in Vdsx in Vbsx" )

// STI edge FET device parameters
`MPRco( WEDGE             ,10.0e-9                                  ,"m"           ,1.0e-9      ,inf         ,"Edge FET width" )
`MPRoo( DGAMMAEDGE        ,0.0                                      ,""            ,-inf        ,inf         ,"Different in body-bias coefficient between Edge-FET and Main-FET" )
`MPRoo( DGAMMAEDGEL       ,0.0                                      ,""            ,-inf        ,inf         ,"L dependence parameter for DGAMMA" )
`MPRoo( DGAMMAEDGELEXP    ,1.0                                      ,""            ,-inf        ,inf         ,"Exponent of L dependence parameter for DGAMMA" )
`MPRoo( DVTEDGE           ,0.0                                      ,""            ,-inf        ,inf         ,"Vth shift for Edge FET" )
`MPRnb( NDEPEDGE          ,1e24                                     ,"1/m^3"                                 ,"Channel doping concentration for EDGEFET" )
`MPRnb( LNDEPEDGE         ,0.0                                      ,"1/m^2"                                 ,"Length dependence of NDEPEDGE" )
`MPRnb( WNDEPEDGE         ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NDEPEDGE" )
`MPRnb( PNDEPEDGE         ,0.0                                      ,"1/m"                                   ,"Area dependence of NDEPEDGE" )
`MPRnb( NFACTOREDGE       ,0.0                                      ,""                                      ,"NFACTOR for Edge FET" )
`MPRnb( LNFACTOREDGE      ,0.0                                      ,"m"                                     ,"Length dependence of NFACTOREDGE" )
`MPRnb( WNFACTOREDGE      ,0.0                                      ,"m"                                     ,"Width dependence of NFACTOREDGE" )
`MPRnb( PNFACTOREDGE      ,0.0                                      ,"m^2"                                   ,"Area dependence of NFACTOREDGE" )
`MPRnb( CITEDGE           ,0.0                                      ,"F/m^2"                                 ,"CIT for Edge FET" )
`MPRnb( LCITEDGE          ,0.0                                      ,"F/m"                                   ,"Length dependence of CITEDGE" )
`MPRnb( WCITEDGE          ,0.0                                      ,"F/m"                                   ,"Width dependence of CITEDGE" )
`MPRnb( PCITEDGE          ,0.0                                      ,"F"                                     ,"Area dependence of CITEDGE" )
`MPRnb( CDSCDEDGE         ,1e-9                                     ,"F/m^2/V"                               ,"CDSCD for edge FET" )
`MPRnb( LCDSCDEDGE        ,0.0                                      ,"F/m/V"                                 ,"Length dependence of CDSCDEDGE" )
`MPRnb( WCDSCDEDGE        ,0.0                                      ,"F/m/V"                                 ,"Width dependence of CDSCDEDGE" )
`MPRnb( PCDSCDEDGE        ,0.0                                      ,"F/V"                                   ,"Area dependence of CDSCDEDGE" )
`MPRnb( CDSCBEDGE         ,0.0                                      ,"F/m^2/V"                               ,"CDSCB for edge FET" )
`MPRnb( LCDSCBEDGE        ,0.0                                      ,"F/m/V"                                 ,"Length dependence of CDSCBEDGE" )
`MPRnb( WCDSCBEDGE        ,0.0                                      ,"F/m/V"                                 ,"Width dependence of CDSCBEDGE" )
`MPRnb( PCDSCBEDGE        ,0.0                                      ,"F/V"                                   ,"Area dependence of CDSCBEDGE" )
`MPRnb( ETA0EDGE          ,0.08                                     ,""                                      ,"DIBL parameter for edge FET" )
`MPRnb( LETA0EDGE         ,0.0                                      ,"m"                                     ,"Length dependence of ETA0EDGE" )
`MPRnb( WETA0EDGE         ,0.0                                      ,"m"                                     ,"Width dependence of ETA0EDGE" )
`MPRnb( PETA0EDGE         ,0.0                                      ,"m^2"                                   ,"Area dependence of ETA0EDGE" )
`MPRnb( ETABEDGE          ,-0.07                                    ,"1/V"                                   ,"ETAB for edge FET" )
`MPRnb( LETABEDGE         ,0.0                                      ,"m/V"                                   ,"Length dependence of ETABEDGE" )
`MPRnb( WETABEDGE         ,0.0                                      ,"m/V"                                   ,"Width dependence of ETABEDGE" )
`MPRnb( PETABEDGE         ,0.0                                      ,"m^2/V"                                 ,"Area dependence of ETABEDGE" )
`MPRnb( KT1EDGE           ,-0.11                                    ,"V"                                     ,"Temperature dependence parameter of threshold voltage for edge FET" )
`MPRnb( LKT1EDGE          ,0.0                                      ,"V*m"                                   ,"Length dependence of KT1EDGE" )
`MPRnb( WKT1EDGE          ,0.0                                      ,"V*m"                                   ,"Width dependence of KT1EDGE" )
`MPRnb( PKT1EDGE          ,0.0                                      ,"V*m^2"                                 ,"Area dependence of KT1EDGE" )
`MPRnb( KT1LEDGE          ,0.0                                      ,"V*m"                                   ,"Temperature dependence parameter of threshold voltage for edge FET" )
`MPRnb( LKT1LEDGE         ,0.0                                      ,"V*m^2"                                 ,"Length dependence of KT1LEDGE" )
`MPRnb( WKT1LEDGE         ,0.0                                      ,"V*m^2"                                 ,"Width dependence of KT1LEDGE" )
`MPRnb( PKT1LEDGE         ,0.0                                      ,"V*m^3"                                 ,"Area dependence of KT1LEDGE" )
`MPRnb( KT2EDGE           ,0.022                                    ,""                                      ,"Temperature dependence parameter of threshold voltage for edge FET" )
`MPRnb( LKT2EDGE          ,0.0                                      ,"m"                                     ,"Length dependence of KT2EDGE" )
`MPRnb( WKT2EDGE          ,0.0                                      ,"m"                                     ,"Width dependence of KT2EDGE" )
`MPRnb( PKT2EDGE          ,0.0                                      ,"m^2"                                   ,"Area dependence of KT2EDGE" )
`MPRnb( KT1EXPEDGE        ,1.0                                      ,""                                      ,"Temperature dependence parameter of threshold voltage for edge device" )
`MPRnb( LKT1EXPEDGE       ,0.0                                      ,"m"                                     ,"Length dependence of KT1EXPEDGE" )
`MPRnb( WKT1EXPEDGE       ,0.0                                      ,"m"                                     ,"Width dependence of KT1EXPEDGE" )
`MPRnb( PKT1EXPEDGE       ,0.0                                      ,"m^2"                                   ,"Area dependence of KT1EXPEDGE" )
`MPRnb( TNFACTOREDGE      ,0.0                                      ,""                                      ,"Temperature dependence parameter of subthreshold slope factor for edge" )
`MPRnb( LTNFACTOREDGE     ,0.0                                      ,"m"                                     ,"Length dependence of TNFACTOREDGE" )
`MPRnb( WTNFACTOREDGE     ,0.0                                      ,"m"                                     ,"Width dependence of TNFACTOREDGE" )
`MPRnb( PTNFACTOREDGE     ,0.0                                      ,"m^2"                                   ,"Area dependence of TNFACTOREDGE" )
`MPRnb( TETA0EDGE         ,0.0                                      ,""                                      ,"Temperature dependence parameter of DIBL parameter for edge FET" )
`MPRnb( LTETA0EDGE        ,0.0                                      ,"m"                                     ,"Length dependence of TETA0EDGE" )
`MPRnb( WTETA0EDGE        ,0.0                                      ,"m"                                     ,"Width dependence of TETA0EDGE" )
`MPRnb( PTETA0EDGE        ,0.0                                      ,"m^2"                                   ,"Area dependence of TETA0EDGE" )
`MPRnb( DVT0EDGE          ,2.2                                      ,""                                      ,"First coefficient of SCE effect on Vth for Edge FET" )
`MPRnb( DVT1EDGE          ,0.53                                     ,""                                      ,"Second coefficient of SCE effect on Vth for Edge FET" )
`MPRnb( DVT2EDGE          ,0.0                                      ,"1/V"                                   ,"Body-bias coefficient for SCE effect for Edge FET" )
`MPRnb( K2EDGE            ,0.0                                      ,"V"                                     ,"Vth shift due to Vertical Non-uniform doping" )
`MPRnb( LK2EDGE           ,0.0                                      ,"m"                                     ,"Length dependence of K2EDGE" )
`MPRnb( WK2EDGE           ,0.0                                      ,"m"                                     ,"Width dependence of K2EDGE" )
`MPRnb( PK2EDGE           ,0.0                                      ,"m^2"                                   ,"Area dependence of K2EDGE" )
`MPRnb( KVTH0EDGE         ,0.0                                      ,"V*m"                                   ,"Threshold Shift parameter for stress effect" )
`MPRnb( LKVTH0EDGE        ,0.0                                      ,"m^LLODKU0"                             ,"Length dependence of KVTH0EDGE" )
`MPRnb( WKVTH0EDGE        ,0.0                                      ,"m^WLODKU0"                             ,"Width dependence of KVTH0EDGE" )
`MPRnb( PKVTH0EDGE        ,0.0                                      ,"m^(LLODKU0+WLODKU0)"                   ,"Area dependence of KVTH0EDGE" )
`MPRnb( STK2EDGE          ,0.0                                      ,"m"                                     ,"K2 shift factor related to Vth change" )
`MPRnb( LSTK2EDGE         ,0.0                                      ,"m^2"                                   ,"Length dependence of STK2EDGE" )
`MPRnb( WSTK2EDGE         ,0.0                                      ,"m^2"                                   ,"Width dependence of STK2EDGE" )
`MPRnb( PSTK2EDGE         ,0.0                                      ,"m^3"                                   ,"Area dependence of STK2EDGE" )
`MPRnb( STETA0EDGE        ,0.0                                      ,"m"                                     ,"ETA0 shift related to Vth0 change" )
`MPRnb( LSTETA0EDGE       ,0.0                                      ,"m^2"                                   ,"Length dependence of STETA0EDGE" )
`MPRnb( WSTETA0EDGE       ,0.0                                      ,"m^2"                                   ,"Width dependence of STETA0EDGE" )
`MPRnb( PSTETA0EDGE       ,0.0                                      ,"m^3"                                   ,"Area dependence of STETA0EDGE" )
`MPIcc( IGCLAMP           ,1                                        ,""            ,0           ,1           ,"Model flag for Ig clamping" )
`MPRoz( LP                ,1.0e-5                                   ,"m"                                     ,"Length scaling parameter for thermal noise" )
`MPRnb( RNOIK             ,0.0                                      ,""                                      ,"Exponential coefficient for enhanced correlated thermal noise" )
`MPRoo( TNOIK             ,0.0                                      ,"1/m"         ,-inf        ,inf         ,"Empirical parameter for Leff trend of Sid at low Ids" )
`MPRcz( TNOIK2            ,0.1                                      ,"1/m"                                   ,"Empirical parameter for sensitivity of RNOIK" )
`MPRnb( K0                ,0.0                                      ,""                                      ,"Non-saturation effect parameter for strong inversion region" )
`MPRnb( LK0               ,0.0                                      ,"m"                                     ,"Length dependence of K0" )
`MPRnb( WK0               ,0.0                                      ,"m"                                     ,"Width dependence of K0" )
`MPRnb( PK0               ,0.0                                      ,"m^2"                                   ,"Area dependence of K0" )
`MPRnb( K01               ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for K0" )
`MPRnb( LK01              ,0.0                                      ,"m/K"                                   ,"Length dependence of K0" )
`MPRnb( WK01              ,0.0                                      ,"m/K"                                   ,"Width dependence of K0" )
`MPRnb( PK01              ,0.0                                      ,"m^2/K"                                 ,"Area dependence of K0" )
`MPRnb( M0                ,1.0                                      ,""                                      ,"offset of non-saturation effect parameter for strong inversion region" )
`MPRnb( LM0               ,0.0                                      ,"m"                                     ,"Length dependence of M0" )
`MPRnb( WM0               ,0.0                                      ,"m"                                     ,"Width dependence of M0" )
`MPRnb( PM0               ,0.0                                      ,"m^2"                                   ,"Area dependence of M0" )
`MPRnb( M01               ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for M0" )
`MPRnb( LM01              ,0.0                                      ,"m/K"                                   ,"Length dependence of M01" )
`MPRnb( WM01              ,0.0                                      ,"m/K"                                   ,"Width dependence of M01" )
`MPRnb( PM01              ,0.0                                      ,"m^2/K"                                 ,"Area dependence of M01" )

// Flicker noise model parameter for EDGE FET transistor
`MPRoz( NEDGE              ,1                                        ,""                                      ,"Flicker noise parameter for edge fet transitor" )
`MPRcz( NOIA1_EDGE         ,0.0                                      ,""                                      ,"Flicker noise fitting parameter in strong inversionfor edge fet transitor" )
`MPRoz( NOIAX_EDGE         ,1.0                                      ,""                                      ,"Flicker noise fitting parameter in strong inversionfor edge fet transitor" )


// Flicker noise model parameter for Halo transistor
`MPIcc( FNOIMOD           ,0                                        ,""            ,0           ,1           ,"Flicker noise model selector" )
`MPRoo( LH                ,1.0e-8                                   ,"m"           ,0.0         ,L           ,"Length of halo transistor" )
`MPRnb( NOIA2             ,NOIA                                     ,"s^(1-EF)/(eV)^1/m^3"                   ,"Flicker noise parameter A for Halo" )
`MPRoz( HNDEP             ,NDEP                                     ,"1/m^3"                                 ,"Halo doping concentration for I-V" )

// Flexibility of tuning Cgg in strong inversion
`MPRco( ABULK             ,1.0                                      ,""            ,1          ,2.0          ,"For flexibility of tuning Cgg in strong inversion" )

// To enhance the fitting flexiblity for the gm/Id
`MPRnb( C0             ,0.0            ,"V"            ,"Lateral NUD1 voltage parameter" )
`MPRnb( LC0            ,0.0            ,"V*m"          ,"Length dependence of C0" )
`MPRnb( WC0            ,0.0            ,"V*m"          ,"Width dependence of C0" )
`MPRnb( PC0            ,0.0            ,"V*m^2"        ,"Area dependence of C0" )
`MPRnb( C01            ,0.0            ,"1/K"          ,"Temperature dependence of lateral NUD1 voltage parameter" )
`MPRnb( LC01           ,0.0            ,"m/K"          ,"Length dependence of C01" )
`MPRnb( WC01           ,0.0            ,"m/K"          ,"Width dependence of C01" )
`MPRnb( PC01           ,0.0            ,"m^2/K"        ,"Area dependence of C01" )
`MPRnb( C0SI           ,1.0            ,"V"            ,"Correction factor for strong inversion used in Mnud1. After binning it should be within (0 : inf)" )
`MPRnb( LC0SI          ,0.0            ,"V*m"          ,"Length dependence of C0SI" )
`MPRnb( WC0SI          ,0.0            ,"V*m"          ,"Width dependence of C0SI" )
`MPRnb( PC0SI          ,0.0            ,"V*m^2"        ,"Area dependence of C0SI" )
`MPRnb( C0SI1          ,0.0            ,"1/K"          ,"Temperature dependence of C0SI1" )
`MPRnb( LC0SI1         ,0.0            ,"m/K"          ,"Length dependence of C0SI1" )
`MPRnb( WC0SI1         ,0.0            ,"m/K"          ,"Width dependence of C0SI1" )
`MPRnb( PC0SI1         ,0.0            ,"m^2/K"        ,"Area dependence of C0SI1" )
`MPRnb( C0SISAT        ,0.0            ,"V"            ,"Correction factor for strong inversion used in Mnud1" )
`MPRnb( LC0SISAT       ,0.0            ,"V*m"          ,"Length dependence of C0SISAT" )
`MPRnb( WC0SISAT       ,0.0            ,"V*m"          ,"Width dependence of C0SISAT" )
`MPRnb( PC0SISAT       ,0.0            ,"V*m^2"        ,"Area dependence of C0SISAT" )
`MPRnb( C0SISAT1       ,0.0            ,"1/K"          ,"Temperature dependence of C0SISAT1" )
`MPRnb( LC0SISAT1      ,0.0            ,"m/K"          ,"Length dependence of C0SISAT1" )
`MPRnb( WC0SISAT1      ,0.0            ,"m/K"          ,"Width dependence of C0SISAT1" )
`MPRnb( PC0SISAT1      ,0.0            ,"m^2/K"        ,"Area dependence of C0SISAT1" )

// Minimum resistance value
`MPRoz( minr          ,$simparam("minr", 1m) ,"Ohm"    ,"minr is the value below which the simulator expects elimination of source/drain resitance and it will improve simulation efficiency without significantly altering the results.")
// High Voltage Model Parameters

// --- Mod selectors -----
`MPIcc( HVMOD          ,0               ,""             ,0           ,1          ,"High Voltage series resistance model, 0: Turn Off 1: Turn On") 
`MPIcc( HVCAP          ,0               ,""             ,0           ,1          ,"High Voltage capacitance model. 0: Turn Off 1: Turn On") 
`MPIcc( HVCAPS         ,0               ,""             ,0           ,1          ,"High Voltage capacitance model at source side. 0: Turn Off 1: Turn On") 
`MPIcc( IIMOD          ,0               ,""            ,0           ,1           ,"Flag for impact ionization in the drift region 0: Turn-Off,  1: Turn On" )

// --- Other parameters -----
`MPRoz( NDRIFTD        ,5.0e16          ,"per m^2"                               ,"Charge density in the drift region" )
`MPRoc( VDRIFT         ,1.0e5           ,"m/sec"        ,0           ,inf        ,"Saturation velocity in the drift region" )
`MPRoc( MDRIFT         ,1.0             ,""             ,0           ,inf        ,"Non-linear resistance parameter" )
`MPRoz( NDRIFTS        ,NDRIFTD         ,"per m^2"                               ,"Charge density in the source side drift region" )
`MPRcc( RDLCW          ,100.0           ,"Ohm*m^WR"     ,0           ,inf        ,"'R'esistance of the 'D'rain side drift region at 'L'ow 'C'urrent" )
`MPRcc( RSLCW          ,0               ,"Ohm*m^WR"     ,0           ,inf        ,"'R'esistance of the 'S'ource side drift region at 'L'ow 'C'urrent" )
`MPRnb( PDRWB          ,0               ,""                                      ,"Body bias dependence of the drift region resistance" )
`MPRnb( VFBDRIFT       ,-1              ,"V"                                     ,"Flat-band voltage of the drift region" )
`MPRnb( VFBOV          ,-1              ,"V"                                     ,"Flat-band voltage of the overlap region" )
`MPRnb( LOVER          ,500n            ,"m"                                     ,"Overlap region length" )
`MPRnb( LOVERACC       ,LOVER           ,"m"                                     ,"Drift region length" )
`MPRnb( NDR            ,NDEP            ,"m^3"                                   ,"Drift region doping" )
`MPRcz( SLHV           ,0               ,""                                      ,"Parameter and Flag for controlling slope of accumulation region capacitance. 0: Turn-Off,  1: Turn On" )
`MPRoz( SLHV1          ,1.0             ,""                                      ,"Parameter for slope of the accumulation capacitance " )
`MPRnb( ALPHADR        ,ALPHA0          ,""                                      ,"First parameter of Iii in the drift region" )
`MPRnb( BETADR         ,BETA0           ,""                                      ,"Second parameter of Iii in the drift region" )
`MPRnb( PRTHV          ,0.0             ,""                                      ,"Temperature coefficient for drift resistance" )
`MPRnb( ATHV           ,0               ,"m/s"                                   ,"Temperature coefficient for drift region saturation velocity" )
`MPRcc( HVFACTOR       ,1e-3            ,""            ,1e-4         ,1          ,"" )
`MPRcz( DRII1          ,1.0             ,""                                      ,"Parameter for carrier concentration for Impact Ionization in the the drift" )
`MPRcz( DRII2          ,5               ,"V"                                     ,"Saturation voltage ~ Esat * L" )
`MPRcz( DELTAII        ,0.5             ,"V"                                     ,"Smoothing parameter" )


// Common variables
real PSiso, PDiso, PSsha, PDsha, PSmer, PDmer, ASiso, ADiso, ASsha, ADsha, ASmer, ADmer;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
real Tb;
real epssi, epsox, ni, Weff, Leff, Weff1, Leff1, Wact, Lact, Weffcj, Eg, Eg0, Weff_SH;
real dLIV, dWIV, dLB, dWB, dLCV, dWCV, dWJ, Cox, epsratio;
real Vdb_noswap, Vsb_noswap, Vgs_noswap, Vgd_noswap, Vds_noswap;
real sigvds, vfb, vgfb, vgfbCV, Vbsx, Vfbsdr;
real Vg, vg, Vd, Vs, vs, Vds, Vdsx, Vgs_eff, Vgd_eff;
real Vth_shift;
real qia, qba, qiaCV, qbaCV, qbs, qbd, qb, dps, phib, phib_n;
real nq, psip, psiavg, psipclamp, sqrtpsisa, sqrtpsisainv, sqrtpsip;
real Cdep, Lnew, L_mult, Wnew, W_mult;
real wf, wr;

// Short channel effects
real n, Fp, nVt, inv_nVt, Vt, inv_Vt;
real PhistVbs, sqrtPhistVbs, Xdep, cdsc;
real T1DEP;
real dVth_ldop, DVTP0_i, DVTP1_i, DVTP2_i, DVTP3_i, DVTP4_i, DVTP5_i;
real dVth_VNUD, dVth_dibl, dvth_temp;
real gam, inv_gam, Phist, sqrtPhist, litl;

// Drain saturation voltage
real qis, qdsat, Eeffs, Dmobs, Esat, EsatL, Vdsat, LambdaC_by2, LambdaC;
real Vdseff, Vdssat, VdssatCV, vdeff, vdsat, qdeff, vdsatcv, VdsatCV;
real ln_T1_T2;
real A1_i, A11_i, A1_t, A2_i, A21_i, A2_t, Nsat;

// Mobility degradation
real EeffFactor, Eeffm, ueff, eta_mu, Dmob, Dtot;

// Velocity saturation
real zsat, Dvsat, Dptwg, PSAT_i, PSATR_i, PSAT_a;

// Output conductance
real diffVds, VaDITS, VaSCBE, Vasat;
real DIBLfactor, PVAGfactor, VaDIBL, Vgst2Vtm, Moc, MdL, Mscbe;

// Impact ionization and GIDL
real Iii, igidl, igisl;

// I-V variables
integer devsign;
real ids;

// C-V variables
real Qb, Qs, Qd1, Qd2, Qd, Qi, QBi, QSi, QDi, QGi, WLCOXVtinv;
real qs, qbeff, dqgeff;
real DPD, vgfbPD, gammaPD, gamg2;
real MdL_2, inv_MdL, inv_MdL_2, MdL_less_1;
real sis, sid, vgpqm, Temps, Tempd, DQSD, DQSD2, invgamg2;
real Vgsov, Vgdov, Qovb, Qovg, Qovs, Qovd, Cgsof, Cgdof;
real XDCinv, Coxeffinv, BSIMBULKTOXP;
real Vgd_ov_noswap, Vgs_ov_noswap;
real phibCV, gamCV;

// S/D series resistances
real WeffWRFactor, DMCGeff, DMDGeff, DMCIeff;
real RSourceGeo, RDrainGeo, Rsource, Rdrain, Rdss, Rdsi, Dr;

// S/D junction area and perimeters
real temp_ASeff, temp_ADeff, temp_PSeff, temp_PDeff;
real ASeff, ADeff;

// Gate resistances
real Grgeltd, Gcrg, idsovvds;

// Body resistance
real Lnl, Lnw, Lnnf, Bodymode, Rbpbx, Rbpby, Rbsbx, Rbsby, Rbdbx, Rbdby;
real Rbdb, Rbsb, Rbpb, Rbps, Rbpd;
real Grbsb, Grbdb, Grbpb, Grbps, Grbpd;

// Gate currents
real Voxm, Voxminv, Voxmacc, Vdseffx;
real Vaux_Igbinv, Vaux_Igbacc, igbinv, igbacc, igb;
real igcs, igcd, igc0, T1_exp;
real igs, igd, igs_mult, igd_mult;
real Aechvb, Bechvb, AechvbEdge, BechvbEdge, ToxRatio, ToxRatioEdge;

// Junction currents and capacitances
real PSeff, PDeff;
real Ibs, Ibd, Vbs_jct, Vbd_jct, arg, sarg;
real Czbs, czbs_p1, czbs_p2, Czbssw, czbssw_p1, czbssw_p2, Czbsswg, czbsswg_p1, czbsswg_p2;
real Czbd, czbd_p1, czbd_p2, Czbdsw, czbdsw_p1, czbdsw_p2, Czbdswg, czbdswg_p1, czbdswg_p2;
real Qbsj, Qbsj1, Qbsj2, Qbsj3;
real Qbdj, Qbdj1, Qbdj2, Qbdj3;
real Isbs, Isbd, Nvtms, Nvtmd;
real SslpRev, IVjsmRev, VjsmRev, SslpFwd, IVjsmFwd, VjsmFwd, XExpBVS;
real DslpRev, IVjdmRev, VjdmRev, DslpFwd, IVjdmFwd, VjdmFwd, XExpBVD;

// Flicker noise
real LINTNOI_i;
real Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal noise
real gspr, gdpr;
real Gtnoi, sidn, Nt;
real mig, migid, mid, Lvsat, Vtn;
real cm_igid, sqid, sqig, ctnoi, betanoisq, thetanoisq, betaLowId;

// Temperature effects
real delTemp1;
real DevTemp, Tnom, Vtm, Vtm0;
real TRatio, delTemp;
real U0_t, U0R_t, UA_t, UAR_t, UC_t, UCR_t, UD_t, UDR_t, UCS_t, UCSR_t, EU_t, rdstemp, VSAT_t, VSATR_t, VSATCV_t;
real DELTA_t, PTWG_t, PTWGR_t, BETA0_t, BGIDL_t, BGISL_t;
real igtemp;
real ETA0_t, ETA0R_t, NFACTOR_t;

//Diode temperature effects
real CJS_t, CJSWS_t, CJSWGD_t, CJD_t, CJSWD_t, CJSWGS_t;
real PBS_t, PBSWS_t, PBSWGS_t, PBD_t, PBSWD_t, PBSWGD_t;
real JSS_t, JSWS_t, JSWGS_t, JSD_t, JSWD_t, JSWGD_t;
real JTSS_t, JTSD_t, JTSSWS_t, JTSSWD_t, JTSSWGS_t, JTSSWGD_t;
real NJTS_t, NJTSD_t, NJTSSW_t, NJTSSWD_t, NJTSSWG_t, NJTSSWGD_t;

// Binning
real PSATB_i;
real KT1_i, KT2_i;
real W_by_NF;
real L_LLN, W_LWN, LW_LLN_LWN, L_LLN1, W_LWN1, LW_LLN_LWN1;
real L_WLN, W_WWN, LW_WLN_WWN, L_WLN1, W_WWN1, LW_WLN_WWN1;
real Inv_L, Inv_W, Inv_WL, Inv_Lact, Inv_Wact, Inv_Llong, Inv_Wwide;
real BIN_L, BIN_W, BIN_WL;
real NGATE_i, NSD_i, NDEP_i, VFB_i;
real CIT_i, CDSCD_i, CDSCDR_i, CDSCD_a, CDSCB_i, NFACTOR_i;
real PHIN_i, ETA0_i, ETA0R_i, ETA0_a, ETAB_i, K2_i, K1_i;
real DELTA_i;
real U0_i, U0R_i, U0_a, VSAT_i, VSATR_i, VSAT_a, VSATCV_i, UA_i, UAR_i, UA_a, EU_i, UD_i, UDR_i, UD_a, UCS_i, UCSR_i, UCS_a, UC_i, UCR_i, UC_a;
real PDIBLC_i, PDIBLCR_i, PDIBLC_a, PDIBLCB_i, PSCBE1_i, PSCBE2_i, PDITS_i, PDITSD_i, FPROUT_i;
real PRWG_i, WR_i, RDWMIN_i, RSWMIN_i, RDW_i, RSW_i, RDSW_i, RDSWMIN_i;
real PTWG_i, PTWGR_i, PTWG_a, PVAG_i, XJ_i;
real PCLM_i, PCLMR_i, PCLM_a, PCLMCV_i, PRWB_i;
real CF_i, CGSL_i, CGDL_i, CKAPPAS_i, CKAPPAD_i;
real VFBCV_i, NDEPCV_i;
real ALPHA0_i, BETA0_i;
real AGIDL_i, BGIDL_i, CGIDL_i, EGIDL_i;
real AGISL_i, BGISL_i, CGISL_i, EGISL_i;
real UTE_i, UA1_i, UC1_i, UD1_i, UCSTE_i, PRT_i, AT_i, PTWGT_i, IIT_i, TGIDL_i, EU1_i;
real KVTH0WE_i, K2WE_i, KU0WE_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real AIGC_i, BIGC_i, CIGC_i;
real AIGS_i, BIGS_i, CIGS_i, AIGD_i, BIGD_i, CIGD_i, POXEDGE_i, PIGCD_i;
real DLCIG_i, DLCIGD_i, NTOX_i;
real IGT_i;
real K0_i, M0_i;
real K01_i, M01_i;
real K0_t, M0_t;
real Mnud;
real NFACTOREDGE_i, CITEDGE_i, CDSCDEDGE_i, CDSCBEDGE_i, ETA0EDGE_i, ETABEDGE_i, KT1EDGE_i, KT1LEDGE_i, KT2EDGE_i, KT1EXPEDGE_i, TNFACTOREDGE_i, TETA0EDGE_i, K2EDGE_i, KVTH0EDGE_i, STK2EDGE_i, STETA0EDGE_i;
real Mnud1;
real C0_i, C01_i, C0_t;
real C0SI_i, C0SI1_i, C0SI_t;
real C0SISAT_i, C0SISAT1_i, C0SISAT_t;

// Stress effects
real W_tmp_stress, tmp1_stress, kstress_u0, tmp1_stress_vth, kstress_vth0, ku0_temp;
real Inv_sa, Inv_sb, Inv_saref, Inv_sbref, Inv_odref, rho_ref, Inv_od,rho;
real mu0_mult, vsat_mult, vth0_stress, k2_stress, eta_stress;
integer i;

// Well proximity effects
real vth0_well, k2_well, mu_well, Wdrn, local_sca, local_scb, local_scc;

// Edge FET Model Variables
real ids_edge, ETA0EDGE_t, NFACTOREDGE_t, Vbi_edge, theta_sce_edge, dvth_dibl, dvth_sce, litl_edge, DGAMMAEDGE_i, vdsatedge, Vdsatedge, Vdssate, phib_edge, phib_n_edge, NDEPEDGE_i, gam_edge;
real vth0_stress_EDGE, k2_stress_EDGE, eta_stress_EDGE;

// 1/f noise model for Edge FET 
real nq_edge, qdeff_edge, qs_edge, Leffnoi_edge, Leffnoisq_edge, noia_edge, noib_edge, noic_edge, FNPowerAtedge;

// Below are used by macros by GEOMOD and RGEOMOD
real nuIntD, nuEndD, nuIntS, nuEndS;
real Rint, Rend;

// Sub-surface punchthrough
real Issl, SSL0_NT, SSL1_NT, PHIB_SSL;

// VTH variables
real q_vth, psip_th;

// 1/f noise model for halo
real vgfbh, gam_h, phib_h, psiph, qsh, nq_h, U0_i_h, i1, qdh, i2, qsch;
real Np2, beta_ch, beta_h, gds_h, gds_ch, gm_ch, R_ch, R_h, Ssi_ch;
real Swi_ch, FNPowerAt1Hz_ch, FNPowerAt1Hz_h;
real T0a, T0b, T0c, T0d, T0e, Swi_h, t_tot, CF_ch, CF_h, LeffnoiH, LH1;

// Self heating
real gth, cth, Pdiss;

// High Voltage Model variables
real idrift_sat_d, idrift_sat_s, delta_hv, T0D, T1D, T2D, rdrift_d, T0S, T1S, T2S, rdrift_s, rdstemphv, VDRIFT_t;
real vgfbdrift, gamhv, phibHV, psip_k, q_k, psipclamp_hv, sqrtpsip_k, psiavg_hv, nq_hv, psi_k, QIOV, QBOV, QIOVS, QBOVS;
real Ntot, Nextra, IsubDR;

// gmin is placed in parallel with drain-bulk and source-bulk diode to increase the numerical convergence
real gmin;

// Operating-point variables
`OPM( QBI,          "C",     "Intrinsic body charge" )
`OPM( QSI,          "C",     "Intrinsic source charge" )
`OPM( QDI,          "C",     "Intrinsic drain charge" )
`OPM( QGI,          "C",     "Intrinsic gate charge" )
`OPM( CGGI,         "F",     "Intrinsic gate capacitance" )
`OPM( CGBI,         "F",     "Intrinsic gate-to-body capacitance" )
`OPM( CGSI,         "F",     "Intrinsic gate-to-source capacitance" )
`OPM( CGDI,         "F",     "Intrinsic gate-to-drain capacitance" )
`OPM( CSGI,         "F",     "Intrinsic source-to-gate capacitance" )
`OPM( CSBI,         "F",     "Intrinsic source-to-body capacitance" )
`OPM( CSSI,         "F",     "Intrinsic source capacitance" )
`OPM( CSDI,         "F",     "Intrinsic source-to-drain capacitance" )
`OPM( CDGI,         "F",     "Intrinsic drain-to-gate capacitance" )
`OPM( CDBI,         "F",     "Intrinsic drain-to-body capacitance" )
`OPM( CDSI,         "F",     "Intrinsic drain-to-source capacitance" )
`OPM( CDDI,         "F",     "Intrinsic drain capacitance" )
`OPM( CBGI,         "F",     "Intrinsic body-to-gate capacitance" )
`OPM( CBBI,         "F",     "Intrinsic body capacitance" )
`OPM( CBSI,         "F",     "Intrinsic body-to-source capacitance" )
`OPM( CBDI,         "F",     "Intrinsic body-to-drain capacitance" )
`OPM( QB,           "C",     "Body charge" )
`OPM( QS,           "C",     "Source charge" )
`OPM( QD,           "C",     "Drain charge" )
`OPM( QG,           "C",     "Gate charge" )
`OPM( CGG,          "F",     "Total gate capacitance" )
`OPM( CGB,          "F",     "Total gate-to-body capacitance" )
`OPM( CGS,          "F",     "Total gate-to-source capacitance" )
`OPM( CGD,          "F",     "Total gate-to-drain capacitance" )
`OPM( CSG,          "F",     "Total source-to-gate capacitance" )
`OPM( CSB,          "F",     "Total source-to-body capacitance" )
`OPM( CSS,          "F",     "Total source capacitance" )
`OPM( CSD,          "F",     "Total source-to-drain capacitance" )
`OPM( CDG,          "F",     "Total drain-to-gate capacitance" )
`OPM( CDB,          "F",     "Total drain-to-body capacitance" )
`OPM( CDS,          "F",     "Total drain-to-source capacitance" )
`OPM( CDD,          "F",     "Total drain capacitance" )
`OPM( CBG,          "F",     "Total body-to-gate capacitance" )
`OPM( CBB,          "F",     "Total body capacitance" )
`OPM( CBS,          "F",     "Total body-to-source capacitance" )
`OPM( CBD,          "F",     "Total body-to-drain capacitance" )
`OPM( ISUB,         "A",     "Substrate current" )
`OPM( IGIDL,        "A",     "" )
`OPM( IGISL,        "A",     "" )
`OPM( IGS,          "A",     "" )
`OPM( IGD,          "A",     "" )
`OPM( IGCS,         "A",     "" )
`OPM( IGCD,         "A",     "" )
`OPM( IGB,          "A",     "" )
`OPM( CGSEXT,       "F",     "" )
`OPM( CGDEXT,       "F",     "" )
`OPM( CGBOV,        "F",     "Front gate charge" )
`OPM( CAPBS,        "F",     "" )
`OPM( CAPBD,        "F",     "" )
`OPP( WEFF,         "m",     "" )
`OPP( LEFF,         "m",     "" )
`OPP( WEFFCV,       "m",     "" )
`OPP( LEFFCV,       "m",     "" )
`OPM( IDS,          "A",     "Drain-source current" )
`OPM( IDEFF,        "A",     "Effective drain current" )
`OPM( ISEFF,        "A",     "Effective source current" )
`OPM( IGEFF,        "A",     "Effective gate current" )
`OPM( IBS,          "A",     "" )
`OPM( IBD,          "A",     "" )
`OPP( VDS,          "V",     "Drain-to-source voltage" )
`OPP( VGS,          "V",     "Gate-to-source voltage" )
`OPP( VBS,          "V",     "Body-to-source voltage" )
`OPP( VDSAT,        "V",     "" )
`OPM( GM,           "mho",   "" )
`OPM( GMBS,         "mho",   "" )
`OPM( GDS,          "mho",   "" )
`OPP( T_TOTAL_K,    "K",     "" )
`OPP( T_TOTAL_C,    "deg-C", "" )
`OPP( T_DELTA_SH,   "K",     "" )
`OPP( VTH,          "V",     "Threshold voltage" )
`OPM( IDRIFTSATD,   "A",     "" )

analog begin
    // Variable initialization to prevent hidden states
    CDSCDR_i   = 0.0; ETA0R_i      = 0.0; ETA0R_t          = 0.0; L_LLN1          = 0.0;
    L_WLN1     = 0.0; PCLMR_i      = 0.0; PDIBLCR_i        = 0.0; PSATR_i         = 0.0;
    PTWGR_i    = 0.0; PTWGR_t      = 0.0; U0R_i            = 0.0; U0R_t           = 0.0;
    UAR_i      = 0.0; UAR_t        = 0.0; UCR_i            = 0.0; UCR_t           = 0.0;
    UCSR_i     = 0.0; UCSR_t       = 0.0; UDR_i            = 0.0; UDR_t           = 0.0;
    UD_a       = 0.0; VSATR_i      = 0.0; VSATR_t          = 0.0; W_LWN1          = 0.0;
    W_WWN1     = 0.0; local_sca    = 0.0; local_scb        = 0.0; local_scc       = 0.0;
    Inv_sa     = 0.0; Inv_sb       = 0.0; vth0_stress_EDGE = 0.0; k2_stress_EDGE  = 0.0;
    eta_stress = 0.0; FNPowerAtedge= 0.0; eta_stress_EDGE  = 0.0;
    local_sca  = 0.0; local_scb    = 0.0; local_scc        = 0.0; K0_i            = 0.0;
    M0_i       = 0.0; K01_i        = 0.0; M01_i            = 0.0; K0_t            = 0.0;
    M0_t       = 0.0; CITEDGE_i    = 0.0; CDSCDEDGE_i      = 0.0; CDSCBEDGE_i     = 0.0;
    ETA0EDGE_i = 0.0; ETABEDGE_i   = 0.0; KT1EDGE_i        = 0.0; KT1LEDGE_i      = 0.0;
    KT2EDGE_i  = 0.0; KT1EXPEDGE_i = 0.0; TNFACTOREDGE_i   = 0.0; TETA0EDGE_i     = 0.0;
    K2EDGE_i   = 0.0; KVTH0EDGE_i  = 0.0; STK2EDGE_i       = 0.0; STETA0EDGE_i    = 0.0;
    Mnud1      = 0.0; C0_i         = 0.0; C01_i            = 0.0; C0_t            = 0.0;
    C0SI_i     = 0.0; C0SI1_i      = 0.0; C0SI_t           = 0.0; C0SISAT_i       = 0.0;
    C0SISAT1_i = 0.0; C0SISAT_t    = 0.0; rdrift_d         = 0.0; rdrift_s        = 0.0;
    IsubDR     = 0.0; rdstemphv    = 1.0; VDRIFT_t         = 1.0;
    gmin       = $simparam("gmin",0);

    // Bias-independent calculations
    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    // Constants
    epssi    = EPSRSUB * `EPS0;
    epsox    = EPSROX * `EPS0;
    Cox      = EPSROX * `EPS0 / TOXE;
    epsratio = EPSRSUB / EPSROX;

    // Physical oxide thickness
    if (!$param_given(TOXP)) begin
        BSIMBULKTOXP = (TOXE * EPSROX / 3.9) - DTOX;
    end else begin
        BSIMBULKTOXP = TOXP;
    end
    L_mult = L * LMLT;
    W_mult = W * WMLT;
    Lnew = L_mult + XL;
    if (Lnew <= 0.0) begin
        $strobe("Fatal: Ldrawn * LMLT + XL = %e for %M is non-positive", Lnew);
        $finish(0);
    end
    W_by_NF = W_mult / NF;
    Wnew    = W_by_NF + XW;
    if (Wnew <= 0.0) begin
        $strobe("Fatal: W / NF * WMLT + XW = %e for %M is non-positive", Wnew);
        $finish(0);
    end

    // Leff and Weff for I-V
    L_LLN      = pow(Lnew, -LLN);
    W_LWN      = pow(Wnew, -LWN);
    LW_LLN_LWN = L_LLN * W_LWN;
    dLIV       = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;
    L_WLN      = pow(Lnew, -WLN);
    W_WWN      = pow(Wnew, -WWN);
    LW_WLN_WWN = L_WLN * W_WWN;
    dWIV       = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;
    Leff       = Lnew - 2.0 * dLIV;
    if (Leff <= 0.0) begin
        $strobe("Fatal: Effective channel length = %e for  %M is non-positive", Leff);
        $finish(0);
    end else if (Leff <= 1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end
    Weff = Wnew - 2.0 * dWIV;
    if (Weff <= 0.0) begin
         $strobe("Fatal: Effective channel Width = %e for %M is non-positive", Weff);
        $finish(0);
    end else if (Weff <= 1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", Weff);
    end

    // Leff and Weff for C-V
    dLCV = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    Lact = Lnew - 2.0 * dLCV;
    if (Lact <= 0.0) begin
         $strobe("Fatal: Effective channel length for C-V = %e for %M is non-positive", Lact);
        $finish(0);
    end else if (Lact <= 1.0e-9) begin
        $strobe("Warning: Effective channel length for C-V = %e for %M is <= 1.0e-9. Recommended Lact >= 1e-8", Lact);
    end
    Wact = Wnew - 2.0 * dWCV;
    if (Wact <= 0.0) begin
        $strobe("Fatal: Effective channel width for C-V = %e for %M is non-positive", Wact);
        $finish(0);
    end else if (Wact <= 1.0e-9) begin
        $strobe("Warning: Effective channel width for C-V = %e for %M is <= 1.0e-9. Recommended Wact >= 1e-8", Wact);
    end

    // Weffcj for diode, GIDL etc.
    dWJ    = DWJ + WLC / pow(Lnew, WLN) + WWC / pow(Wnew, WWN) + WWLC / pow(Lnew, WLN) / pow(Wnew, WWN);
    Weffcj = Wnew - 2.0 * dWJ;
    if (Weffcj <= 0.0) begin
        $strobe("Fatal: Effective channel width for S/D junctions = %e for %M is non-positive", Weffcj);
        $finish(0);
     end
    Inv_L     = 1.0e-6 / Leff;
    Inv_W     = 1.0e-6 / Weff;
    Inv_Lact  = 1.0e-6 / Lact;
    Inv_Wact  = 1.0e-6 / Wact;
    Inv_Llong = 1.0e-6 / LLONG;
    Inv_Wwide = 1.0e-6 / WWIDE;
    Inv_WL    = Inv_L * Inv_W;

    // Effective length and width for binning
    L_LLN1 = L_LLN;
    L_WLN1 = L_WLN;
    if (DLBIN != 0.0) begin
        if (DLBIN <= -Lnew) begin
            $strobe("Fatal: DLBIN for %M = %e is <= -Ldrawn * LMLT", DLBIN);
            $finish(0);
        end else begin
            L_LLN1 = pow(Lnew + DLBIN, -LLN);
            L_WLN1 = pow(Lnew + DLBIN, -WLN);
        end
    end
    W_LWN1 = W_LWN;
    W_WWN1 = W_WWN;
    if (DWBIN != 0.0) begin
        if (DWBIN <= -Wnew) begin
            $strobe("Fatal: DWBIN for %M = %e is <= -Wdrawn * WMLT", DWBIN);
            $finish(0);
        end else begin
            W_LWN1 = pow(Wnew + DWBIN, -LWN);
            W_WWN1 = pow(Wnew + DWBIN, -WWN);
        end
    end
    LW_LLN_LWN1 = L_LLN1 * W_LWN1;
    dLB         = LINT + LL * L_LLN1 + LW * W_LWN1 + LWL * LW_LLN_LWN1;
    LW_WLN_WWN1 = L_WLN1 * W_WWN1;
    dWB         = WINT + WL * L_WLN1 + WW * W_WWN1 + WWL * LW_WLN_WWN1;
    Leff1 = Lnew - 2.0 * dLB + DLBIN;
    if (Leff1 <= 0.0) begin
        $strobe("Fatal: Effective channel length for binning = %e for %M is non-positive", Leff1);
        $finish(0);
    end
    Weff1 = Wnew - 2.0 * dWB + DWBIN;
    if (Weff1 <= 0.0) begin
        $strobe("Fatal: Effective channel width for binning = %e for %M is non-positive", Weff1);
        $finish(0);
    end
    if (BINUNIT == 1) begin
        BIN_L = 1.0e-6 / Leff1;
        BIN_W = 1.0e-6 / Weff1;
    end else begin
        BIN_L = 1.0 / Leff1;
        BIN_W = 1.0 / Weff1;
    end
    BIN_WL         = BIN_L * BIN_W;
    VFB_i          = VFB + BIN_L * LVFB + BIN_W * WVFB + BIN_WL * PVFB;
    VFBCV_i        = VFBCV + BIN_L * LVFBCV + BIN_W * WVFBCV + BIN_WL * PVFBCV;
    NSD_i          = NSD + BIN_L * LNSD + BIN_W * WNSD + BIN_WL * PNSD;
    NDEP_i         = NDEP + BIN_L * LNDEP + BIN_W * WNDEP + BIN_WL * PNDEP;
    NDEPCV_i       = NDEPCV + BIN_L * LNDEPCV + BIN_W * WNDEPCV + BIN_WL * PNDEPCV;
    NGATE_i        = NGATE + BIN_L * LNGATE + BIN_W * WNGATE + BIN_WL * PNGATE;
    CIT_i          = CIT + BIN_L * LCIT + BIN_W * WCIT + BIN_WL * PCIT;
    NFACTOR_i      = NFACTOR + BIN_L * LNFACTOR + BIN_W * WNFACTOR + BIN_WL * PNFACTOR;
    CDSCD_i        = CDSCD + BIN_L * LCDSCD + BIN_W * WCDSCD + BIN_WL * PCDSCD;
    CDSCB_i        = CDSCB + BIN_L * LCDSCB + BIN_W * WCDSCB + BIN_WL * PCDSCB;
    DVTP0_i        = DVTP0 + BIN_L * LDVTP0 + BIN_W * WDVTP0 + BIN_WL * PDVTP0;
    DVTP1_i        = DVTP1 + BIN_L * LDVTP1 + BIN_W * WDVTP1 + BIN_WL * PDVTP1;
    DVTP2_i        = DVTP2 + BIN_L * LDVTP2 + BIN_W * WDVTP2 + BIN_WL * PDVTP2;
    DVTP3_i        = DVTP3 + BIN_L * LDVTP3 + BIN_W * WDVTP3 + BIN_WL * PDVTP3;
    DVTP4_i        = DVTP4 + BIN_L * LDVTP4 + BIN_W * WDVTP4 + BIN_WL * PDVTP4;
    DVTP5_i        = DVTP5 + BIN_L * LDVTP5 + BIN_W * WDVTP5 + BIN_WL * PDVTP5;
    K2_i           = K2 + BIN_L * LK2 + BIN_W * WK2 + BIN_WL * PK2;
    K1_i           = K1 + BIN_L * LK1 + BIN_W * WK1 + BIN_WL * PK1;
    XJ_i           = XJ + BIN_L * LXJ + BIN_W * WXJ + BIN_WL * PXJ;
    PHIN_i         = PHIN + BIN_L * LPHIN + BIN_W * WPHIN + BIN_WL * PPHIN;
    ETA0_i         = ETA0 + BIN_L * LETA0 + BIN_W * WETA0 + BIN_WL * PETA0;
    ETAB_i         = ETAB + BIN_L * LETAB + BIN_W * WETAB + BIN_WL * PETAB;
    DELTA_i        = DELTA + BIN_L * LDELTA + BIN_W * WDELTA + BIN_WL * PDELTA;
    U0_i           = U0 + BIN_L * LU0 + BIN_W * WU0 + BIN_WL * PU0;
    UA_i           = UA + BIN_L * LUA + BIN_W * WUA + BIN_WL * PUA;
    UD_i           = UD + BIN_L * LUD + BIN_W * WUD + BIN_WL * PUD;
    EU_i           = EU + BIN_L * LEU + BIN_W * WEU + BIN_WL * PEU;
    UCS_i          = UCS + BIN_L * LUCS + BIN_W * WUCS + BIN_WL * PUCS;
    UC_i           = UC + BIN_L * LUC + BIN_W * WUC + BIN_WL * PUC;
    PCLM_i         = PCLM + BIN_L * LPCLM + BIN_W * WPCLM + BIN_WL * PPCLM;
    PCLMCV_i       = PCLMCV + BIN_L * LPCLMCV + BIN_W * WPCLMCV + BIN_WL * PPCLMCV;
    RSW_i          = RSW + BIN_L * LRSW + BIN_W * WRSW + BIN_WL * PRSW;
    RDW_i          = RDW + BIN_L * LRDW + BIN_W * WRDW + BIN_WL * PRDW;
    PRWG_i         = PRWG + BIN_L * LPRWG + BIN_W * WPRWG + BIN_WL * PPRWG;
    PRWB_i         = PRWB + BIN_L * LPRWB + BIN_W * WPRWB + BIN_WL * PPRWB;
    WR_i           = WR + BIN_L * LWR + BIN_W * WWR + BIN_WL * PWR;
    RSWMIN_i       = RSWMIN + BIN_L * LRSWMIN + BIN_W * WRSWMIN + BIN_WL * PRSWMIN;
    RDWMIN_i       = RDWMIN + BIN_L * LRDWMIN + BIN_W * WRDWMIN + BIN_WL * PRDWMIN;
    RDSW_i         = RDSW + BIN_L * LRDSW + BIN_W * WRDSW + BIN_WL * PRDSW;
    RDSWMIN_i      = RDSWMIN + BIN_L * LRDSWMIN + BIN_W * WRDSWMIN + BIN_WL * PRDSWMIN;
    PTWG_i         = PTWG + BIN_L * LPTWG + BIN_W * WPTWG + BIN_WL * PPTWG;
    PDIBLC_i       = PDIBLC + BIN_L * LPDIBLC + BIN_W * WPDIBLC + BIN_WL * PPDIBLC;
    PDIBLCB_i      = PDIBLCB + BIN_L * LPDIBLCB + BIN_W * WPDIBLCB + BIN_WL * PPDIBLCB;
    PSCBE1_i       = PSCBE1 + BIN_L * LPSCBE1 + BIN_W * WPSCBE1 + BIN_WL * PPSCBE1;
    PSCBE2_i       = PSCBE2 + BIN_L * LPSCBE2 + BIN_W * WPSCBE2 + BIN_WL * PPSCBE2;
    PDITS_i        = PDITS + BIN_L * LPDITS + BIN_W * WPDITS + BIN_WL * PPDITS;
    PDITSD_i       = PDITSD + BIN_L * LPDITSD + BIN_W * WPDITSD + BIN_WL * PPDITSD;
    FPROUT_i       = FPROUT + BIN_L * LFPROUT + BIN_W * WFPROUT + BIN_WL * PFPROUT;
    PVAG_i         = PVAG + BIN_L * LPVAG + BIN_W * WPVAG + BIN_WL * PPVAG;
    VSAT_i         = VSAT + BIN_L * LVSAT + BIN_W * WVSAT + BIN_WL * PVSAT;
    PSAT_i         = PSAT + BIN_L * LPSAT + BIN_W * WPSAT + BIN_WL * PPSAT;
    VSATCV_i       = VSATCV + BIN_L * LVSATCV + BIN_W * WVSATCV + BIN_WL * PVSATCV;
    CF_i           = CF + BIN_L * LCF + BIN_W * WCF + BIN_WL * PCF;
    CGSL_i         = CGSL + BIN_L * LCGSL + BIN_W * WCGSL + BIN_WL * PCGSL;
    CGDL_i         = CGDL + BIN_L * LCGDL + BIN_W * WCGDL + BIN_WL * PCGDL;
    CKAPPAS_i      = CKAPPAS + BIN_L * LCKAPPAS + BIN_W * WCKAPPAS + BIN_WL * PCKAPPAS;
    CKAPPAD_i      = CKAPPAD + BIN_L * LCKAPPAD + BIN_W * WCKAPPAD + BIN_WL * PCKAPPAD;
    ALPHA0_i       = ALPHA0 + BIN_L * LALPHA0 + BIN_W * WALPHA0 + BIN_WL * PALPHA0;
    BETA0_i        = BETA0 + BIN_L * LBETA0 + BIN_W * WBETA0 + BIN_WL * PBETA0;
    KVTH0WE_i      = KVTH0WE + BIN_L * LKVTH0WE  + BIN_W * WKVTH0WE + BIN_WL * PKVTH0WE;
    K2WE_i         = K2WE + BIN_L * LK2WE + BIN_W * WK2WE + BIN_WL * PK2WE;
    KU0WE_i        = KU0WE + BIN_L * LKU0WE + BIN_W * WKU0WE + BIN_WL * PKU0WE;
    AGIDL_i        = AGIDL + BIN_L * LAGIDL + BIN_W * WAGIDL + BIN_WL * PAGIDL;
    BGIDL_i        = BGIDL + BIN_L * LBGIDL + BIN_W * WBGIDL + BIN_WL * PBGIDL;
    CGIDL_i        = CGIDL + BIN_L * LCGIDL + BIN_W * WCGIDL + BIN_WL * PCGIDL;
    EGIDL_i        = EGIDL + BIN_L * LEGIDL + BIN_W * WEGIDL + BIN_WL * PEGIDL;
    AGISL_i        = AGISL + BIN_L * LAGISL + BIN_W * WAGISL + BIN_WL * PAGISL;
    BGISL_i        = BGISL + BIN_L * LBGISL + BIN_W * WBGISL + BIN_WL * PBGISL;
    CGISL_i        = CGISL + BIN_L * LCGISL + BIN_W * WCGISL + BIN_WL * PCGISL;
    EGISL_i        = EGISL + BIN_L * LEGISL + BIN_W * WEGISL + BIN_WL * PEGISL;
    UTE_i          = UTE + BIN_L * LUTE + BIN_W * WUTE + BIN_WL * PUTE;
    UA1_i          = UA1 + BIN_L * LUA1 + BIN_W * WUA1 + BIN_WL * PUA1;
    UC1_i          = UC1 + BIN_L * LUC1 + BIN_W * WUC1 + BIN_WL * PUC1;
    UD1_i          = UD1 + BIN_L * LUD1 + BIN_W * WUD1 + BIN_WL * PUD1;
    EU1_i          = EU1 + BIN_L * LEU1 + BIN_W * WEU1 + BIN_WL * PEU1;
    UCSTE_i        = UCSTE + BIN_L * LUCSTE + BIN_W * WUCSTE + BIN_WL * PUCSTE;
    PRT_i          = PRT + BIN_L * LPRT + BIN_W * WPRT + BIN_WL * PPRT;
    AT_i           = AT + BIN_L * LAT + BIN_W * WAT + BIN_WL * PAT;
    PTWGT_i        = PTWGT + BIN_L * LPTWGT + BIN_W * WPTWGT + BIN_WL * PPTWGT;
    IIT_i          = IIT + BIN_L * LIIT + BIN_W * WIIT + BIN_WL * PIIT;
    TGIDL_i        = TGIDL + BIN_L * LTGIDL + BIN_W * WTGIDL + BIN_WL * PTGIDL;
    IGT_i          = IGT + BIN_L * LIGT + BIN_W * WIGT + BIN_WL * PIGT;
    AIGBINV_i      = AIGBINV + BIN_L * LAIGBINV + BIN_W * WAIGBINV + BIN_WL * PAIGBINV;
    BIGBINV_i      = BIGBINV + BIN_L * LBIGBINV + BIN_W * WBIGBINV + BIN_WL * PBIGBINV;
    CIGBINV_i      = CIGBINV + BIN_L * LCIGBINV + BIN_W * WCIGBINV + BIN_WL * PCIGBINV;
    EIGBINV_i      = EIGBINV + BIN_L * LEIGBINV + BIN_W * WEIGBINV + BIN_WL * PEIGBINV;
    NIGBINV_i      = NIGBINV + BIN_L * LNIGBINV + BIN_W * WNIGBINV + BIN_WL * PNIGBINV;
    AIGBACC_i      = AIGBACC + BIN_L * LAIGBACC + BIN_W * WAIGBACC + BIN_WL * PAIGBACC;
    BIGBACC_i      = BIGBACC + BIN_L * LBIGBACC + BIN_W * WBIGBACC + BIN_WL * PBIGBACC;
    CIGBACC_i      = CIGBACC + BIN_L * LCIGBACC + BIN_W * WCIGBACC + BIN_WL * PCIGBACC;
    NIGBACC_i      = NIGBACC + BIN_L * LNIGBACC + BIN_W * WNIGBACC + BIN_WL * PNIGBACC;
    AIGC_i         = AIGC + BIN_L * LAIGC + BIN_W * WAIGC + BIN_WL * PAIGC;
    BIGC_i         = BIGC + BIN_L * LBIGC + BIN_W * WBIGC + BIN_WL * PBIGC;
    CIGC_i         = CIGC + BIN_L * LCIGC + BIN_W * WCIGC + BIN_WL * PCIGC;
    AIGS_i         = AIGS + BIN_L * LAIGS + BIN_W * WAIGS + BIN_WL * PAIGS;
    BIGS_i         = BIGS + BIN_L * LBIGS + BIN_W * WBIGS + BIN_WL * PBIGS;
    CIGS_i         = CIGS + BIN_L * LCIGS + BIN_W * WCIGS + BIN_WL * PCIGS;
    AIGD_i         = AIGD + BIN_L * LAIGD + BIN_W * WAIGD + BIN_WL * PAIGD;
    BIGD_i         = BIGD + BIN_L * LBIGD + BIN_W * WBIGD + BIN_WL * PBIGD;
    CIGD_i         = CIGD + BIN_L * LCIGD + BIN_W * WCIGD + BIN_WL * PCIGD;
    POXEDGE_i      = POXEDGE + BIN_L * LPOXEDGE + BIN_W * WPOXEDGE + BIN_WL * PPOXEDGE;
    DLCIG_i        = DLCIG + BIN_L * LDLCIG + BIN_W * WDLCIG + BIN_WL * PDLCIG;
    DLCIGD_i       = DLCIGD + BIN_L * LDLCIGD + BIN_W * WDLCIGD + BIN_WL * PDLCIGD;
    NTOX_i         = NTOX + BIN_L * LNTOX + BIN_W * WNTOX + BIN_WL * PNTOX;
    KT1_i          = KT1 + BIN_L * LKT1 + BIN_W * WKT1 + BIN_WL * PKT1;
    KT2_i          = KT2 + BIN_L * LKT2 + BIN_W * WKT2 + BIN_WL * PKT2;
    PSATB_i        = PSATB + BIN_L * LPSATB + BIN_W * WPSATB + BIN_WL * PPSATB;
    A1_i           = A1 + BIN_L * LA1 + BIN_W * WA1 + BIN_WL * PA1;
    A11_i          = A11 + BIN_L * LA11 + BIN_W * WA11 + BIN_WL * PA11;
    A2_i           = A2 + BIN_L * LA2 + BIN_W * WA2 + BIN_WL * PA2;
    A21_i          = A21 + BIN_L * LA21 + BIN_W * WA21 + BIN_WL * PA21;
    K0_i           = K0 + BIN_L * LK0 + BIN_W * WK0 + BIN_WL * PK0;
    M0_i           = M0 + BIN_L * LM0 + BIN_W * WM0 + BIN_WL * PM0;
    K01_i          = K01 + BIN_L * LK01 + BIN_W * WK01 + BIN_WL * PK01;
    M01_i          = M01 + BIN_L * LM01 + BIN_W * WM01 + BIN_WL * PM01;
    NFACTOREDGE_i  = NFACTOREDGE + BIN_L * LNFACTOREDGE + BIN_W * WNFACTOREDGE + BIN_WL * PNFACTOREDGE;
    NDEPEDGE_i     = NDEPEDGE + BIN_L * LNDEPEDGE + BIN_W * WNDEPEDGE + BIN_WL * PNDEPEDGE;
    CITEDGE_i      = CITEDGE + BIN_L * LCITEDGE + BIN_W * WCITEDGE + BIN_WL * PCITEDGE;
    CDSCDEDGE_i    = CDSCDEDGE + BIN_L * LCDSCDEDGE + BIN_W * WCDSCDEDGE + BIN_WL * PCDSCDEDGE;
    CDSCBEDGE_i    = CDSCBEDGE + BIN_L * LCDSCBEDGE + BIN_W * WCDSCBEDGE + BIN_WL * PCDSCBEDGE;
    ETA0EDGE_i     = ETA0EDGE + BIN_L * LETA0EDGE + BIN_W * WETA0EDGE + BIN_WL * PETA0EDGE;
    ETABEDGE_i     = ETABEDGE + BIN_L * LETABEDGE + BIN_W * WETABEDGE + BIN_WL * PETABEDGE;
    KT1EDGE_i      = KT1EDGE + BIN_L * LKT1EDGE + BIN_W * WKT1EDGE + BIN_WL * PKT1EDGE;
    KT1LEDGE_i     = KT1LEDGE + BIN_L * LKT1LEDGE + BIN_W * WKT1LEDGE + BIN_WL * PKT1LEDGE;
    KT2EDGE_i      = KT2EDGE + BIN_L * LKT2EDGE + BIN_W * WKT2EDGE + BIN_WL * PKT2EDGE;
    KT1EXPEDGE_i   = KT1EXPEDGE + BIN_L * LKT1EXPEDGE + BIN_W * WKT1EXPEDGE + BIN_WL * PKT1EXPEDGE;
    TNFACTOREDGE_i = TNFACTOREDGE + BIN_L * LTNFACTOREDGE + BIN_W * WTNFACTOREDGE + BIN_WL * PTNFACTOREDGE;
    TETA0EDGE_i    = TETA0EDGE + BIN_L * LTETA0EDGE + BIN_W * WTETA0EDGE + BIN_WL * PTETA0EDGE;
    K2EDGE_i       = K2EDGE + BIN_L * LK2EDGE + BIN_W * WK2EDGE + BIN_WL * PK2EDGE;
    KVTH0EDGE_i    = KVTH0EDGE + BIN_L * LKVTH0EDGE + BIN_W * WKVTH0EDGE + BIN_WL * PKVTH0EDGE;
    STK2EDGE_i     = STK2EDGE + BIN_L * LSTK2EDGE + BIN_W * WSTK2EDGE + BIN_WL * PSTK2EDGE;
    STETA0EDGE_i   = STETA0EDGE + BIN_L * LSTETA0EDGE + BIN_W * WSTETA0EDGE + BIN_WL * PSTETA0EDGE;
    C0_i           = C0 + BIN_L * LC0 + BIN_W * WC0 + BIN_WL * PC0;
    C01_i          = C01 + BIN_L * LC01 + BIN_W * WC01 + BIN_WL * PC01;
    C0SI_i         = C0SI + BIN_L * LC0SI + BIN_W * WC0SI + BIN_WL * PC0SI;
    C0SI1_i        = C0SI1 + BIN_L * LC0SI1 + BIN_W * WC0SI1 + BIN_WL * PC0SI1;
    C0SISAT_i      = C0SISAT + BIN_L * LC0SISAT + BIN_W * WC0SISAT + BIN_WL * PC0SISAT;
    C0SISAT1_i     = C0SISAT1 + BIN_L * LC0SISAT1 + BIN_W * WC0SISAT1 + BIN_WL * PC0SISAT1;

    if (ASYMMOD != 0) begin
        CDSCDR_i  = CDSCDR + BIN_L * LCDSCDR + BIN_W * WCDSCDR + BIN_WL * PCDSCDR;
        ETA0R_i   = ETA0R + BIN_L * LETA0R + BIN_W * WETA0R + BIN_WL * PETA0R;
        U0R_i     = U0R + BIN_L * LU0R + BIN_W * WU0R + BIN_WL * PU0R;
        UAR_i     = UAR + BIN_L * LUAR + BIN_W * WUAR + BIN_WL * PUAR;
        UDR_i     = UDR + BIN_L * LUDR + BIN_W * WUDR + BIN_WL * PUDR;
        UCSR_i    = UCSR + BIN_L * LUCSR + BIN_W * WUCSR + BIN_WL * PUCSR;
        UCR_i     = UCR + BIN_L * LUCR + BIN_W * WUCR + BIN_WL * PUCR;
        PCLMR_i   = PCLMR + BIN_L * LPCLMR + BIN_W * WPCLMR + BIN_WL * PPCLMR;
        PDIBLCR_i = PDIBLCR + BIN_L * LPDIBLCR + BIN_W * WPDIBLCR + BIN_WL * PPDIBLCR;
        VSATR_i   = VSATR + BIN_L * LVSATR + BIN_W * WVSATR + BIN_WL * PVSATR;
        PSATR_i   = PSATR + BIN_L * LPSATR + BIN_W * WPSATR + BIN_WL * PPSATR;
        PTWGR_i   = PTWGR + BIN_L * LPTWGR + BIN_W * WPTWGR + BIN_WL * PPTWGR;
    end

    // Geometrical scaling
    T0        = NDEPL1 * max(pow(Inv_L, NDEPLEXP1) - pow(Inv_Llong, NDEPLEXP1), 0.0) + NDEPL2 * max(pow(Inv_L, NDEPLEXP2) - pow(Inv_Llong, NDEPLEXP2), 0.0);
    T1        = NDEPW * max(pow(Inv_W, NDEPWEXP) - pow(Inv_Wwide, NDEPWEXP), 0.0) + NDEPWL * pow(Inv_W * Inv_L, NDEPWLEXP);
    NDEP_i    = NDEP_i * (1.0 + T0 + T1);
    T0        = NFACTORL * max( pow(Inv_L, NFACTORLEXP) - pow(Inv_Llong, NFACTORLEXP), 0.0);
    T1        = NFACTORW * max( pow(Inv_W, NFACTORWEXP) - pow(Inv_Wwide, NFACTORWEXP), 0.0) + NFACTORWL * pow(Inv_WL, NFACTORWLEXP);
    NFACTOR_i = NFACTOR_i * (1.0 + T0 + T1);
    T0        = (1.0 + CDSCDL * max(pow(Inv_L, CDSCDLEXP) - pow(Inv_Llong, CDSCDLEXP), 0.0));
    CDSCD_i   = CDSCD_i * T0;
    if (ASYMMOD != 0) begin
        CDSCDR_i = CDSCDR_i * T0;
    end
    CDSCB_i = CDSCB_i * (1.0 + CDSCBL * max(pow(Inv_L, CDSCBLEXP) - pow(Inv_Llong, CDSCBLEXP), 0.0));
    U0_i    = MULU0 * U0_i;
    if (MOBSCALE != 1) begin
        if (U0LEXP > 0.0) begin
            U0_i = U0_i * (1.0 - U0L * max(pow(Inv_L, U0LEXP) - pow(Inv_Llong, U0LEXP), 0.0));
            if (ASYMMOD != 0) begin
                U0R_i = U0R_i * (1.0 - U0L * max(pow(Inv_L, U0LEXP) - pow(Inv_Llong, U0LEXP), 0.0));
            end
        end else begin
            U0_i = U0_i * (1.0 - U0L);
            if (ASYMMOD != 0) begin
                U0R_i = U0R_i * (1.0 - U0L);
            end
        end
    end else begin
        U0_i = U0_i * (1.0 - (UP1 * lexp(-Leff / LP1)) - (UP2 * lexp(-Leff / LP2)));
        if (ASYMMOD != 0) begin
            U0R_i = U0R_i * (1.0 - (UP1 * lexp(-Leff / LP1)) - (UP2 * lexp(-Leff / LP2)));
        end
    end
    T0   = UAL * max(pow(Inv_L, UALEXP) - pow(Inv_Llong, UALEXP), 0.0);
    T1   = UAW * max(pow(Inv_W, UAWEXP) - pow(Inv_Wwide, UAWEXP), 0.0) + UAWL * pow(Inv_WL, UAWLEXP);
    UA_i = UA_i * (1.0 + T0 + T1);
    if (ASYMMOD != 0) begin
        UAR_i = UAR_i * (1.0 + T0 + T1);
    end
    T0   = EUL * max(pow(Inv_L, EULEXP) - pow(Inv_Llong, EULEXP), 0.0);
    T1   = EUW * max(pow(Inv_W, EUWEXP) - pow(Inv_Wwide, EUWEXP), 0.0) + EUWL * pow(Inv_WL, EUWLEXP);
    EU_i = EU_i * (1.0 + T0 + T1);
    T0   = 1.0 + UDL * max(pow(Inv_L, UDLEXP) - pow(Inv_Llong, UDLEXP), 0.0);
    UD_i = UD_i * T0;
    if (ASYMMOD != 0) begin
        UDR_i = UDR_i * T0;
    end
    T0   = UCL * max(pow(Inv_L, UCLEXP) - pow(Inv_Llong, UCLEXP), 0.0);
    T1   = UCW * max(pow(Inv_W, UCWEXP) - pow(Inv_Wwide, UCWEXP), 0.0) + UCWL * pow(Inv_WL, UCWLEXP);
    UC_i = UC_i * (1.0 + T0 + T1);
    if (ASYMMOD != 0) begin
        UCR_i = UCR_i * (1.0 + T0 + T1);
    end
    T0     = max(pow(Inv_L, DSUB) - pow(Inv_Llong, DSUB), 0.0);
    ETA0_i = ETA0_i * T0;
    if (ASYMMOD != 0) begin
        ETA0R_i = ETA0R_i * T0;
    end
    ETAB_i   = ETAB_i * max(pow(Inv_L, ETABEXP) - pow(Inv_Llong, ETABEXP), 0.0);
    T0       = 1.0 + PDIBLCL * max(pow(Inv_L, PDIBLCLEXP) - pow(Inv_Llong, PDIBLCLEXP), 0.0);
    PDIBLC_i = PDIBLC_i * T0;
    if (ASYMMOD != 0) begin
        PDIBLCR_i = PDIBLCR_i * T0;
    end
    T0       = DELTA_i * (1.0 + DELTAL * max(pow(Inv_L, DELTALEXP) - pow(Inv_Llong, DELTALEXP), 0.0));
    DELTA_i  = min(T0, 0.5);
    FPROUT_i = FPROUT_i * (1.0 + FPROUTL * max(pow(Inv_L, FPROUTLEXP) - pow(Inv_Llong, FPROUTLEXP), 0.0));
    T0       = (1.0 + PCLML * max(pow(Inv_L, PCLMLEXP) - pow(Inv_Llong, PCLMLEXP), 0.0));
    PCLM_i   = PCLM_i * T0;
    PCLM_i   = max(PCLM_i, 0.0);
    if (ASYMMOD != 0) begin
        PCLMR_i = PCLMR_i * T0;
        PCLMR_i = max(PCLMR_i, 0.0);
    end
    T0     = VSATL * max(pow(Inv_L, VSATLEXP) - pow(Inv_Llong, VSATLEXP), 0.0);
    T1     = VSATW * max(pow(Inv_W, VSATWEXP) - pow(Inv_Wwide, VSATWEXP), 0.0) + VSATWL * pow(Inv_WL, VSATWLEXP);
    VSAT_i = VSAT_i * (1.0 + T0 + T1);
    if (ASYMMOD != 0) begin
        VSATR_i = VSATR_i * (1.0 + T0 + T1);
    end
    PSAT_i = max(PSAT_i * (1.0 + PSATL * max(pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0.0)), 0.25);
    if (ASYMMOD != 0) begin
        PSATR_i = max(PSATR_i * (1.0 + PSATL * max(pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0.0)), 0.25);
    end
    T0     = (1.0 + PTWGL * max(pow(Inv_L, PTWGLEXP) - pow(Inv_Llong, PTWGLEXP), 0.0));
    PTWG_i = PTWG_i * T0;
    if (ASYMMOD != 0) begin
        PTWGR_i = PTWGR_i * T0;
    end
    ALPHA0_i = ALPHA0_i * (1.0 + ALPHA0L * max(pow(Inv_L, ALPHA0LEXP) - pow(Inv_Llong, ALPHA0LEXP), 0.0));
    AGIDL_i  = AGIDL_i * (1.0 + AGIDLL * Inv_L + AGIDLW * Inv_W);
    AGISL_i  = AGISL_i * (1.0 + AGISLL * Inv_L + AGISLW * Inv_W);
    AIGC_i   = AIGC_i * (1.0 + AIGCL * Inv_L + AIGCW * Inv_W);
    AIGS_i   = AIGS_i * (1.0 + AIGSL * Inv_L + AIGSW * Inv_W);
    AIGD_i   = AIGD_i * (1.0 + AIGDL * Inv_L + AIGDW * Inv_W);
    PIGCD_i  = PIGCD * (1.0 + PIGCDL * Inv_L);
    T0       = NDEPCVL1 * max(pow(Inv_Lact, NDEPCVLEXP1) - pow(Inv_Llong, NDEPCVLEXP1), 0.0) + NDEPCVL2 * max( pow(Inv_Lact, NDEPCVLEXP2) - pow(Inv_Llong, NDEPCVLEXP2), 0.0);
    T1       = NDEPCVW * max(pow(Inv_Wact, NDEPCVWEXP) - pow(Inv_Wwide, NDEPCVWEXP), 0.0) + NDEPCVWL * pow(Inv_Wact * Inv_Lact, NDEPCVWLEXP);
    NDEPCV_i = NDEPCV_i * (1.0 + T0 + T1);
    T0       = VFBCVL * max(pow(Inv_Lact, VFBCVLEXP) - pow(Inv_Llong, VFBCVLEXP), 0.0);
    T1       = VFBCVW * max(pow(Inv_Wact, VFBCVWEXP) - pow(Inv_Wwide, VFBCVWEXP), 0.0) + VFBCVWL * pow(Inv_WL, VFBCVWLEXP);
    VFBCV_i  = VFBCV_i * (1.0 + T0 + T1);
    T0       = VSATCVL * max(pow(Inv_Lact, VSATCVLEXP) - pow(Inv_Llong, VSATCVLEXP), 0.0);
    T1       = VSATCVW * max(pow(Inv_W, VSATCVWEXP) - pow(Inv_Wwide, VSATCVWEXP), 0.0) + VSATCVWL * pow(Inv_WL, VSATCVWLEXP);
    VSATCV_i = VSATCV_i * (1.0 + T0 + T1);
    PCLMCV_i = PCLMCV_i * (1.0 + PCLMCVL * max(pow(Inv_Lact, PCLMCVLEXP) - pow(Inv_Llong, PCLMCVLEXP), 0.0));
    PCLMCV_i = max(PCLMCV_i, 0.0);
    T0       = K1L * max(pow(Inv_L, K1LEXP) - pow(Inv_Llong, K1LEXP), 0.0);
    T1       = K1W * max(pow(Inv_W, K1WEXP) - pow(Inv_Wwide, K1WEXP), 0.0) + K1WL * pow(Inv_WL, K1WLEXP);
    K1_i     = K1_i * (1.0 + T0 + T1);
    T0       = K2L * max(pow(Inv_L, K2LEXP) - pow(Inv_Llong, K2LEXP), 0.0);
    T1       = K2W * max(pow(Inv_W, K2WEXP) - pow(Inv_Wwide, K2WEXP), 0.0) + K2WL * pow(Inv_WL, K2WLEXP);
    K2_i     = K2_i * (1.0 + T0 + T1);
    PRWB_i   = PRWB_i * (1.0 + PRWBL * max( pow(Inv_L, PRWBLEXP) - pow(Inv_Llong, PRWBLEXP), 0));

    // Global scaling parameters for temperature
    UTE_i   = UTE_i * (1.0 + Inv_L * UTEL);
    UA1_i   = UA1_i * (1.0 + Inv_L * UA1L);
    UD1_i   = UD1_i * (1.0 + Inv_L * UD1L);
    AT_i    = AT_i * (1.0 + Inv_L * ATL);
    PTWGT_i = PTWGT_i * (1.0 + Inv_L * PTWGTL);
    if ($port_connected(t) == 0) begin
        if (SHMOD == 0 || RTH0 == 0.0) begin
            Temp(t) <+ 0.0;
        end else begin
            $strobe("5 terminal Module, while 't' node is not connected, SH is activated.");
        end
    end
    if (RDSMOD == 1) begin
        RSW_i = RSW_i * (1.0 + RSWL * max(pow(Inv_L, RSWLEXP) - pow(Inv_Llong, RSWLEXP), 0.0));
        RDW_i = RDW_i * (1.0 + RDWL * max(pow(Inv_L, RDWLEXP) - pow(Inv_Llong, RDWLEXP), 0.0));
    end else begin
        RDSW_i = RDSW_i * (1.0 + RDSWL * max(pow(Inv_L, RDSWLEXP) - pow(Inv_Llong, RDSWLEXP), 0.0));
    end

    // Parameter checking
    if (UCS_i < 1.0) begin
        UCS_i = 1.0;
    end else if (UCS_i > 2.0) begin
        UCS_i = 2.0;
    end
    if (ASYMMOD != 0) begin
        if (UCSR_i < 1.0) begin
            UCSR_i = 1.0;
        end else if (UCSR_i > 2.0) begin
            UCSR_i = 2.0;
        end
    end
    if (CGIDL_i < 0.0) begin
        $strobe("Fatal: CGIDL_i = %e is negative.", CGIDL_i);
        $finish(0);
    end
    if (CGISL_i < 0.0) begin
        $strobe("Fatal: CGISL_i = %e is negative.", CGISL_i);
        $finish(0);
    end
    if (CKAPPAD_i <= 0.0) begin
        $strobe("Fatal: CKAPPAD_i = %e is non-positive.", CKAPPAD_i);
        $finish(0);
    end
    if (CKAPPAS_i <= 0.0) begin
        $strobe("Fatal: CKAPPAS_i = %e is non-positive.", CKAPPAS_i);
        $finish(0);
    end
    if (PDITS_i < 0.0) begin
        $strobe("Fatal: PDITS_i = %e is negative.", PDITS_i);
        $finish(0);
    end
    if (CIT_i < 0.0) begin
        $strobe("Fatal: CIT_i = %e is negative.", CIT_i);
        $finish(0);
    end
    if (NFACTOR_i < 0.0) begin
        $strobe("Fatal: NFACTOR_i = %e is negative.", NFACTOR_i);
        $finish(0);
    end
    if (K1_i < 0.0) begin
        $strobe("Fatal: K1_i = %e is negative.", K1_i);
        $finish(0);
    end

    if (NSD_i <= 0.0) begin
        $strobe("Fatal: NSD_i = %e is non-positive.", NSD_i);
        $finish(0);
    end
    if (NDEP_i <= 0.0) begin
        $strobe("Fatal: NDEP_i = %e is non-positive.", NDEP_i);
        $finish(0);
    end
    if (NDEPCV_i <= 0.0) begin
        $strobe("Fatal: NDEPCV_i = %e is non-positive.", NDEPCV_i);
        $finish(0);
    end
    if (IGBMOD != 0) begin
        if (NIGBINV_i <= 0.0) begin
            $strobe("Fatal: NIGBINV_i = %e is non-positive.", NIGBINV_i);
            $finish(0);
        end
        if (NIGBACC_i <= 0.0) begin
            $strobe("Fatal: NIGBACC_i = %e is non-positive.", NIGBACC_i);
            $finish(0);
        end
    end
    if (IGCMOD != 0) begin
        if (POXEDGE_i <= 0.0) begin
            $strobe("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i);
            $finish(0);
        end
    end
    if (CDSCD_i < 0.0) begin
        $strobe("Fatal: CDSCD_i = %e is negative.", CDSCD_i);
        $finish(0);
    end
    if (ASYMMOD != 0) begin
        if (CDSCDR_i < 0.0) begin
            $strobe("Fatal: CDSCDR_i = %e is negative.", CDSCDR_i);
            $finish(0);
        end
    end
    if (DLCIG_i < 0.0) begin
        $strobe("Warning: DLCIG = %e is negative, setting it to 0.", DLCIG_i);
        DLCIG_i = 0.0;
    end
    if (DLCIGD_i < 0.0) begin
        $strobe("Warning: DLCIGD = %e is negative, setting it to 0.", DLCIGD_i);
        DLCIGD_i = 0.0;
    end
    if (M0_i < 0.0) begin
        $strobe("Warning: M0_i = %e is negative, setting it to 0.", M0_i);
        M0_i = 0.0;
    end
    if (U0_i <= 0.0) begin
        $strobe("Warning: U0_i = %e is non-positive, setting it to the default value.", U0_i);
        U0_i = 0.067;
    end
    if (UA_i < 0.0) begin
        $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i);
        UA_i = 0.0;
    end
    if (EU_i < 0.0) begin
        $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i);
        EU_i = 0.0;
    end
    if (UD_i < 0.0) begin
        $strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i);
        UD_i = 0.0;
    end
    if (UCS_i < 0.0) begin
        $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i);
        UCS_i = 0.0;
    end

    // Initialize variables used in geometry macros
    nuEndD = 0.0; nuEndS = 0.0; nuIntD = 0.0; nuIntS = 0.0; Rend = 0.0; Rint = 0.0;

    // Process drain series resistance
    DMCGeff = DMCG - DMCGT;
    DMCIeff = DMCI;
    DMDGeff = DMDG - DMCGT;

    // Processing S/D resistances and conductances
    if($param_given(NRS)) begin
        RSourceGeo = RSH * NRS;
    end else if (RGEOMOD > 0 && RSH > 0.0) begin
        `BSIMBULKRdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 1, RSourceGeo)
    end else begin
        RSourceGeo = 0.0;
    end

    if ($param_given(NRD)) begin
        RDrainGeo = RSH * NRD;
    end else if (RGEOMOD > 0 && RSH > 0.0) begin
        `BSIMBULKRdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 0, RDrainGeo)
    end else begin
        RDrainGeo = 0.0;
    end
    // Clamping of S/D resistances 

    if (RDSMOD == 0) begin
        if (RSourceGeo < minr) begin
            RSourceGeo = 0;
        end
        if (RDrainGeo < minr) begin
            RDrainGeo = 0;
        end
    end else begin
        if (RSourceGeo <= minr) begin
            RSourceGeo = minr;
        end
        if (RDrainGeo <= minr) begin
            RDrainGeo = minr;
        end
    end


    if (RDSMOD == 1) begin
        if (RSWMIN_i <= 0.0) begin
            RSWMIN_i = 0.0;
        end
        if (RDWMIN_i <= 0.0) begin
            RDWMIN_i = 0.0;
        end
        if (RSW_i <= 0.0) begin
            RSW_i = 0.0;
        end
        if (RDW_i <= 0.0) begin
            RDW_i = 0.0;
        end
    end else begin
        if (RDSWMIN_i <= 0.0) begin
            RDSWMIN_i = 0.0;
        end
        if (RDSW_i <= 0.0) begin
            RDSW_i = 0.0;
        end
    end

    // Body resistance network
    Grbsb = 0.0; Grbdb = 0.0; Grbpb = 0.0; Grbps = 0.0; Grbpd = 0.0;

    if (RBODYMOD != 0) begin
        Lnl  = lln(Leff * 1.0e6);
        Lnw  = lln(Weff * 1.0e6);
        Lnnf = lln(NF);
        Bodymode = 5;
        Rbpb = RBPB;
        Rbpd = RBPD;
        Rbps = RBPS;
        Rbdb = RBDB;
        Rbsb = RBSB;
        if (!$param_given(RBPS0) || !$param_given(RBPD0)) begin
            Bodymode = 1;
        end
        else if (!$param_given(RBSBX0) && !$param_given(RBSBY0) || !$param_given(RBDBX0) && !$param_given(RBDBY0)) begin
            Bodymode = 3;
        end
        if (RBODYMOD == 2) begin
            if (Bodymode == 5) begin
                Rbsbx = RBSBX0 * lexp(RBSDBXL * Lnl + RBSDBXW * Lnw + RBSDBXNF * Lnnf);
                Rbsby = RBSBY0 * lexp(RBSDBYL * Lnl + RBSDBYW * Lnw + RBSDBYNF * Lnnf);
                Rbsb  = Rbsbx * Rbsby / (Rbsbx + Rbsby);
                Rbdbx = RBDBX0 * lexp(RBSDBXL * Lnl + RBSDBXW * Lnw + RBSDBXNF * Lnnf);
                Rbdby = RBDBY0 * lexp(RBSDBYL * Lnl + RBSDBYW * Lnw + RBSDBYNF * Lnnf);
                Rbdb  = Rbdbx * Rbdby / (Rbdbx + Rbdby);
            end
            if (Bodymode == 3 || Bodymode == 5) begin
                Rbps = RBPS0 * lexp(RBPSL * Lnl + RBPSW * Lnw + RBPSNF * Lnnf);
                Rbpd = RBPD0 * lexp(RBPDL * Lnl + RBPDW * Lnw + RBPDNF * Lnnf);
            end
            Rbpbx = RBPBX0 * lexp(RBPBXL * Lnl + RBPBXW * Lnw + RBPBXNF * Lnnf);
            Rbpby = RBPBY0 * lexp(RBPBYL * Lnl + RBPBYW * Lnw + RBPBYNF * Lnnf);
            Rbpb  = Rbpbx * Rbpby / (Rbpbx + Rbpby);
        end
        if (RBODYMOD == 1 || (RBODYMOD == 2 && Bodymode == 5)) begin
            if (Rbdb < 1.0e-3) begin
                Grbdb = 1.0e3;  // in mho
            end else begin
                Grbdb = GBMIN + 1.0 / Rbdb;
            end
            if (Rbpb < 1.0e-3) begin
                Grbpb = 1.0e3;
            end else begin
                Grbpb = GBMIN + 1.0 / Rbpb;
            end
            if (Rbps < 1.0e-3) begin
                Grbps = 1.0e3;
            end else begin
                Grbps = GBMIN + 1.0 / Rbps;
            end
            if (Rbsb < 1.0e-3) begin
                Grbsb = 1.0e3;
            end else begin
                Grbsb = GBMIN + 1.0 / Rbsb;
            end
            if (Rbpd < 1.0e-3) begin
                Grbpd = 1.0e3;
            end else begin
                Grbpd = GBMIN + 1.0 / Rbpd;
            end
        end else if (RBODYMOD == 2 && Bodymode == 3) begin
            Grbdb = GBMIN;
            Grbsb = GBMIN;
            if (Rbpb < 1.0e-3) begin
                Grbpb = 1.0e3;
            end else begin
                Grbpb = GBMIN + 1.0 / Rbpb;
            end
            if (Rbps < 1.0e-3) begin
                Grbps = 1.0e3;
            end else begin
                Grbps = GBMIN + 1.0 / Rbps;
            end
            if (Rbpd < 1.0e-3) begin
                Grbpd = 1.0e3;
            end else begin
                Grbpd = GBMIN + 1.0 / Rbpd;
            end
        end else if (RBODYMOD == 2 && Bodymode == 1) begin
            Grbdb = GBMIN;
            Grbsb = GBMIN;
            Grbps = 1.0e3;
            Grbpd = 1.0e3;
            if (Rbpb < 1.0e-3) begin
                Grbpb = 1.0e3;
            end else begin
                Grbpb = GBMIN + 1.0 / Rbpb;
            end
        end
    end

    // Gate process resistance
    Grgeltd = RSHG * (XGW + Weffcj / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));
    if (Grgeltd > 0.0) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3;
        if (RGATEMOD != 0) begin
            `STROBE("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
        end
    end
    T0           = TOXE * TOXE;
    T1           = TOXE * POXEDGE_i;
    T2           = T1 * T1;
    ToxRatio     = lexp(NTOX_i * lln(TOXREF / TOXE)) / T0;
    ToxRatioEdge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    Aechvb       = (TYPE == `ntype) ? 4.97232e-7 : 3.42537e-7;
    Bechvb       = (TYPE == `ntype) ? 7.45669e11 : 1.16645e12;
    AechvbEdge   = Aechvb * Weff * ToxRatioEdge;
    BechvbEdge   = -Bechvb * TOXE * POXEDGE_i;
    Aechvb       = Aechvb * (Weff * Leff * ToxRatio);
    Bechvb       = -Bechvb * TOXE;
    Weff_SH      = WTH0 + Weff;

    // Parameters for self-heating effects
    if((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        gth = Weff_SH * NF / RTH0;
        cth = CTH0 * Weff_SH * NF;
    end else begin
        // Set gth to some value to prevent a singular G matrix
        gth = 1.0;
        cth = 0.0;
    end

    // Temperature-dependent calculations
    if (TNOM <= -`P_CELSIUS0) begin
        T0 = `REFTEMP - `P_CELSIUS0;
        $strobe("Warning: TNOM = %e C <= %e C. Setting TNOM to %e C.", TNOM, -`P_CELSIUS0, T0);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `P_CELSIUS0;
    end
    DevTemp = $temperature + DTEMP;

    // Calculate temperature dependent values for self-heating effects
    if ((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        delTemp1 = Temp(t);
    end else begin
        delTemp1 = 0.0;
    end
    DevTemp    = delTemp1 + DevTemp;
    T_DELTA_SH = Temp(t);
    T_TOTAL_K  = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    Vt         = `KboQ * DevTemp;
    inv_Vt     = 1.0 / Vt;
    TRatio     = DevTemp / Tnom;
    delTemp    = DevTemp - Tnom;
    Vtm        = `KboQ * DevTemp;
    Vtm0       = `KboQ * Tnom;
    Eg         = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
    Eg0        = BG0SUB - TBGASUB * Tnom * Tnom / (Tnom + TBGBSUB);
    T1         = (DevTemp / Tnom) * sqrt(DevTemp / Tnom);
    ni         = NI0SUB * T1 * lexp(Eg / (2.0 * Vtm0) - Eg / (2.0 * Vtm));
    if ((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        T0   = lln(NDEP_i / ni);
        phib = sqrt(T0 * T0 + 1.0e-6);
    end else begin
        phib = lln(NDEP_i / ni);
    end
    if ((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        T0  = lln(NDEPEDGE_i * NSD_i / (ni * ni));
        Vbi_edge = sqrt(T0 * T0 + 1.0e-6);
    end else begin
        Vbi_edge = lln(NDEPEDGE_i * NSD_i / (ni * ni));
    end
    if (NGATE_i > 0.0) begin
        Vfbsdr = -devsign * Vt * lln(NGATE_i / NSD_i) + VFBSDOFF;
    end else begin
        Vfbsdr = 0.0;
    end

    // Short channel effects
    Phist     = max(0.4 + Vt * phib + PHIN_i, 0.4);
    sqrtPhist = sqrt(Phist);
    T1DEP     = sqrt(2.0 * epssi / (`q * NDEP_i));
    litl      = sqrt((epssi / epsox) * TOXE * XJ_i);
    NFACTOR_t = NFACTOR_i * hypsmooth((1.0 + TNFACTOR * (TRatio - 1.0)), 1e-3);
    ETA0_t    = ETA0_i * (1.0 + TETA0 * (TRatio - 1.0));
    if (ASYMMOD != 0) begin
        ETA0R_t = ETA0R_i * (1.0 + TETA0 * (TRatio - 1.0));
    end

    // Mobility degradation
    eta_mu = (TYPE != `ntype) ? (`Oneby3 * ETAMOB) : (0.5 * ETAMOB);
    U0_t   = U0_i * pow(TRatio, UTE_i);
    UA_t   = UA_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
    UC_t   = UC_i * hypsmooth(1.0 + UC1_i * delTemp - 1.0e-6, 1.0e-3);
    UD_t   = UD_i * pow(TRatio, UD1_i);
    UCS_t  = UCS_i * pow(TRatio, UCSTE_i);
    EU_t   = EU_i * hypsmooth((1.0 + EU1_i * (TRatio - 1.0)), 1e-3);
    if (ASYMMOD != 0) begin
        U0R_t  = U0R_i * pow(TRatio, UTE_i);
        UAR_t  = UAR_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
        UCR_t  = UCR_i * hypsmooth(1.0 + UC1_i * delTemp - 1.0e-6, 1.0e-3);
        UDR_t  = UDR_i * pow(TRatio, UD1_i);
        UCSR_t = UCSR_i * pow(TRatio, UCSTE_i);
    end
    rdstemp = pow(TRatio, PRT_i);
    VSAT_t  = VSAT_i * pow(TRatio, -AT_i);
    if (VSAT_t < 100.0) begin
        $strobe("Warning: VSAT(%f) = %e is less than 100, setting it to 100.", DevTemp, VSAT_t);
        VSAT_t = 100.0;
    end
    if (HVMOD == 1) begin
        rdstemphv = pow(TRatio, PRTHV);
        VDRIFT_t  = VDRIFT * pow(TRatio, -ATHV);
    end
    if (ASYMMOD != 0) begin
        VSATR_t = VSATR_i * pow(TRatio, -AT_i);
        if(VSATR_t < 100.0) begin
            $strobe("Warning: VSATR(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATR_t);
            VSATR_t = 100.0;
        end
    end
    VSATCV_t = VSATCV_i * pow(TRatio, -AT_i);
    if (VSATCV_t < 100.0) begin
        $strobe("Warning: VSATCV(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATCV_t);
        VSATCV_t = 100.0;
    end
    DELTA_t = 1.0 / ( hypsmooth((1.0 / DELTA_i) * (1.0 + TDELTA * delTemp) - 2.0 , 1.0e-3) + 2.0);
    PTWG_t  = PTWG_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
    if (ASYMMOD != 0) begin
        PTWGR_t = PTWGR_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
    end
    A1_t    = A1_i * hypsmooth(1.0 + A11_i * delTemp - 1.0e-6, 1.0e-3);
    A2_t    = A2_i * hypsmooth(1.0 + A21_i * delTemp - 1.0e-6, 1.0e-3);
    BETA0_t = BETA0_i * pow(TRatio, IIT_i);
    BGIDL_t = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
    BGISL_t = BGISL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
    igtemp  = lexp(IGT_i * lln(TRatio));
    K0_t    = K0_i * hypsmooth(1.0 + K01_i * delTemp - 1.0e-6, 1.0e-3);
    M0_t    = M0_i * hypsmooth(1.0 + M01_i * delTemp - 1.0e-6, 1.0e-3);
    C0_t    = C0_i * hypsmooth(1.0 + C01_i * delTemp - 1.0e-6, 1.0e-3);
    C0SI_t  = C0SI_i * hypsmooth(1.0 + C0SI1_i * delTemp - 1.0e-6, 1.0e-3);
    C0SISAT_t = C0SISAT_i * hypsmooth(1.0 + C0SISAT1_i * delTemp - 1.0e-6, 1.0e-3);

    // Diode model temperature effects
    CJS_t     = CJS * hypsmooth(1.0 + TCJ * delTemp - 1.0e-6, 1.0e-3);
    CJD_t     = CJD * hypsmooth(1.0 + TCJ * delTemp - 1.0e-6, 1.0e-3);
    CJSWS_t   = CJSWS * hypsmooth(1.0 + TCJSW * delTemp - 1.0e-6, 1.0e-3);
    CJSWD_t   = CJSWD * hypsmooth(1.0 + TCJSW * delTemp - 1.0e-6, 1.0e-3);
    CJSWGS_t  = CJSWGS * hypsmooth(1.0 + TCJSWG * delTemp - 1.0e-6, 1.0e-3);
    CJSWGD_t  = CJSWGD * hypsmooth(1.0 + TCJSWG * delTemp - 1.0e-6, 1.0e-3);
    PBS_t     = hypsmooth(PBS - TPB * delTemp - 0.01, 1.0e-3) + 0.01;
    PBD_t     = hypsmooth(PBD - TPB * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWS_t   = hypsmooth(PBSWS - TPBSW * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWD_t   = hypsmooth(PBSWD - TPBSW * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWGS_t  = hypsmooth(PBSWGS - TPBSWG * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWGD_t  = hypsmooth(PBSWGD - TPBSWG * delTemp - 0.01, 1.0e-3) + 0.01;
    T0        = Eg0 / Vtm0 - Eg / Vtm;
    T1        = lln(TRatio);
    T3        = lexp((T0 + XTIS * T1) / NJS);
    JSS_t     = JSS * T3;
    JSWS_t    = JSWS * T3;
    JSWGS_t   = JSWGS * T3;
    T3        = lexp((T0 + XTID * T1) / NJD);
    JSD_t     = JSD * T3;
    JSWD_t    = JSWD * T3;
    JSWGD_t   = JSWGD * T3;
    JTSS_t    = JTSS * lexp(Eg0 * XTSS * (TRatio - 1.0) / Vtm);
    JTSSWS_t  = JTSSWS * lexp(Eg0 * XTSSWS * (TRatio - 1.0) / Vtm);
    JTSSWGS_t = JTSSWGS * (sqrt(JTWEFF / Weffcj) + 1.0) * lexp(Eg0 * XTSSWGS * (TRatio - 1) / Vtm);
    JTSD_t    = JTSD * lexp(Eg0 * XTSD * (TRatio - 1.0) / Vtm);
    JTSSWD_t  = JTSSWD * lexp(Eg0 * XTSSWD * (TRatio - 1.0) / Vtm);
    JTSSWGD_t = JTSSWGD * (sqrt(JTWEFF / Weffcj) + 1.0) * lexp(Eg0 * XTSSWGD * (TRatio - 1) / Vtm);

    // All NJT*'s smoothed to 0.01 to prevent divide by zero/negative values
    NJTS_t     = hypsmooth(NJTS * (1.0 + TNJTS * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSW_t   = hypsmooth(NJTSSW * (1.0 + TNJTSSW * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSWG_t  = hypsmooth(NJTSSWG * (1.0 + TNJTSSWG * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSD_t    = hypsmooth(NJTSD * (1.0 + TNJTSD * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSWD_t  = hypsmooth(NJTSSWD * (1.0 + TNJTSSWD * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSWGD_t = hypsmooth(NJTSSWGD * (1.0 + TNJTSSWGD * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;

    // Effective S/D junction area and perimeters
    `BSIMBULKPAeffGeo(NF, GEOMOD, MINZ, Weffcj, DMCGeff, DMCIeff, DMDGeff, temp_PSeff, temp_PDeff, temp_ASeff, temp_ADeff)
    if ($param_given(AS)) begin
        ASeff = AS * WMLT * LMLT;
    end else begin
        ASeff = temp_ASeff;
    end
    if (ASeff < 0.0) begin
        $strobe("Warning: (instance %M) ASeff = %e is negative. Set to 0.0.", ASeff);
        ASeff = 0.0;
    end
    if ($param_given(AD)) begin
        ADeff = AD * WMLT * LMLT;
    end else begin
        ADeff = temp_ADeff;
    end
    if (ADeff < 0.0) begin
        $strobe("Warning: (instance %M) ADeff = %e is negative. Set to 0.0.", ADeff);
        ADeff = 0.0;
    end
    if ($param_given(PS)) begin
        if (PERMOD == 0) begin
            // PS does not include gate-edge perimeters
            PSeff = PS * WMLT;
        end else begin
            // PS includes gate-edge perimeters
            PSeff = max(PS * WMLT - Weffcj * NF, 0.0);
        end
    end else begin
        PSeff = temp_PSeff;
        if (PSeff < 0.0) begin
            $strobe("Warning: (instance %M) PSeff = %e is negative. Set to 0.0.", PSeff);
            PSeff = 0.0;
        end
    end
    if ($param_given(PD)) begin
        if (PERMOD == 0) begin
            // PD does not include gate-edge perimeters
            PDeff = PD * WMLT;
        end else begin
            // PD includes gate-edge perimeters
            PDeff = max(PD * WMLT - Weffcj * NF, 0.0);
        end
    end else begin
        PDeff = temp_PDeff;
        if (PDeff < 0.0) begin
            $strobe("Warning: (instance %M) PDeff = %e is negative. Set to 0.0.", PDeff);
            PDeff = 0.0;
        end
    end
    Isbs = ASeff * JSS_t + PSeff * JSWS_t + Weffcj * NF * JSWGS_t;
    if (Isbs > 0.0) begin
        Nvtms    = Vtm * NJS;
        XExpBVS  = lexp(-BVS / Nvtms) * XJBVS;
        T2       = max(IJTHSFWD / Isbs, 10.0);
        Tb       = 1.0 + T2 - XExpBVS;
        VjsmFwd  = Nvtms * lln(0.5 * (Tb + sqrt(Tb * Tb + 4.0 * XExpBVS)));
        T0       = lexp(VjsmFwd / Nvtms);
        IVjsmFwd = Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
        SslpFwd  = Isbs * (T0 + XExpBVS / T0) / Nvtms;
        T2       = hypsmooth(IJTHSREV / Isbs - 10.0, 1.0e-3) + 10.0;
        VjsmRev  = -BVS - Nvtms * lln((T2 - 1.0) / XJBVS);
        T1       = XJBVS * lexp(-(BVS + VjsmRev) / Nvtms);
        IVjsmRev = Isbs * (1.0 + T1);
        SslpRev  = -Isbs * T1 / Nvtms;
    end else begin
        Nvtms    = 0.0;
        XExpBVS  = 0.0;
        VjsmFwd  = 0.0;
        IVjsmFwd = 0.0;
        SslpFwd  = 0.0;
        VjsmRev  = 0.0;
        IVjsmRev = 0.0;
        SslpRev  = 0.0;
    end

    // Drain-side junction currents
    Isbd = ADeff * JSD_t + PDeff * JSWD_t + Weffcj * NF * JSWGD_t;
    if (Isbd > 0.0) begin
        Nvtmd    = Vtm * NJD;
        XExpBVD  = lexp(-BVD / Nvtmd) * XJBVD;
        T2       = max(IJTHDFWD / Isbd, 10.0);
        Tb       = 1.0 + T2 - XExpBVD;
        VjdmFwd  = Nvtmd * lln(0.5 * (Tb + sqrt(Tb * Tb + 4.0 * XExpBVD)));
        T0       = lexp(VjdmFwd / Nvtmd);
        IVjdmFwd = Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
        DslpFwd  = Isbd * (T0 + XExpBVD / T0) / Nvtmd;
        T2       = hypsmooth(IJTHDREV / Isbd - 10.0, 1.0e-3) + 10.0;
        VjdmRev  = -BVD - Nvtmd * lln((T2 - 1.0) / XJBVD);
        T1       = XJBVD * lexp(-(BVD + VjdmRev) / Nvtmd);
        IVjdmRev = Isbd * (1.0 + T1);
        DslpRev  = -Isbd * T1 / Nvtmd;
    end else begin
        Nvtmd    = 0.0;
        XExpBVD  = 0.0;
        VjdmFwd  = 0.0;
        IVjdmFwd = 0.0;
        DslpFwd  = 0.0;
        VjdmRev  = 0.0;
        IVjdmRev = 0.0;
        DslpRev  = 0.0;
    end

    // STI stress equations
    if((SA > 0.0) && (SB > 0.0) && ((NF == 1.0) || ((NF > 1.0) && (SD > 0.0)))) begin
        T0              = pow(Lnew, LLODKU0);
        W_tmp_stress    = Wnew + WLOD;
        T1              = pow(W_tmp_stress, WLODKU0);
        tmp1_stress     = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);
        kstress_u0      = 1.0 + tmp1_stress;
        T0              = pow(Lnew, LLODVTH);
        T1              = pow(W_tmp_stress, WLODVTH);
        tmp1_stress_vth = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
        kstress_vth0    = 1.0 + tmp1_stress_vth;
        T0              = TRatio - 1.0;
        ku0_temp        = kstress_u0 * (1.0 + TKU0 * T0) + 1.0e-9;
        for (i = 0; i < NF; i = i + 1) begin: forloop
            T0     = 1.0 / NF / (SA + 0.5 * L_mult + i * (SD + L_mult));
            T1     = 1.0 / NF / (SB + 0.5 * L_mult + i * (SD + L_mult));
            Inv_sa = Inv_sa + T0;
            Inv_sb = Inv_sb + T1;
        end
        Inv_saref   = 1.0 / (SAREF + 0.5 * L_mult);
        Inv_sbref   = 1.0 / (SBREF + 0.5 * L_mult);
        Inv_odref   = Inv_saref + Inv_sbref;
        rho_ref     = (KU0 / ku0_temp) * Inv_odref;
        Inv_od      = Inv_sa + Inv_sb;
        rho         = (KU0 / ku0_temp) * Inv_od;
        mu0_mult    = (1.0 + rho) / (1.0 + rho_ref);
        vsat_mult   = (1.0 + rho * KVSAT) / (1.0 + rho_ref * KVSAT);
        vth0_stress = (KVTH0 / kstress_vth0) * (Inv_od - Inv_odref);
        k2_stress   = (STK2 / pow(kstress_vth0, LODK2)) * (Inv_od - Inv_odref);
        eta_stress  = (STETA0 / pow(kstress_vth0, LODETA0)) * (Inv_od - Inv_odref);
        U0_t        = U0_t * mu0_mult;
        VSAT_t      = VSAT_t * vsat_mult;
        K2_i        = K2_i + k2_stress;
        ETA0_t      = ETA0_t + eta_stress;
        if (EDGEFET == 1) begin
            vth0_stress_EDGE = (KVTH0EDGE_i / kstress_vth0) * (Inv_od - Inv_odref);
            k2_stress_EDGE   = (STK2EDGE_i / pow(kstress_vth0, LODK2)) * (Inv_od - Inv_odref);
            eta_stress_EDGE  = (STETA0EDGE_i / pow(kstress_vth0, LODETA0)) * (Inv_od - Inv_odref);
        end
        K2EDGE_i   = K2EDGE_i + k2_stress_EDGE;
        ETA0EDGE_i = ETA0EDGE_i + eta_stress_EDGE;
    end else begin
        vth0_stress = 0.0;
        vth0_stress_EDGE = 0.0;
    end

    // Well proximity effect
    if (WPEMOD == 1) begin
        Wdrn      = W / NF;
        local_sca = SCA;
        local_scb = SCB;
        local_scc = SCC;
        if (!$param_given(SCA) && !$param_given(SCB) && !$param_given(SCC)) begin
            if($param_given(SC) && SC > 0.0) begin
                T1        = SC + Wdrn;
                T2        = 1.0 / SCREF;
                local_sca = SCREF * SCREF / (SC * T1);
                local_scb = ((0.1 * SC + 0.01 * SCREF) * lexp(-10.0 * SC * T2)  - (0.1 * T1 + 0.01 * SCREF) *
                            lexp(-10.0 * T1 * T2)) / Wdrn;
                local_scc = ((0.05 * SC + 0.0025 * SCREF) * lexp(-20.0 * SC * T2)  - (0.05 * T1 + 0.0025 * SCREF) *
                            lexp(-20.0 * T1 * T2)) / Wdrn;
            end else begin
                `STROBE("Warning: (Instance %M) No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.");
            end
        end
    end
    vth0_well = KVTH0WE_i * (local_sca + WEB * local_scb + WEC * local_scc);
    k2_well   = K2WE_i * (local_sca + WEB * local_scb + WEC * local_scc);
    mu_well   = 1.0 + KU0WE_i * (local_sca + WEB * local_scb + WEC * local_scc);
    U0_t      = U0_t * mu_well;
    K2_i      = K2_i + k2_well;

    // Load terminal voltages
    Vg            = devsign * V(gi, bi);
    Vd            = devsign * V(di, bi);
    Vs            = devsign * V(si, bi);
    Vds           = Vd - Vs;
    Vds_noswap    = Vds;
    Vsb_noswap    = Vs;
    Vdb_noswap    = Vd;
    Vbs_jct       = devsign * V(sbulk, si);
    Vbd_jct       = devsign * V(dbulk, di);
    Vgd_noswap    = Vg - Vd;
    Vgs_noswap    = Vg - Vs;
    Vgd_ov_noswap = devsign * V(gm, di);
    Vgs_ov_noswap = devsign * V(gm, si);

    // Terminal voltage conditioning
    // Source-drain interchange
    sigvds = 1.0;
    if (Vds < 0.0) begin
        sigvds = -1.0;
        Vd = devsign * V(si, bi);
        Vs = devsign * V(di, bi);
    end
    Vds  = Vd - Vs;
    T0   = AVDSX * Vds;
    if (T0 > `EXPL_THRESHOLD) begin
       T1 = T0;
    end else begin
       T1 = ln(1.0 + exp(T0));
    end
    Vdsx = ((2.0 / AVDSX) * T1) - Vds - ((2.0 / AVDSX) * ln(2.0));
    Vbsx = -(Vs + 0.5 * (Vds - Vdsx));

    // Asymmetry model
    T0 = tanh(0.6 * Vds_noswap / Vtm);
    wf = 0.5 + 0.5 * T0;
    wr = 1.0 - wf;
    if (ASYMMOD != 0) begin
        CDSCD_a  = CDSCDR_i * wr + CDSCD_i * wf;
        ETA0_a   = ETA0R_t * wr + ETA0_t * wf;
        PDIBLC_a = PDIBLCR_i * wr + PDIBLC_i * wf;
        PCLM_a   = PCLMR_i * wr + PCLM_i * wf;
        PSAT_a   = PSATR_i * wr + PSAT_i * wf;
        VSAT_a   = VSATR_t * wr + VSAT_t * wf;
        PTWG_a   = PTWGR_t * wr + PTWG_t * wf;
        U0_a     = U0R_t * wr + U0_t * wf;
        UA_a     = UAR_t * wr + UA_t * wf;
        UC_a     = UCR_t * wr + UC_t * wf;
        UD_a     = UDR_t * wr + UD_t * wf;
        UCS_a    = UCSR_t * wr + UCS_t * wf;
    end else begin
        CDSCD_a  = CDSCD_i;
        ETA0_a   = ETA0_t;
        PDIBLC_a = PDIBLC_i;
        PCLM_a   = PCLM_i;
        PSAT_a   = PSAT_i;
        VSAT_a   = VSAT_t;
        PTWG_a   = PTWG_t;
        U0_a     = U0_t;
        UA_a     = UA_t;
        UC_a     = UC_t;
        UD_a     = UD_t;
        UCS_a    = UCS_t;
    end

    // SCE, DIBL, SS degradation effects, Ref: BSIM4
    `Smooth(Phist - Vbsx, 0.05, 0.1, PhistVbs)
    sqrtPhistVbs = sqrt(PhistVbs);
    Xdep         = T1DEP * sqrtPhistVbs;
    Cdep         = epssi / Xdep;
    cdsc         = CIT_i + NFACTOR_t + CDSCD_a * Vdsx - CDSCB_i * Vbsx;
    T1           = 1.0 + cdsc/Cox;
    `Smooth(T1, 1.0, 0.05, n)
    nVt     = n * Vt;
    inv_nVt = 1.0 / nVt;

    // Vth shift for DIBL
    dVth_dibl = -(ETA0_a + ETAB_i * Vbsx) * Vdsx;
    `Smooth2(dVth_dibl, 0.0, 5.0e-5, dVth_dibl)
    
    // Vth shift with temperature
    dvth_temp = (KT1_i + KT1L / Leff + KT2_i * Vbsx) * (pow(TRatio, KT1EXP) - 1.0);
    

    // Vth correction for pocket implants
    if (DVTP0_i > 0.0) begin
        T0 = -DVTP1_i * Vdsx;
        if (T0 < -`EXPL_THRESHOLD) begin
            T2 = `MIN_EXPL;
        end else begin
            T2 = lexp(T0);
        end
        T3        = Leff + DVTP0_i * (1.0 + T2);
        dVth_ldop = -nVt * lln(Leff / T3);
    end else begin
        dVth_ldop = 0.0;
    end
    T4        = DVTP5_i + DVTP2_i / pow(Leff, DVTP3_i);
    dVth_ldop = dVth_ldop - T4 * tanh(DVTP4_i * Vdsx);

    // Normalization of terminal and flatband voltage by nVt
    VFB_i = VFB_i + DELVTO;
    vg    = Vg * inv_nVt;
    vs    = Vs * inv_nVt;
    vfb   = VFB_i * inv_nVt;

    // Compute dVth_VNUD with "first-order" and "second-order" body-bias effect
    dVth_VNUD = K1_i * (sqrtPhistVbs - sqrtPhist) - K2_i * Vbsx;
    Vth_shift = dVth_dibl + dVth_ldop + dVth_VNUD - dvth_temp + vth0_stress + vth0_well;
    vgfb      = vg - vfb - Vth_shift * inv_nVt;

    // Threshold voltage for operating point information
    gam     = sqrt(2.0 * `q * epssi * NDEP_i * inv_Vt) / Cox;
    q_vth   = 0.5;
    T0      = hypsmooth((2.0 * phib + Vs * inv_Vt), 1.0e-3);
    nq      = 1.0 + gam / (2.0 * sqrt(T0));
    psip_th = hypsmooth((Vs * inv_Vt + 2.0 * phib + lln(q_vth) + 2.0 * q_vth + lln(2.0 * nq / gam * (2.0 * q_vth * nq / gam + 2.0 * sqrt(T0)))), 1.0e-3);
    VTH     = devsign * (VFB_i + (psip_th - Vs * inv_Vt) * Vt + Vt * gam * sqrt(psip_th) + Vth_shift);

    // Normalized body factor
    gam     = sqrt(2.0 * `q * epssi * NDEP_i * inv_nVt) / Cox;
    inv_gam = 1.0 / gam;

    // psip: pinch-off voltage
    phib_n = phib / n;
    `PO_psip(vgfb, gam, 0.0, phib_n, psip)

    // Normalized inversion charge at source end of channel
    `BSIM_q(psip, phib_n, vs, gam, qs)

    // Average charge-surface potential slope, Ref: Charge-based MOS Transistor Modeling by C. Enz & E. Vittoz
    `Smooth(psip, 1.0, 2.0, psipclamp)
    sqrtpsip = sqrt(psipclamp);

    // Source side surface potential
    psiavg = psip - 2.0 * qs;
    `Smooth(psiavg, 1.0, 2.0, T0)
    nq = 1.0 + gam / (sqrtpsip + sqrt(T0));

    // Drain saturation voltage
    EeffFactor = 1.0e-8 / (epsratio * TOXE);
    T0 = nVt * (vgfb - psip - 2.0 * qs * (nq - 1.0));
    `Smooth(T0, 0.0, 0.1, qbs)

    // Source side qi and qb for Vdsat- normalized to Cox
    qis = 2.0 * nq * nVt * qs;
    Eeffs = EeffFactor * (qbs + eta_mu * qis);

    // Ref: BSIM4 mobility model
    T2 = pow(0.5 * (1.0 + (qis / qbs)), UCS_a);
    T3 = (UA_a + UC_a * Vbsx) * pow(Eeffs, EU_t) + UD_a / T2;
    T4 = 1.0 + T3;
    `Smooth(T4, 1.0, 0.0015, Dmobs)
    WeffWRFactor = 1.0 / (pow(Weff * 1.0e6, WR_i) * NF);

    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else begin
        T0   = 1.0 + PRWG_i * qis;
        T1   = PRWB_i * (sqrtPhistVbs - sqrtPhist);
        T2   = 1.0 / T0 + T1;
        T3   = T2 + sqrt(T2 * T2 + 0.01);
        Rdss = (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF * rdstemp;
        if (RDSMOD == 2) begin
            Rdss = (RSourceGeo + (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF + RDrainGeo) * rdstemp;
        end
    end
    T0  = pow(Dmobs, 1.0 / PSAT_a);
    T11 = PSATB_i * Vbsx;
    T12 = sqrt(0.1+T11*T11);
    T1  = 0.5*(1-T11+sqrt((1-T11)*(1-T11)+T12));
    T2  = 10.0 * PSATX * qs * T1 / (10.0 * PSATX + qs * T1);
    if (PTWG_a < 0.0) begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 / (1.0 - PTWG_a * T2));
    end else begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 + PTWG_a * T2);
    end

    // qdsat for external Rds
    if (Rdss == 0) begin
        // Accurate qdsat derived from consistent I-V
        T0 = 0.5 * LambdaC * (qs * qs + qs) / (1.0 + 0.5 * LambdaC * (1.0 + qs));
        T1 = 2.0 * LambdaC * (qs - T0);
        T2 = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0.0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = -2.0 * LambdaC * (T1/T2) * (T1/T2) *(T1/T2);
        end
        T6 = T0 * T5 + T3 + LambdaC * (2.0 * T0 + 1.0);
        T0 = T0 - (T4 / T6);
        T1 = 2.0 * LambdaC * (qs - T0);
        T2 = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0.0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = (T1 / T2) * (T1 / T2) * (T1 / T2);
        end
        T6    = T0 * T5 + T3 + LambdaC * (2.0 * T0 + 1.0);
        qdsat = T0 - (T4/T6);
    // qdsat for internal Rds, Ref: BSIM4
    end else begin
        // Accurate qdsat derived from consistent I-V
        T11 = Weff * 2.0 * nq * Cox * nVt * VSAT_a;
        T12 = T11 * LambdaC * Rdss / (2.0 * nVt);
        T0  = 0.5 * LambdaC * (qs * qs + qs) / (1.0 + 0.5 * LambdaC * (1.0 + qs));
        T1  = 2.0 * LambdaC * (qs - T0);
        T2  = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0.0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = -2.0 * LambdaC * (T1 / T2) * (T1 / T2) * (T1 / T2);
        end
        T6 = T0 * T5 + T3 + T12 * (qs + 2.0 * T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
        T0 = T0 - T4 / T6;
        T1 = 2.0 * LambdaC * (qs - T0);
        T2 = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = -2.0 * LambdaC * (T1 / T2) * (T1 / T2) * (T1 / T2);
        end
        T6    = T0 * T5 + T3 + T12 * (qs + 2.0 * T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
        qdsat = T0 - T4 / T6;
    end
    vdsat = psip - 2.0 * phib_n - (2.0 * qdsat + lln((qdsat * 2.0 * nq * inv_gam) * ((qdsat * 2.0 * nq * inv_gam) + (gam / (nq - 1.0)))));
    Vdsat = vdsat * nVt;

    // Normalized charge qdeff at drain end of channel
    // Vdssat clamped to avoid negative values during transient simulation
    `Smooth(Vdsat - Vs, 0.0, 1.0e-3, Vdssat)
    T7      = pow(Vds / Vdssat , 1.0 / DELTA_t);
    T8      = pow(1.0 + T7, -DELTA_t);
    Vdseff  = Vds * T8;
    vdeff   = (Vdseff + Vs) * inv_nVt;
    `BSIM_q(psip, phib_n, vdeff, gam, qdeff)

    // Reevaluation of nq to include qdeff
    psiavg = psip - qs - qdeff -1.0;
    `Smooth(psiavg, 1.0, 2.0, T0)
    T2 = sqrt(T0);
    nq = 1.0 + gam / (sqrtpsip + T2);

    // Inversion and bulk charge
    DQSD2 = (qs - qdeff) * (qs - qdeff);
    T0    = 1.0 / (1.0 + qs + qdeff);
    T1    = DQSD2 * T0;
    Qb    = vgfb - psip - (nq - 1.0) * (qs + qdeff + `Oneby3 * T1);
    T2    = `Oneby3 * nq;
    T3    = T1 * T0;
    Qs    = T2 * (2.0 * qs + qdeff + 0.5 * (1.0 + 0.8 * qs + 1.2 * qdeff) * T3);
    Qd    = T2 * (qs + 2.0 * qdeff + 0.5 * (1.0 + 1.2 * qs + 0.8 * qdeff) * T3);

    // Mobility degradation, Ref: BSIM4
    // Average charges (qba and qia) - normalized to Cox
    `Smooth(nVt * Qb, 0.0, 0.1, qba)
    qia   = nVt * (Qs + Qd);

    Eeffm = EeffFactor * (qba + eta_mu * qia);
    T2    = pow(0.5 * (1.0 + (qia / qba)), UCS_a);
    T3    = (UA_a + UC_a * Vbsx) * pow(Eeffm, EU_t) + UD_a / T2;
    T4    = 1.0 + T3;
    `Smooth(T4, 1.0, 0.0015, Dmob)

    // Output conductance
    Esat  = 2.0 * VSAT_a / (U0_a / Dmob);
    EsatL = Esat * Leff;
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end

    // Output conductance due to DIBL, Ref: BSIM4
    DIBLfactor = PDIBLC_a;
    diffVds    = Vds - Vdseff;
    Vgst2Vtm   = qia + 2.0 * nVt;
    if (DIBLfactor > 0.0) begin
        T3     = Vgst2Vtm / (Vdssat + Vgst2Vtm);
        T4     = hypsmooth((1.0 + PDIBLCB_i * Vbsx), 1.0e-3);
        T5     = 1.0 / T4;
        VaDIBL = Vgst2Vtm / DIBLfactor * T3 * PVAGfactor * T5;
        Moc    = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end

    // Degradation factor due to pocket implants, Ref: BSIM4
    if (FPROUT_i <= 0.0) begin
        Fp = 1.0;
    end else begin
        T9 = FPROUT_i * sqrt(Leff) / Vgst2Vtm;
        Fp = 1.0 / (1.0 + T9);
    end

    // Channel length modulation, Ref: BSIM4
    Vasat = Vdssat + EsatL;
    if(PCLM_a != 0.0) begin
        if (PCLMG < 0.0) begin
            T1 = PCLM_a / (1.0 - PCLMG * qia / EsatL) / Fp;
        end else begin
            T1 = PCLM_a * (1.0 + PCLMG * qia / EsatL) / Fp;
        end
        MdL = 1.0 + T1 * lln(1.0 + diffVds / T1 / Vasat);
    end else begin
        MdL = 1.0;
    end
    Moc = Moc * MdL;

    // Calculate Va_DITS, Ref: BSIM4
    T1 = lexp(PDITSD_i * Vds);
    if (PDITS_i > 0.0) begin
        T2      = 1.0 + PDITSL * Leff;
        VaDITS  = (1.0 + T2 * T1) / PDITS_i;
        VaDITS  = VaDITS * Fp;
    end else begin
        VaDITS  = `MAX_EXPL;
    end
    T4  = diffVds / VaDITS;
    T0  = 1.0 + T4;
    Moc = Moc * T0;

    // Calculate Va_SCBE, Ref: BSIM4
    if (PSCBE2_i > 0.0) begin
        if (diffVds > PSCBE1_i * litl / `EXPL_THRESHOLD) begin
            T0     = PSCBE1_i * litl / diffVds;
            VaSCBE = Leff * lexp(T0) / PSCBE2_i;
        end else begin
            VaSCBE = `MAX_EXPL * Leff/PSCBE2_i;
        end
    end else begin
        VaSCBE = `MAX_EXPL;
    end
    Mscbe = 1.0 + (diffVds / VaSCBE);
    Moc   = Moc * Mscbe;

    // Velocity saturation
    T0 = pow(Dmob, 1.0 / PSAT_a);
    T11 = PSATB_i * Vbsx;
    T12 = sqrt(0.1+T11*T11);
    T1  = 0.5*(1-T11+sqrt((1-T11)*(1-T11)+T12));
    T2  = 10.0 * PSATX * qia * T1 / (10.0 * PSATX + qia * T1);
    if (PTWG_a < 0.0) begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 / (1.0 - PTWG_a * T2));
    end else begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 + PTWG_a * T2);
    end
    T1 = 2.0 * LambdaC * (qs - qdeff);
    T2 = sqrt(1.0 + T1 * T1);
    if (T1 != 0.0) begin
        Dvsat = 0.5 * (T2 + (1.0 / T1) * asinh(T1));
    end else begin
        Dvsat = 0.5 * (T2 + (1.0 / T2));
    end
    Dptwg = Dvsat;

    // S/D series resistances, Ref: BSIM4
    Rsource = 0.0;
    Rdrain  = 0.0;
    if (RDSMOD == 1) begin
        Rdsi = 0.0;
        Dr   = 1.0;
        // Rs (Source side resistance for all fingers)
        T2      = Vgs_noswap - Vfbsdr;
        T3      = sqrt(T2 * T2 + 0.01);
        Vgs_eff = 0.5 * (T2 + T3);
        T5      = 1.0 + PRWG_i * Vgs_eff;
        T6      = (1.0 / T5) + PRWB_i * Vsb_noswap;
        T4      = 0.5 * (T6 + sqrt(T6 * T6 + 0.01));
        Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T4) * WeffWRFactor);
        // Rd (Drain side resistance for all fingers)
        T2      = Vgd_noswap - Vfbsdr;
        T3      = sqrt(T2 * T2 + 0.01);
        Vgd_eff = 0.5 * (T2 + T3);
        T5      = 1.0 + PRWG_i * Vgd_eff;
        T6      = (1.0 / T5) + PRWB_i * Vdb_noswap;
        T4      = 0.5 * (T6 + sqrt(T6 * T6 + 0.01));
        Rdrain  = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T4) * WeffWRFactor);
    end else begin
        // Ref: (1) BSIM4 (2) "Operation and Modeling of the MOS Transistor" by Yannis Tsividis
        T0      = 1.0 + PRWG_i * qia;
        T1      = PRWB_i * (sqrtPhistVbs - sqrtPhist);
        T2      = 1.0 / T0 + T1;
        T3      = 0.5 * (T2 + sqrt(T2 * T2 + 0.01));
        Rdsi    = rdstemp * (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF;
        Rdrain  = RDrainGeo;
        Rsource = RSourceGeo;
        Dr      = 1.0 + U0_a /(Dvsat * Dmob) * Cox * Weff / Leff * qia * Rdsi;
        if (RDSMOD == 2) begin
            Rdsi    = rdstemp * (RSourceGeo + (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF + RDrainGeo);
            Rdrain  = 0.0;
            Rsource = 0.0;
            Dr      = 1.0 + U0_a /(Dvsat * Dmob) * Cox * Weff / Leff * qia * Rdsi;
        end
    end

    // Non-saturation effect
    T0   = A1_t + A2_t / (qia + 2.0 * n * Vtm);
    DQSD = qs - qdeff;
    T1   = T0 * DQSD * DQSD;
    T2   = T1 + 1.0 - 0.001;
    T3   = -1.0 + 0.5 * (T2 + sqrt(T2 * T2 + 0.004));
    Nsat = 0.5 * (1.0 + sqrt(1.0 + T3));

    // MNUD model to enhance Id-Vd fitting flexibility
    T0   = (qs + qdeff);
    T1   = (qs - qdeff);
    T2   = T1 / (T0 + M0_t);
    T3   = K0_t * T2 * T2;
    Mnud = 1.0 + T3;

    // MNUD1 to enhance the fitting flexiblity for the gm/Id - similar approach used in BSIM-CMG
    T9    = C0_t / (max(0, C0SI_t + C0SISAT_t * T1 * T1) * T0 + 2.0 * n * Vtm);
    Mnud1 = lexp(-T9);
    Dtot  = Dmob * Dvsat * Dr;

    // Effective mobility including mobility degradation
    ueff = U0_a / Dtot;

    // I-V
    ids  = 2.0 * NF * nq * ueff * Weff / Leff * Cox * nVt * nVt * ((qs - qdeff) * (1.0 + qs + qdeff)) * Moc / Nsat * Mnud * Mnud1;
    ids  = ids * IDS0MULT;

// High-voltage model begins: Ref. - Harshit Agarwal et.al., IEEE TED vol. 66, issue 10, pp. 4258, 2019

    if (RDSMOD == 1 && HVMOD == 1) begin
        T4  = 1 + PDRWB * Vbsx;
        T0  = ids ;
        T11 = NF * Weff * `q  * VDRIFT_t ;
        if (RDLCW != 0) begin
            idrift_sat_d = T11 * NDRIFTD  ;
            delta_hv = pow(ids,4-MDRIFT) / (pow(ids,4-MDRIFT)+ HVFACTOR * pow(idrift_sat_d,4-MDRIFT));
            T5  = T0/idrift_sat_d ;
            if (T5 >= 0.99) begin
                T5  = 0.5 * ((T5 + 0.99) - sqrt( (T5 - 0.99) * (T5 - 0.99) + 1.0e-6) + 0.001 );
            end
            T0D = delta_hv * pow(T5,MDRIFT) ;
            T1D = 1.0 - T0D ;
            T2D = pow(T1D,1.0/MDRIFT) ;
            rdrift_d = rdstemphv * RDLCW * WeffWRFactor/T2D * T4;
            IDRIFTSATD = idrift_sat_d;
            if (rdrift_d < 0) begin
                rdrift_d = 0;
            end
        end

        if (RSLCW != 0) begin
            idrift_sat_s = T11 * NDRIFTS  ;
            delta_hv = pow(ids,4-MDRIFT) / (pow(ids,4-MDRIFT)+ HVFACTOR * pow(idrift_sat_s,4-MDRIFT));
            T5  = T0/idrift_sat_s ;
            if (T5 >= 0.99) begin
                T5  = 0.5 * ((T5 + 0.99) - sqrt( (T5 - 0.99) * (T5 - 0.99) + 1.0e-6) + 0.001 );
            end
            T0S = delta_hv * pow(T5,MDRIFT) ;
            T1S = 1.0 - T0S ;
            T2S = pow(T1S,1.0/MDRIFT) ;
            rdrift_s = rdstemphv * RSLCW * WeffWRFactor/T2S * T4;
            if (rdrift_s < 0) begin
                rdrift_s = 0;
            end
        end

        Rdrain  = Rdrain + rdrift_d;  
        Rsource = Rsource + rdrift_s;  
    end

    QIOV  = 0;
    QBOV  = 0;
    QIOVS = 0;
    QBOVS = 0;

    // CV calculations for HVMOD
    if (RDSMOD == 1 && HVCAP == 1 && HVMOD == 1) begin
        vgfbdrift = -devsign * V(gm,di) - VFBOV ;
        vgfbdrift = vgfbdrift/Vt;
        gamhv     = sqrt(2.0 * `q * epssi * NDR * inv_Vt) / Cox;
        phibHV    = lln(NDR / ni);
        `PO_psip(vgfbdrift,gamhv,0,phibHV,psip_k)
        `BSIM_q(psip_k, phibHV, devsign *V(di,bi)/Vt, gamhv, q_k)

        // calculate nq for the drift region
        `Smooth(psip_k, 1.0, 2.0, psipclamp_hv)
        sqrtpsip_k = sqrt(psipclamp_hv);
        psiavg_hv = psip_k - 2.0 * q_k;
        `Smooth(psiavg_hv, 1.0, 2.0, T0)
        nq_hv = 1.0 + gamhv / (sqrtpsip_k + sqrt(T0));
        psi_k = psip_k - 2 * q_k;

        // contribution due to accumulation of the overlap region
        QBOV = NF * Wact * LOVER * `EPS0 * EPSROX / BSIMBULKTOXP * Vt * (vgfbdrift - psi_k - 2 * nq_hv * q_k);

        // contribution due to inversion of the overlap region
        if (SLHV > 0) begin
            T1 = 1 + q_k / SLHV1 ;
            T2 = SLHV * 1.9e-9 / T1;
            T0 = 3.9 * `EPS0 / (BSIMBULKTOXP * 3.9 / EPSROX + T2 / epsratio);
        end else begin
            T0 = `EPS0 * EPSROX / BSIMBULKTOXP;
        end
        QIOV = NF * Wact * LOVERACC * 2 * nq_hv * Vt * T0 * q_k ;

        // For symmetric device, adding contribution of the source side drift region

        if (HVCAPS == 1) begin
            vgfbdrift = -devsign * V(gm,si) - VFBOV ;
            vgfbdrift = vgfbdrift/Vt;
            `PO_psip(vgfbdrift,gamhv,0,phibHV,psip_k)
            `BSIM_q(psip_k, phibHV, devsign * V(si,bi)/Vt, gamhv, q_k)           

            `Smooth(psip_k, 1.0, 2.0, psipclamp_hv)
            sqrtpsip_k = sqrt(psipclamp_hv);
            psiavg_hv = psip_k - 2.0 * q_k;
            `Smooth(psiavg_hv, 1.0, 2.0, T0)
            nq_hv = 1.0 + gamhv / (sqrtpsip_k + sqrt(T0));
            psi_k = psip_k - 2 * q_k;

            QBOVS = NF * Wact * LOVER * `EPS0 * EPSROX / BSIMBULKTOXP * Vt * (vgfbdrift - psi_k - 2 * nq_hv * q_k);

            if (SLHV > 0) begin
                T1 = 1 + q_k / SLHV1 ;
                T2 = SLHV * 1.9e-9 / T1;
                T0 = 3.9 * `EPS0 / (BSIMBULKTOXP * 3.9 / EPSROX + T2 / epsratio);
            end else begin
                T0 = `EPS0 * EPSROX / BSIMBULKTOXP;
            end

           QIOVS = NF * Wact * LOVERACC * 2 * nq_hv * Vt * T0 * q_k ;
        end
    end 


    Gcrg = 0.0;
    if (RGATEMOD > 1) begin
        idsovvds = ueff * Weff / Leff * Cox * qia;
        T9       = XRCRG2 * Vt;
        T0       = T9 * ueff * Weff / Leff * Cox;
        Gcrg     = XRCRG1 * NF * (T0 + idsovvds);
        if (RGATEMOD == 2) begin
            T11  = Grgeltd + Gcrg;
            Gcrg = Grgeltd * Gcrg / T11;
        end
    end

    // Impact ionization currents, Ref: BSIM4
    if ((ALPHA0_i <= 0.0) || (BETA0_t <= 0.0)) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = -BETA0_t / diffVds;
        Iii = ALPHA0_i * diffVds * ids * lexp(T1) / Mscbe;
    end else begin
        Iii = ALPHA0_i * diffVds * ids * `MIN_EXPL / Mscbe;
    end

    // Secondary impact ionization in the drift region
    if (HVMOD == 1 && IIMOD == 1) begin
        Ntot = DRII1 * ids/(NF * Weff * `q  * VDRIFT_t );   
        Nextra = Ntot/NDRIFTD - 1;
        `Smooth(Nextra, 0, DELTAII, Nextra)
        Nextra = NDRIFTD * Nextra;

        `Smooth(devsign * V(d,bi) - Vdseff - DRII2, 0, 0.05, T2)
        T3 = 2.0 * `q /(EPSRSUB * `EPS0) * Nextra;
        T3 = T3 * T2;                             

        if (T3 > BETADR / `EXPL_THRESHOLD) begin
            T1  = -BETADR/T3;
            IsubDR = ALPHADR * T2 * ids * lexp(T1);
        end else begin
            IsubDR = ALPHADR * T2 * ids * `MIN_EXPL;
        end
        Iii = Iii + IsubDR;
    end

    ISUB = Iii * devsign;

    // Gate currents, Ref: BSIM4
    igbinv = 0.0; igbacc = 0.0; igb = 0.0; igcs = 0.0;
    igcd   = 0.0; igs    = 0.0; igd = 0.0;

    if ((IGCMOD != 0) || (IGBMOD != 0)) begin
        Voxm    = nVt * (vgfb - psip + qs + qdeff);
        T1      = sqrt(Voxm * Voxm + 1.0e-4);
        Voxmacc = 0.5 * (-Voxm + T1);
        Voxminv = 0.5 * (Voxm + T1);
    // Igbinv
    if (IGBMOD != 0) begin
        T1     = Voxm / NIGBACC_i / Vt;
        Vaux_Igbacc = NIGBACC_i * Vt * lln(1.0 + lexp(-T1));
        T2     = AIGBACC_i - BIGBACC_i * Voxmacc;
        T3     = 1.0 + CIGBACC_i * Voxmacc;
        T4     = -7.45669e11 * TOXE * T2 * T3;
        T5     = lexp(T4);
        T6     = 4.97232e-7;
        igbacc = NF * Weff * Leff * T6 * ToxRatio * Vg * Vaux_Igbacc * T5;
        igbacc = igbacc * igtemp;
        T1     = (Voxm - EIGBINV_i) / NIGBINV_i / Vt;
        Vaux_Igbinv = NIGBINV_i * Vt * lln(1.0 + lexp(T1));
        T2     = AIGBINV_i - BIGBINV_i * Voxminv;
        T3     = 1.0 + CIGBINV_i * Voxminv;
        T4     = -9.82222e11 * TOXE * T2 * T3;
        T5     = lexp (T4);
        T6     = 3.75956e-7;
        igbinv = NF * Weff * Leff * T6 * ToxRatio * Vg * Vaux_Igbinv * T5;
        igbinv = igbinv * igtemp;
        igb    = igbacc + igbinv;
    end

    if (IGCMOD != 0) begin
        // Igcinv
        T1   = AIGC_i - BIGC_i * Voxminv;
        T2   = 1.0 + CIGC_i * Voxminv;
        T3   = Bechvb * T1 * T2;
        T4   = nq * nVt * (qs + qdeff) * lexp(T3);
        igc0 = NF * Aechvb * T4 * (Vg + 0.5 * Vdsx - 0.5 * (Vs + Vd)) * igtemp;
        // Gate-current partitioning
        Vdseffx = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1      = PIGCD_i * Vdseffx;
        T1_exp  = lexp(-T1);
        T3      = T1 + T1_exp -1.0 + 1.0e-4;
        T4      = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5      = T1 * T1 + 2.0e-4;
        if (sigvds > 0) begin
            igcd = igc0 * T4 / T5;
            igcs = igc0 * T3 / T5;
        end else begin
            igcs = igc0 * T4 / T5;
            igcd = igc0 * T3 / T5;
        end
        // Igs
        T2      = Vgs_noswap - Vfbsdr;
        Vgs_eff = sqrt(T2 * T2 + 1.0e-4);
        if (IGCLAMP == 1) begin
            T1 = hypsmooth((AIGS_i - BIGS_i * Vgs_eff), 1.0e-6);
            if (CIGS_i < 0.01) begin
                CIGS_i = 0.01;
            end
        end else begin
            T1 = AIGS_i - BIGS_i * Vgs_eff;
        end
        T2       = 1.0 + CIGS_i * Vgs_eff;
        T3       = BechvbEdge * T1 * T2;
        T4       = lexp(T3);
        igs_mult = igtemp * NF * AechvbEdge * DLCIG_i;
        igs      = igs_mult * Vgs_noswap * Vgs_eff * T4;
        // Igd
        T2      = Vgd_noswap - Vfbsdr;
        Vgd_eff = sqrt(T2 * T2 + 1.0e-4);
        if (IGCLAMP == 1) begin
            T1 = hypsmooth((AIGD_i - BIGD_i * Vgd_eff), 1.0e-6);
            if (CIGD_i < 0.01) begin
                CIGD_i = 0.01;
            end
        end else begin
            T1 = AIGD_i - BIGD_i * Vgd_eff;
        end
        T2       = 1.0 + CIGD_i * Vgd_eff;
        T3       = BechvbEdge * T1 * T2;
        T4       = lexp(T3);
        igd_mult = igtemp * NF * AechvbEdge * DLCIGD_i;
        igd      = igd_mult * Vgd_noswap * Vgd_eff * T4;
    end
    end
    IGS  = devsign * igs;
    IGD  = devsign * igd;
    IGB  = devsign * igb;
    IGCS = devsign * igcs;
    IGCD = devsign * igcd;

    // GIDL and GISL currents, Ref: BSIM4
    igisl = 0.0;
    igidl = 0.0;
    if (GIDLMOD != 0) begin
        T0 = epsratio * TOXE;
        // GIDL
        if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0) || (CGIDL_i < 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-Vgd_noswap - EGIDL_i + Vfbsdr) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            if (CGIDL_i != 0.0) begin
                T3 = Vdb_noswap * Vdb_noswap * Vdb_noswap;
                T4 = CGIDL_i + abs(T3) + 1.0e-4;
                T5 = hypsmooth(T3 / T4, 1.0e-6) - 1.0e-6;
            end else begin
                T5 = 1.0;
            end
            T6 = AGIDL_i * Weff * T1 * lexp(-T2) * T5;
        end
        igidl = T6;
        // GISL
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0) || (CGISL_i < 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-Vgs_noswap - EGISL_i + Vfbsdr) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            if (CGISL_i != 0.0) begin
                T3 = Vsb_noswap * Vsb_noswap * Vsb_noswap;
                T4 = CGISL_i + abs(T3) + 1.0e-4;
                T5 = hypsmooth(T3 / T4, 1.0e-6) - 1.0e-6;
            end else begin
                T5 = 1.0;
            end
            T6 = AGISL_i * Weff * T1 * lexp(-T2) * T5;
        end
        igisl = T6;
    end
    IGIDL = devsign * NF * igidl;
    IGISL = devsign * NF * igisl;

    // Junction currents and capacitances
    // Source-side junction currents
    if (Isbs > 0.0) begin
        if (Vbs_jct < VjsmRev) begin
            T0  = Vbs_jct / Nvtms;
            T1  = lexp(T0) - 1.0;
            T2  = IVjsmRev + SslpRev * (Vbs_jct - VjsmRev);
            Ibs = T1 * T2;
        end else if (Vbs_jct <= VjsmFwd) begin
            T0  = Vbs_jct / Nvtms;
            T1  = (BVS + Vbs_jct) / Nvtms;
            T2  = lexp(-T1);
            Ibs = Isbs * (lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
        end else begin
            Ibs = IVjsmFwd + SslpFwd * (Vbs_jct - VjsmFwd);
        end
    end else begin
        Ibs = 0.0;
    end

    // Source-side junction tunneling currents
    if (JTSS_t > 0.0) begin
        if ((VTSS - Vbs_jct) < (VTSS * 1.0e-3)) begin
            T0  = -Vbs_jct / Vtm0 / NJTS_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibs = Ibs - ASeff * JTSS_t * T1;
        end else begin
            T0  = -Vbs_jct / Vtm0 / NJTS_t;
            T1  = lexp(T0 * VTSS / (VTSS - Vbs_jct)) - 1.0;
            Ibs = Ibs - ASeff * JTSS_t * T1;
        end
    end
    if (JTSSWS_t > 0.0) begin
        if ((VTSSWS - Vbs_jct) < (VTSSWS * 1.0e-3)) begin
            T0  = -Vbs_jct / Vtm0 / NJTSSW_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibs = Ibs - PSeff * JTSSWS_t * T1;
        end else begin
            T0  = -Vbs_jct / Vtm0 / NJTSSW_t;
            T1  = lexp(T0 * VTSSWS / (VTSSWS - Vbs_jct)) - 1.0;
            Ibs = Ibs - PSeff * JTSSWS_t * T1;
        end
    end
    if (JTSSWGS_t > 0.0) begin
        if((VTSSWGS - Vbs_jct) < (VTSSWGS * 1.0e-3)) begin
            T0  = -Vbs_jct / Vtm0 / NJTSSWG_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
        end else begin
            T0  = -Vbs_jct / Vtm0 / NJTSSWG_t;
            T1  = lexp(T0 * VTSSWGS / (VTSSWGS - Vbs_jct)) - 1.0;
            Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
        end
    end

    // Drain-side junction currents
    if (Isbd > 0.0) begin
        if (Vbd_jct < VjdmRev) begin
            T0  = Vbd_jct / Nvtmd;
            T1  = lexp(T0) - 1.0;
            T2  = IVjdmRev + DslpRev * (Vbd_jct - VjdmRev);
            Ibd = T1 * T2;
        end else if (Vbd_jct <= VjdmFwd) begin
            T0  = Vbd_jct / Nvtmd;
            T1  = (BVD + Vbd_jct) / Nvtmd;
            T2  = lexp(-T1);
            Ibd = Isbd * (lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
        end else begin
            Ibd = IVjdmFwd + DslpFwd * (Vbd_jct - VjdmFwd);
        end
    end else begin
        Ibd = 0.0;
    end

    // Drain-side junction tunneling currents
    if (JTSD_t > 0.0) begin
        if ((VTSD - Vbd_jct) < (VTSD * 1.0e-3)) begin
            T0  = -Vbd_jct / Vtm0 / NJTSD_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibd = Ibd - ADeff * JTSD_t * T1;
        end else begin
            T0  = -Vbd_jct / Vtm0 / NJTSD_t;
            T1  = lexp(T0 * VTSD/ (VTSD - Vbd_jct)) - 1.0;
            Ibd = Ibd - ADeff * JTSD_t * T1;
        end
    end
    if (JTSSWD_t > 0.0) begin
        if ((VTSSWD - Vbd_jct) < (VTSSWD * 1.0e-3)) begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWD_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibd = Ibd - PDeff * JTSSWD_t * T1;
        end else begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWD_t;
            T1  = lexp(T0 * VTSSWD / (VTSSWD - Vbd_jct)) - 1.0;
            Ibd = Ibd - PDeff * JTSSWD_t * T1;
        end
    end
    if (JTSSWGD_t > 0.0) begin
        if ((VTSSWGD - Vbd_jct) < (VTSSWGD * 1.0e-3)) begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWGD_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
        end else begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWGD_t;
            T1  = lexp(T0 * VTSSWGD / (VTSSWGD - Vbd_jct)) - 1.0;
            Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
        end
    end

    // Junction capacitances (no swapping)
    // Source-to-bulk junction
    Czbs       = CJS_t * ASeff;
    Czbssw     = CJSWS_t * PSeff;
    Czbsswg    = CJSWGS_t * Weffcj * NF;
    czbs_p1    = pow(0.1, -MJS);
    czbs_p2    = 1.0 / (1.0 - MJS) * (1.0 - 0.05 * MJS * (1.0 + MJS) * czbs_p1);
    czbssw_p1  = pow(0.1, -MJSWS);
    czbssw_p2  = 1.0 / (1.0 - MJSWS) * (1.0 - 0.05 * MJSWS * (1.0 + MJSWS) * czbssw_p1);
    czbsswg_p1 = pow(0.1, -MJSWGS);
    czbsswg_p2 = 1.0 / (1.0 - MJSWGS) * (1.0 - 0.05 * MJSWGS * (1.0 + MJSWGS) * czbsswg_p1);
    `JunCap(Czbs, Vbs_jct, PBS_t, MJS, czbs_p1, czbs_p2, Qbsj1)
    `JunCap(Czbssw, Vbs_jct, PBSWS_t, MJSWS, czbssw_p1, czbssw_p2, Qbsj2)
    `JunCap(Czbsswg, Vbs_jct, PBSWGS_t, MJSWGS, czbsswg_p1, czbsswg_p2, Qbsj3)
    Qbsj = Qbsj1 + Qbsj2 + Qbsj3;

    // Drain-to-bulk junction
    Czbd       = CJD_t * ADeff;
    Czbdsw     = CJSWD_t * PDeff;
    Czbdswg    = CJSWGD_t * Weffcj * NF;
    czbd_p1    = pow(0.1, -MJD);
    czbd_p2    = 1.0 / (1.0 - MJD) * (1.0 - 0.05 * MJD * (1.0 + MJD) * czbd_p1);
    czbdsw_p1  = pow(0.1, -MJSWD);
    czbdsw_p2  = 1.0 / (1.0 - MJSWD) * (1.0 - 0.05 * MJSWD * (1.0 + MJSWD) * czbdsw_p1);
    czbdswg_p1 = pow(0.1, -MJSWGD);
    czbdswg_p2 = 1.0 / (1.0 - MJSWGD) * (1.0 - 0.05 * MJSWGD * (1.0 + MJSWGD) * czbdswg_p1);
    `JunCap(Czbd, Vbd_jct, PBD_t, MJD, czbd_p1, czbd_p2, Qbdj1)
    `JunCap(Czbdsw, Vbd_jct, PBSWD_t, MJSWD, czbdsw_p1, czbdsw_p2, Qbdj2)
    `JunCap(Czbdswg, Vbd_jct, PBSWGD_t, MJSWGD, czbdswg_p1, czbdswg_p2, Qbdj3)
    Qbdj = Qbdj1 + Qbdj2 + Qbdj3;

    // Sub-surface leakage drain current
    if (SSLMOD != 0) begin
        T1 = pow(NDEP_i / 1.0e23, SSLEXP1);
        T2 = pow(300.0 / DevTemp, SSLEXP2);
        T3 = (devsign*SSL5 * V(bi,si)) / Vt;         
        SSL0_NT  = SSL0 * lexp(-T1 * T2);
        SSL1_NT  = SSL1 * T2 * T1;
        PHIB_SSL = SSL3 * tanh(lexp(devsign * SSL4 * (V(gi, bi) - VTH - V(si,bi))));
        Issl     = sigvds * NF * Weff * SSL0_NT * lexp(T3) * lexp(-SSL1_NT * Leff) * lexp(PHIB_SSL / Vt) * (lexp(SSL2 * Vdsx / Vt) - 1.0);
        I(di, si) <+ devsign * Issl;
    end

    // Harshit's new flicker noise model. Ref: H. Agarwal et. al., IEEE J-EDS, vol. 3, no. 4, April 2015.
    Nt      = 4.0 * Vt * `q;
    Esatnoi = 2.0 * VSAT_a / ueff;
    if (EM <= 0.0) begin
       DelClm = 0.0;
    end else begin
        T0     = (diffVds / litl + EM) / Esatnoi;
        DelClm = litl * lln(T0);
        if (DelClm < 0.0) begin
           DelClm = 0.0;
        end
    end
    Nstar = Vt / `q * (Cox + Cdep + CIT_i);
    Nl    = 2.0 * nq * Cox * Vt * qdeff * Mnud1 * Mnud / `q;
    T0a   = `q * `q * `q * Vt * abs(ids) * ueff;
    T0b   = `q * Vt * ids * ids;
    T0c   = NOIA + NOIB * Nl + NOIC * Nl * Nl;
    T0d   = (Nl + Nstar) * (Nl + Nstar);
    T0e   = NOIA * `q * Vt;
    if (FNOIMOD == 1) begin
        LH1 = LH;
        if (Leff > LH1) begin
            T0 = (Leff - LH1);
        end else begin
            LH1 = Leff;
            T0 = LH1;
        end            
        if(LINTNOI >= T0 / 2.0) begin
            $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative. Re-setting LINTNOI = 0.", LINTNOI);
            LINTNOI_i = 0.0;
        end else begin
            LINTNOI_i = LINTNOI;
        end
        LeffnoiH = Leff;
        vgfbh  = (Vg - VFB_i) / Vt;
        gam_h  = sqrt(2.0 * `q * epssi * HNDEP / Vt) / Cox;
        phib_h = ln(HNDEP / ni);

        // Pinch-Off potential for halo region
        `PO_psip(vgfbh, gam_h, 0.0, phib_h, psiph)

        // Normalized inversion charge at source end of halo MOSFET
        `BSIM_q(psiph, phib_h, vs, gam_h, qsh)
        nq_h = 1.0 + gam_h / (2.0 * sqrt(psiph));

        // Setting mobility of halo region equal to the mobility of the channel. In general, U0H < ueff
        U0_i_h  = ueff;
        beta_h  = U0_i_h * Cox * Weff;
        beta_ch = ueff * Cox * Weff;

        // Normalized drain current for halo transistor. Eq. (14) of the paper
        i1 = ids * LH1 / (2.0 * nq_h * beta_h * Vt * Vt);

        // Normalized drain current for channel transistor. Eq. (15) of the paper
        i2 = ids * (LeffnoiH - LH1) / (2.0 * nq * beta_ch * nVt * nVt);
        T0 = (1.0 + 4.0 * (qsh * qsh + qsh - i1));
        if (T0 < 1.0) begin
            qdh = 0.0;
        end else begin
            // Drain charge of halo transistor. Eq. (16) of the paper
            qdh = -0.5 + 0.5 * sqrt(T0);
        end

        // Source charge of channel transistor. Eq. (17) of the paper
        qsch   = -0.5 + 0.5 * sqrt(1.0 + 4.0 * (qdeff * qdeff + qdeff + i2));
        gds_h  = 2.0 * nq_h * beta_h * Vt * qdh;
        gds_ch = 2.0 * nq * beta_ch * Vt * qdeff;
        gm_ch  = 2.0 * beta_ch * Vt * (qsch - qdeff);
        R_ch   = gds_h * (LeffnoiH - LH1);
        R_h    = gm_ch * LH1 + gds_ch * LH1;
        t_tot  = 1.0 / (R_ch + R_h) / (R_ch + R_h);
        CF_ch  = R_ch * R_ch * t_tot;
        CF_h   = R_h * R_h * t_tot;

        // Local noise source
        if (Leff != LH1) begin
            Np2       = 2.0 * nq * Cox * Vt * qsch / `q;
            Leffnoi   = LeffnoiH - 2.0 * LINTNOI_i-LH1;
            Leffnoisq = Leffnoi * Leffnoi;
            // Channel transistor LNS
            T1     = 1.0e10 * Cox * Leffnoisq;
            T2     = NOIA * lln((Np2 + Nstar) / (Nl + Nstar));
            T3     = NOIB * (Np2 - Nl);
            T4     = 0.5 * NOIC * (Np2 * Np2 - Nl * Nl);
            T5     = 1.0e10 * Leffnoisq * Weff * NF;
            Ssi_ch = T0a / T1 * (T2 + T3 + T4) + T0b / T5 * DelClm * T0c / T0d;
            T6     = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
            Swi_ch = T0e / T6 * ids * ids;
            T7 = Swi_ch + Ssi_ch;
            if (T7 > 0.0)  begin
                FNPowerAt1Hz_ch = (Ssi_ch * Swi_ch) / T7;
            end else begin
                FNPowerAt1Hz_ch = 0.0;
            end
        end else begin
            FNPowerAt1Hz_ch = 0.0;
        end

        // Halo transistor LNS
        T8    = NOIA2 * `q * Vt;
        T9    = Weff * NF * LH1 * 1.0e10 * Nstar * Nstar;
        Swi_h = T8 / T9 * ids * ids;
        T10   = Swi_h;
        if (T10 > 0.0) begin
            FNPowerAt1Hz_h = Swi_h;
        end else begin
            FNPowerAt1Hz_h = 0.0;
        end
        // Overall noise
        FNPowerAt1Hz = FNPowerAt1Hz_ch * CF_ch + FNPowerAt1Hz_h * CF_h;
        I(di, si) <+ flicker_noise(sigvds*FNPowerAt1Hz, EF, "1overf");
    end else begin
        // Parameter checking
        if (LINTNOI >= Leff/2.0) begin
            $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative. Re-setting LINTNOI = 0.", LINTNOI);
            LINTNOI_i = 0.0;
        end else begin
            LINTNOI_i = LINTNOI;
        end
        if (NOIA > 0.0 || NOIB > 0.0 || NOIC > 0.0) begin
            Leffnoi   = Leff - 2.0 * LINTNOI_i;
            Leffnoisq = Leffnoi * Leffnoi;
            T0        = 1.0e10 * Cox * Leffnoisq;
            N0        = 2.0 * nq * Cox * Vt * qs * Mnud1 * Mnud / `q;
            T1        = NOIA * lln((N0 + Nstar) / (Nl + Nstar));
            T2        = NOIB * (N0 - Nl);
            T3        = 0.5 * NOIC * (N0 * N0 - Nl * Nl);
            T4        = 1.0e10 * Leffnoisq * Weff * NF;
            Ssi       = T0a / T0 * (T1 + T2 + T3) + T0b / T4 * DelClm * T0c / T0d;
            T5        = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
            Swi       = T0e / T5 * ids * ids;
            T6        = Swi + Ssi;
            if (T6 > 0.0) begin
                FNPowerAt1Hz = (Ssi * Swi) / T6/(1+NOIA1*pow((qs-qdeff),NOIAX));
            end else begin
                FNPowerAt1Hz = 0.0;
            end
        end else begin
            FNPowerAt1Hz = 0.0;
        end
        I(di, si) <+ flicker_noise(sigvds*FNPowerAt1Hz, EF, "1overf");
    end
    
    T0         = qia / Esatnoi / Leff;
    T1         = T0 * T0;
    T3         = RNOIA * (1.0 + TNOIA * Leff * T1);
    T4         = RNOIB * (1.0 + TNOIB * Leff * T1);
    T5         = RNOIK * (1.0 + TNOIK * Leff * T1);
    ctnoi      = RNOIC * (1.0 + TNOIC * Leff * T1);
    betanoisq  = 3.0 * T3 * T3;
    betanoisq  = (betanoisq - 1.0) * exp(-Leff / LP) + 1.0;
    betaLowId  = T5 * T5;
    thetanoisq = T4 * T4;
    cm_igid    = 0.0;
    case (TNOIMOD)
        0: begin
            QSi   = -NF * Weff * Leff * Cox * Vt * Qs;
            QDi   = -NF * Weff * Leff * Cox * Vt * Qd;
            T0    = ueff * abs(QSi + QDi);
            T1    = T0 * Rdsi + Leff * Leff;
            Gtnoi = (T0 / T1) * NTNOI;
            sidn  = Nt * Gtnoi;
            I(di, si) <+ white_noise(sidn, "id");
            V(N1)     <+ 0.0;
        end
        1: begin
            Vtn   = 2.0 * nq * nVt;
            T0    = ueff * Dptwg * Moc * Cox * Vtn;
            T1    = 0.5 * (qs + qdeff);
            T3    = T1 + 0.5;
            T4    = T3 * T3;
            T5    = T4 * T3;
            T6    = (qs - qdeff);
            T7    = T6 * T6;
            T8    = T7 * T6;
            T9    = (6.0 * T1 + 0.5) * T7;
            Lvsat = Leff * Dptwg;
            T10   = Lvsat / Leff;
            T12   = 1.0 + (betaLowId * (Vdseff / Vdssat) / (TNOIK2 + qia));
            T12   = ((T12 - 1.0) * exp(-Leff / LP)) + 1.0;
            `Smooth(T12, 0.0, 1.0e-1, T12)
            mid   = T0 * NF * Weff / Lvsat * (T1 * T12 + T7 * betanoisq / (12.0 * T3));
            mig   = Lvsat * T10 * T10 * (T1 / T4 - T9 / (60.0 * T4 * T4) + T7 * T7 / (144.0 * T4 * T5)) * 15.0 / 4.0 * thetanoisq / (NF * Weff * 12.0 * T0);
            migid = T10 * (T6 / (12.0 * T3) - T8 / (144.0 * T5)) * ctnoi / 0.395;
            sqid  = sqrt(Nt * mid);
            if (mig == 0.0) begin
                sqig    = 0.0;
                cm_igid = 0.0;
            end else begin
                sqig = sqrt(Nt / mig);
                if (sqid == 0.0) begin
                    cm_igid = 0.0;
                end else begin
                    cm_igid = migid * sqig / sqid;
                end
            end
            I(N2)     <+ white_noise(cm_igid, "corl");
            I(NI)     <+ white_noise(sqig * sqig * (1.0 - cm_igid), "corl");
            I(NI)     <+ -sqig * V(N2);
            I(NC)     <+ ddt(mig * Cox * Weff * NF * Leff * V(NC));
            I(di, si) <+ white_noise(sqid * sqid * (1.0 - cm_igid), "id");
            I(di, si) <+ sqid * V(N2);
            I(gi, si) <+ ddt(0.5 * ((1.0 + sigvds) * mig * Cox * Weff * NF * Leff * V(NC)));
            I(gi, di) <+ ddt(0.5 * ((1.0 - sigvds) * mig * Cox * Weff * NF * Leff * V(NC)));
        end
    endcase
    I(N2) <+ V(N2);
    I(NR) <+ V(NR);

    // Gate current shot noise
    if (IGCMOD != 0) begin
        I(gi, si) <+ white_noise(2.0 * `q * abs(igcs + igs), "igs");
        I(gi, di) <+ white_noise(2.0 * `q * abs(igcd + igd), "igd");
    end
    if (IGBMOD != 0) begin
        I(gi, bi) <+ white_noise(2.0 * `q * abs(igb), "igb");
    end
    
    // C-V model
    vgfbCV   = vgfb;
    gamg2    = (2.0 * `q * epssi * NGATE_i) / (Cox * Cox * Vt);
    invgamg2 = 0.0;
    if (CVMOD == 1) begin
        VFBCV_i = VFBCV_i + DELVTO;
        vg      = Vg * inv_Vt;
        vs      = Vs * inv_Vt;
        vfb     = VFBCV_i * inv_Vt;
        vgfbCV  = vg - vfb;
        phibCV    = lln(NDEPCV_i / ni);
        // Normalized body factor
        gamCV      = sqrt(2.0 * `q * epssi * NDEPCV_i * inv_Vt) / Cox;
        inv_gam  = 1.0 / gamCV;
        gamg2    = (2.0 * `q * epssi * NGATE_i) / (Cox * Cox * Vt);
        invgamg2 = (NGATE_i > 0.0) ? (1.0 / gamg2) : 0.0;
        DPD      = (NGATE_i > 0.0) ? (NDEPCV_i / NGATE_i) : 0.0;

        // psip: pinch-off voltage
        `PO_psip(vgfbCV, gamCV, DPD, phibCV, psip)

        // Normalized inversion charge at source end of channel
        `BSIM_q(psip, phibCV, vs, gamCV, qs)
        `Smooth(psip, 1.0, 2.0, psipclamp)
        sqrtpsip = sqrt(psipclamp);

        // Source side surface potential
        psiavg = psip - 2.0 * qs;
        `Smooth(psiavg, 1.0, 2.0, T0)
        nq = 1.0 + gamCV / (sqrtpsip + sqrt(T0));

        // Drain saturation voltage
        T0 = Vt * (vgfbCV - psip - 2.0 * qs * (nq - 1.0));
        `Smooth(T0, 0.0, 0.1, qbs)

        // Source side qi and qb for Vdsat (normalized to Cox)
        qis = 2.0 * nq * Vt * qs;
        Eeffs = EeffFactor * (qbs + eta_mu * qis);

        // Ref: BSIM4 mobility model
        T3 = (UA_a + UC_a * Vbsx) * pow(Eeffs, EU_t);
        T4 = 1.0 + T3;
        `Smooth(T4, 1.0, 0.0015, Dmobs)
        LambdaC_by2 = (U0_a / Dmobs) * Vt / (VSATCV_t * Lact);
        qdsat       = LambdaC_by2 * (qs * qs + qs) / (1.0 + LambdaC_by2 * (1.0 + qs));
        vdsatcv     = psip - 2.0 * phibCV - (2.0 * qdsat + lln((qdsat * 2.0 * nq * inv_gam) * ((qdsat * 2.0 * nq * inv_gam) + (gam / (nq - 1.0)))));
        VdsatCV     = vdsatcv * Vt;
        
        // Normalized charge qdeff at drain end of channel
        `Smooth(VdsatCV - Vs, 0.0, 1e-3, VdssatCV)
        VdssatCV     = VdssatCV / ABULK;
        T7     = pow(Vds / VdssatCV , 1.0 / DELTA_t);
        T8     = pow(1.0 + T7, -DELTA_t);
        Vdseff = Vds * T8;
        vdeff  = (Vdseff + Vs) * inv_Vt;
        `BSIM_q(psip, phibCV, vdeff, gamCV, qdeff)

        // Reevaluation of nq to include qdeff needed for gummel symmetry
        psiavg = psip - qs - qdeff - 1.0;
        `Smooth(psiavg, 1.0, 2.0, T0)
        T2 = sqrt(T0);
        T3 = 1.0 + DPD + gamCV / (sqrtpsip + T2);
        T4 = 0.5 + DPD * T2 * inv_gam;
        T5 = sqrt(T4 * T4 + T3 * (qs + qdeff) * invgamg2);
        nq = T3 / (T4 + T5);

        // C-V expressions including velocity saturation and CLM
        // Velocity saturation for C-V
        T0  = Vt * (vgfbCV - psip - 2.0 * qs * (nq - 1.0));
        `Smooth(T0, 0.0, 0.1, qbs)
        T1  = Vt * (vgfbCV - psip - 2.0 * qdeff * (nq - 1.0));
        `Smooth(T1, 0.0, 0.1, qbd)
        qb  = 0.5 * (qbs + qbd);
        qia = nq * Vt * (qs + qdeff);
        Eeffm = EeffFactor * (qb + eta_mu * qia);
       `PO_psip((vgfbCV + DELVFBACC * inv_Vt), gamCV, DPD, phibCV, psip)
        T3    = (UA_a + UC_a * Vbsx) * pow(Eeffm, EU_t);
        T4    = 1.0 + T3;
        `Smooth(T4, 1.0, 0.0015, Dmob)
        LambdaC = 2.0 * (U0_a / Dmob) * Vt / (VSATCV_t * Lact);
        dps     = qs - qdeff;
        T1      = 2.0 * (LambdaC * dps) * (LambdaC * dps);
        zsat    = sqrt(1.0 + T1);
        Dvsat   = 0.5 * (1.0 + zsat);
        // CLM for C-V
        Esat    = 2.0 * VSATCV_t / (U0_a / Dmob);
        EsatL   = Esat * Lact;
        Vasat   = VdssatCV + EsatL;
        diffVds = Vds - Vdseff;
    end
    if (PCLMCV_i != 0.0) begin
        MdL = 1.0 + PCLMCV_i * lln(1.0 + diffVds / PCLMCV_i / Vasat);
    end else begin
        MdL = 1.0;
    end
    MdL_2       = MdL * MdL;
    inv_MdL     = 1.0 / MdL;
    inv_MdL_2   = 1.0 / MdL_2;
    MdL_less_1  = MdL - 1.0;
    vgpqm = vgfbCV - psip;
    DQSD  = (qs - qdeff);
    DQSD2 = (qs - qdeff) * (qs - qdeff);
    sis   = vgpqm + 2.0 * qs;
    sid   = vgpqm + 2.0 * qdeff;
    `Smooth(sis, 0.0, 0.5, T1)
    `Smooth(sid, 0.0, 0.5, T2)
    Temps = sqrt(0.25 + T1 * invgamg2);
    Tempd = sqrt(0.25 + T2 * invgamg2);
    T1 = sis / (1.0 + 2.0 * Temps);
    T2 = sid / (1.0 + 2.0 * Tempd);
    T3 = Temps + Tempd;
    T4 = `Oneby3 * (DQSD2 / (T3 * T3 * T3));
    T5 = (ABULK*Dvsat * inv_MdL) / (1.0 + qs + qdeff);
    T6 = 0.8 * (T3 * T3 + Temps * Tempd) * T5;
    T7 = T6 + (2.0 * invgamg2);
    T8 = `Oneby3 * DQSD2 * T5;
    dqgeff = sid * (2.0 * Tempd - 1.0) / (2.0 * Tempd + 1.0);
    qbeff  = vgpqm - 2.0 * (nq - 1.0) * qdeff + dqgeff;
    Qb  = inv_MdL * (T1 + T2 + (T4 * T7 - nq * (qs + qdeff + T8))) + MdL_less_1 * qbeff;
    T9  = qs + qdeff;
    T10 = DQSD2 * T5 * T5;
    Qi  = nq * inv_MdL * (T9 + `Oneby3 * DQSD2 * T5) + 2.0 * nq * MdL_less_1 * qdeff;
    Qd1 = nq * inv_MdL_2 * (0.5 * T9 - (DQSD / 6.0) * (1.0 - DQSD * T5 - 0.2 * T10));
    Qd2 = nq * (MdL - inv_MdL) * qdeff;
    Qd  = Qd1 + Qd2;
    Qs  = Qi - Qd;

    // Quantum mechanical effects
    `Smooth(Vt * Qb, 0.0, 0.1, qbaCV)
    qiaCV      = Vt * (Qs + Qd);
    T0         = (qiaCV + ETAQM * qbaCV) / QM0;
    T1         = 1.0 + pow(T0, 0.7 * BDOS);
    XDCinv     = ADOS * 1.9e-9 / T1;
    Coxeffinv  = 3.9 * `EPS0 / (BSIMBULKTOXP * 3.9 / EPSROX + XDCinv / epsratio);
    QBi        = -NF * Wact * Lact * (`EPS0 * EPSROX / BSIMBULKTOXP) * Vt * Qb;
    WLCOXVtinv = NF * Wact * Lact * Coxeffinv * Vt;
    QSi        = -WLCOXVtinv * Qs;
    QDi        = -WLCOXVtinv * Qd;
    QGi        = -(QBi + QSi + QDi);

    // Outer fringing capacitances
    if (!$param_given(CF)) begin
        CF_i = 2.0 * EPSROX * `EPS0 / `M_PI * lln(CFRCOEFF * (1.0 + 0.4e-6 / TOXE));
    end
    Cgsof = CGSO + CF_i;
    Cgdof = CGDO + CF_i;

    // Overlap capacitances
    if (COVMOD == 0) begin
        Qovs = -Wact * NF * Cgsof * Vgs_ov_noswap;
        Qovd = -Wact * NF * Cgdof * Vgd_ov_noswap;
    end else begin
        T0    = sqrt((Vgs_ov_noswap - Vfbsdr + `DELTA_1) * (Vgs_ov_noswap - Vfbsdr + `DELTA_1) + 4.0 * `DELTA_1);
        Vgsov = 0.5 * (Vgs_ov_noswap - Vfbsdr + `DELTA_1 - T0);
        T1    = sqrt(1.0 - 4.0 * Vgsov / CKAPPAS_i);
        Qovs  = -Wact * NF * (Cgsof * Vgs_ov_noswap + CGSL_i * (Vgs_ov_noswap - Vfbsdr - Vgsov - 0.5 * CKAPPAS_i * (-1.0 + T1)));
        T0    = sqrt((Vgd_ov_noswap - Vfbsdr + `DELTA_1) * (Vgd_ov_noswap - Vfbsdr + `DELTA_1) + 4.0 * `DELTA_1);
        Vgdov = 0.5 * (Vgd_ov_noswap - Vfbsdr + `DELTA_1 - T0);
        T2    = sqrt(1.0 - 4.0 * Vgdov / CKAPPAD_i);
        Qovd  = -Wact * NF * (Cgdof * Vgd_ov_noswap + CGDL_i * (Vgd_ov_noswap - Vfbsdr - Vgdov - 0.5 * CKAPPAD_i * (-1.0 + T2)));
    end
    Qovb = -devsign * NF * Lact * CGBO * V(gm, bi);
    Qovg = -(Qovs + Qovd + Qovb);
        
    // Edge FET model
    if (EDGEFET == 1) begin
        phib_edge     = lln(NDEPEDGE_i / ni);
        Phist         = max(0.4 + Vt * phib_edge + PHIN_i, 0.4);
        sqrtPhist     = sqrt(Phist);
        T1DEP         = sqrt(2.0 * epssi / (`q * NDEPEDGE_i));
        NFACTOREDGE_t = NFACTOREDGE_i * hypsmooth((1.0 + TNFACTOREDGE_i * (TRatio - 1.0)), 1e-3);
        ETA0EDGE_t    = ETA0EDGE_i * (1.0 + TETA0EDGE_i * (TRatio - 1.0));
        `Smooth(Phist - Vbsx, 0.05, 0.1, PhistVbs)
        sqrtPhistVbs  = sqrt(PhistVbs);
        Xdep          = T1DEP * sqrtPhistVbs;
        Cdep          = epssi / Xdep;
        cdsc          = CITEDGE_i + NFACTOREDGE_t + CDSCDEDGE_i * Vdsx - CDSCBEDGE_i * Vbsx;
        T1            = 1.0 + cdsc/Cox;
        `Smooth(T1, 1.0, 0.05, n)
        nVt       = n * Vt;
        inv_nVt   = 1.0 / nVt;
        vg        = Vg * inv_nVt;
        vs        = Vs * inv_nVt;
        vfb       = VFB_i * inv_nVt;
        dvth_dibl = -(ETA0EDGE_t + ETABEDGE_i * Vbsx) * Vdsx;
        dvth_temp = (KT1EDGE_i + KT1LEDGE_i / Leff + KT2EDGE_i * Vbsx) * (pow(TRatio, KT1EXPEDGE_i) - 1.0);
        litl_edge = litl * (1.0 + DVT2EDGE * Vbsx);
        T0        = DVT1EDGE * Leff / litl_edge;
        if (T0 < 40.0) begin
            theta_sce_edge = 0.5 * DVT0EDGE / (cosh(T0) - 1.0);
        end else begin
            theta_sce_edge = DVT0EDGE * lexp(-T0);
        end
        dvth_sce  = theta_sce_edge * (Vbi_edge - Phist);
        Vth_shift = dvth_dibl - dvth_temp + dvth_sce + DVTEDGE + vth0_stress_EDGE - K2EDGE_i * Vbsx;
        vgfb      = vg - vfb - Vth_shift * inv_nVt;

        // Normalized body factor
        DGAMMAEDGE_i = DGAMMAEDGE * (1.0 + DGAMMAEDGEL * pow(Leff, -DGAMMAEDGELEXP));
        gam_edge          = sqrt(2.0 * `q * epssi * NDEPEDGE_i * inv_nVt) / Cox;
        gam_edge          = gam_edge * (1.0 + DGAMMAEDGE_i);
        inv_gam           = 1.0 / gam_edge;
        
        // psip: pinch-off voltage
        phib_n_edge  = phib_edge / n;
        `PO_psip(vgfb, gam_edge, 0.0, phib_n_edge, psip)
        
        
        `BSIM_q(psip, phib_n_edge, vs, gam_edge, qs_edge)

        // Approximate pinch-off voltage
        vdsatedge = 2.0 * nVt * qs_edge + 2.0 * nVt;
        Vdsatedge = vdsatedge;
        Vdsatedge = Vdsatedge + Vs;

        // Vdssat clamped to avoid negative values during transient simulation
        `Smooth(Vdsatedge - Vs, 0.0, 1.0e-3, Vdssate)
        T7     = pow(Vds / Vdssate, 1.0 / DELTA_t);
        T8     = pow(1.0 + T7, -DELTA_t);
        Vdseff = Vds * T8;
        vdeff  = (Vdseff + Vs) * inv_nVt;
        `BSIM_q(psip, phib_n_edge, vdeff, gam_edge, qdeff_edge)

        // Nq calculation for Edge FET
        `Smooth(psip, 1.0, 2.0, psipclamp)
        sqrtpsip = sqrt(psipclamp);
        psiavg   = psip - qs_edge - qdeff_edge -1.0;
        `Smooth(psiavg, 1.0, 2.0, T0)
        T2       = sqrt(T0);
        nq_edge  = 1.0 + gam_edge / (sqrtpsip + T2);
        ids_edge = 2.0 * NF * nq_edge * ueff * WEDGE / Leff * Cox * nVt * nVt * ((qs_edge - qdeff_edge) * (1.0 + qs_edge + qdeff_edge)) * Moc;
        ids      = ids_edge + ids;
        
        // Flickernoise calculation for Edge FET
        noia_edge      = NOIA * NEDGE;
        noib_edge      = NOIB * NEDGE;
        noic_edge      = NOIC * NEDGE;
        Leffnoi_edge   = Leff-2.0 * LINTNOI_i;
        Leffnoisq_edge = Leffnoi_edge*Leffnoi_edge;
        Nstar = Vt / `q * (Cox + Cdep + CITEDGE_i);
        Nl    = 2.0 * nq_edge * Cox * Vt * qdeff_edge / `q;
        T0a   = `q * `q * `q * Vt * abs(ids_edge) * ueff;
        T0b   = `q * Vt * ids_edge * ids_edge;
        T0c   = noia_edge + noib_edge * Nl + noic_edge * Nl * Nl;
        T0d   = (Nl + Nstar) * (Nl + Nstar);
        T0e   = noia_edge * `q * Vt;
        N0    = 2.0 * nq_edge * Cox * Vt * qs_edge / `q;
        T1    = noia_edge * lln((N0 + Nstar) / (Nl + Nstar));
        T2    = noib_edge * (N0 - Nl);
        T3    = 0.5 * noic_edge * (N0 * N0 - Nl * Nl);
        T4    = 1.0e10 * Leffnoisq_edge * WEDGE * NF;
        Ssi   = T0a / T0 * (T1 + T2 + T3) + T0b / T4 * DelClm * T0c / T0d;
        T5    = WEDGE * NF * Leffnoi_edge * 1.0e10 * Nstar * Nstar;
        Swi   = T0e / T5 * ids_edge * ids_edge;
        T6    = Swi + Ssi;
        if (T6 > 0.0) begin
            T7 = (Ssi * Swi) / T6;
            T8= 1.0 + NOIA1_EDGE * pow((qs_edge - qdeff_edge), NOIAX_EDGE);
            FNPowerAtedge = T7/T8;
        end else begin
            FNPowerAtedge = 0.0;
        end
        I(di, si) <+ flicker_noise(sigvds*FNPowerAtedge, EF, "1overf_edgefet");
    end
    // End of Edge FET parasitic device drain current model

    
    // Charge expressions including fringing and overlap capacitances
    QB = devsign * (QBi + Qovb + Qbsj + Qbdj);
    if (sigvds > 0) begin
        QSI = devsign * QSi;
        QDI = devsign * QDi;
        QS  = devsign * (QSi + Qovs - Qbsj);
        QD  = devsign * (QDi + Qovd - Qbdj);
    end else begin
        QSI = devsign * QDi;
        QDI = devsign * QSi;
        QS  = devsign * (QDi + Qovs - Qbsj);
        QD  = devsign * (QSi + Qovd - Qbdj);
    end
    QG = devsign * (QGi + Qovg);

    if (HVMOD == 1 && HVCAP == 1) begin
        Qovb = Qovb + QIOV;
        Qovd = Qovd + QBOV;
        if (HVCAPS == 1) begin
            Qovb = Qovb + QIOVS;
            Qovs = Qovs + QBOVS;
        end 
    end

    // Output
    // Intrinsic charges
    QBI = devsign * QBi;
    QGI = devsign * QGi;

    // QSI and QDI are defined above
    // Intrinsic capacitances
    CGSI = -ddx(QGI, V(si));
    CGDI = -ddx(QGI, V(di));
    CGBI = -ddx(QGI, V(bi));
    CGGI = ddx(QGI, V(gi));
    CSSI = ddx(QSI, V(si));
    CSDI = -ddx(QSI, V(di));
    CSBI = -ddx(QSI, V(bi));
    CSGI = -ddx(QSI, V(gi));
    CDSI = -ddx(QDI, V(si));
    CDDI = ddx(QDI, V(di));
    CDBI = -ddx(QDI, V(bi));
    CDGI = -ddx(QDI, V(gi));
    CBSI = -ddx(QBI, V(si));
    CBDI = -ddx(QBI, V(di));
    CBBI = ddx(QBI, V(bi));
    CBGI = -ddx(QBI, V(gi));

    // Total capacitances
    CGS = -ddx(QG, V(si));
    CGD = -ddx(QG, V(di));
    CGB = -ddx(QG, V(bi));
    CGG = CGGI + ddx(devsign * Qovg, V(gm));
    CSS = ddx(QS, V(si));
    CSD = -ddx(QS, V(di));
    CSB = CSBI - ddx((QS - QSI), V(sbulk));
    CSG = CSGI - ddx((QS - QSI), V(gm));
    CDS = -ddx(QD, V(si));
    CDD = ddx(QD, V(di));
    CDB = CDBI - ddx((QD - QDI), V(dbulk));
    CDG = CDGI - ddx((QD - QDI), V(gm));
    CBS = -ddx(QB, V(si));
    CBD = -ddx(QB, V(di));
    CBB = CBBI + ddx(QB, V(sbulk)) + ddx(QB, V(dbulk)) + ddx((devsign * Qovb), V(bi));
    CBG = -ddx(QB, V(gi)) - ddx((devsign * Qovb), V(gm));

    // Total extrinsic capacitance
    CGSEXT = -devsign * ddx(Qovg, V(si));  // Gate-to-source overlap + outer fringing
    CGDEXT = -devsign * ddx(Qovg, V(di));  // Gate-to-drain overlap + outer fringing
    CGBOV  = -devsign * ddx(Qovg, V(bi));  // Gate-to-body overlap

    // Total S/D junction capacitances
    CAPBS  = -devsign * ddx(Qbsj, V(si));
    CAPBD  = -devsign * ddx(Qbdj, V(di));

    // W & L
    WEFF   = Weff;  // Effective width for I-V
    LEFF   = Leff;  // Effective length for I-V
    WEFFCV = Wact;  // Effective width for C-V
    LEFFCV = Lact;  // Effective length for C-V

    // Currents and derivatives
    if (sigvds > 0) begin
        IDS   = devsign * ids;                       // Intrinsic drain-to-source current
        IDEFF = IDS - (IGD + IGCD) + ISUB + IGIDL;   // Total drain current
        ISEFF = -IDS - (IGS + IGCS) + IGISL;         // Total source current
    end else begin
        IDS   = -devsign * ids;                      // Intrinsic drain-to-source current
        IDEFF = IDS - (IGD + IGCD) + IGIDL;          // Total drain current
        ISEFF = -IDS - (IGS + IGCS) + ISUB + IGISL;  // Total source current
    end
    IGEFF = IGB + IGS + IGCS + IGD + IGCD;           // Total gate tunneling current
    IBS   = -devsign * Ibs;                          // Source junction current
    IBD   = -devsign * Ibd;                          // Source junction current
    VDS   = V(di, si);                               // Drain-to-source voltage
    VGS   = V(gi, si);
    VBS   = -V(si, bi);                              // Source-to-body voltage
    VDSAT = Vdssat;                                  // Drain-to-source saturation voltage
    GM    = ddx(IDS, V(gi));                         // Transconductance
    GMBS  = ddx(IDS, V(bi));                         // Body transconductance
    if (sigvds > 0)begin
        GDS   = ddx(IDS, V(di));                     // Output conductance
    end else begin
        GDS   = ddx(-IDS, V(si)); 
    end                         

    // Loading variables
    I(gi, bi) <+ ddt(QGI);
    I(si, bi) <+ ddt(QSI);
    I(di, bi) <+ ddt(QDI);
    I(gm, si) <+ ddt(-devsign * Qovs);
    I(gm, di) <+ ddt(-devsign * Qovd);
    I(gm, bi) <+ ddt(-devsign * Qovb);

    // Drain-to-source current
    I(di, si) <+ devsign * sigvds * ids;

    if (IGBMOD != 0) begin
        I(gi, bi) <+ IGB;
    end
    if (IGCMOD != 0) begin
        I(gi, si) <+ (IGS + IGCS);
        I(gi, di) <+ (IGD + IGCD);
    end
    if (sigvds > 0) begin
        I(di, bi) <+ ISUB + IGIDL;
        I(si, bi) <+ IGISL;
    end else begin
        I(di, bi) <+ IGIDL;
        I(si, bi) <+ ISUB + IGISL;
    end

    // External S/D resistances
    
    if (RDSMOD !=2 && RDrainGeo >0) begin
        gdpr = 1.0 / Rdrain;   // Note: gdpr considers all fingers
        I(d, di) <+ V(d, di) * gdpr;
        I(d, di) <+ white_noise(Nt * gdpr, "rd");
    end else begin
        V(d, di) <+ 0.0;
    end 
    
    if (RDSMOD !=2 && RSourceGeo >0) begin
        gspr = 1.0 / Rsource;   // Note: gspr considers all fingers
        I(s, si) <+ V(s, si) * gspr;
        I(s, si) <+ white_noise(Nt * gspr, "rs");
    end else begin
        V(s, si) <+ 0.0;
    end
        
        
    if (RGATEMOD == 0) begin
        V(g, gm) <+ 0.0;
    end else begin: rgate
        real Ggate, Gnoise;
        if (RGATEMOD == 2) begin
            Ggate  = Gcrg;
            Gnoise = Gcrg * Gcrg / Grgeltd;
        end else begin
            Ggate  = Grgeltd;
            Gnoise = Grgeltd;
        end
        I(g, gm) <+ V(g, gm) * Ggate;
        I(g, gm) <+ white_noise(Nt * Gnoise, "rg");
    end

    if (RGATEMOD == 3) begin
        I(gm, gi) <+ V(gm, gi) * Gcrg;
    end else begin
        V(gm, gi) <+ 0.0;
    end
    
    if ((SHMOD != 0) && (RTH0 > 0.0)) begin
        Pdiss = devsign * sigvds * ids * V(di, si);
        if (RDSMOD !=2 && RDrainGeo >0) begin
            Pdiss = Pdiss + V(d, di) * V(d, di) / Rdrain;
        end
        if (RDSMOD !=2 && RSourceGeo >0) begin
            Pdiss = Pdiss + V(s, si) * V(s, si) / Rsource;
        end
        Pwr(t) <+ delTemp1 * gth + ddt(delTemp1 * cth) - Pdiss;
    end else begin
        Temp(t) <+ 0.0;
    end
        
    if (RBODYMOD != 0) begin
        I(bi, sbulk) <+ V(bi, sbulk) * Grbps;
        I(b, sbulk)  <+ V(b, sbulk) * Grbsb;
        I(b, bi)     <+ V(b, bi) * Grbpb;
        I(b, dbulk)  <+ V(b, dbulk) * Grbdb;
        I(bi, dbulk) <+ V(bi, dbulk) * Grbpd;
        I(sbulk, bi) <+ white_noise(Nt * Grbps, "rbps");
        I(sbulk, b)  <+ white_noise(Nt * Grbsb, "rbsb");
        I(b, bi)     <+ white_noise(Nt * Grbpb, "rbpb");
        I(dbulk, bi) <+ white_noise(Nt * Grbpd, "rbpd");
        I(dbulk, b)  <+ white_noise(Nt * Grbdb, "rbdb");
    end else begin
        V(b, sbulk)  <+ 0.0;
        V(b, bi)     <+ 0.0;
        V(b, dbulk)  <+ 0.0;
    end

    // Diode currents and capacitances
    if (RBODYMOD != 0) begin
        I(sbulk, si) <+ devsign * Ibs + V(sbulk, si) * gmin;
        I(dbulk, di) <+ devsign * Ibd + V(dbulk, di) * gmin;
        I(sbulk, si) <+ devsign * ddt(Qbsj);
        I(dbulk, di) <+ devsign * ddt(Qbdj);
    end else begin
        I(bi, si) <+ devsign * Ibs + V(bi, si) * gmin;
        I(bi, di) <+ devsign * Ibd + V(bi, di) * gmin;
        I(bi, si) <+ devsign * ddt(Qbsj);
        I(bi, di) <+ devsign * ddt(Qbdj);
    end
end
endmodule
